
FreeRTOS_Peripheral_samg55.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000a25c  00400000  00400000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0040a25c  0040a25c  0001225c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000898  20000000  0040a264  00018000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00004688  20000898  0040ab00  00018898  2**3
                  ALLOC
  4 .stack        00003000  20004f20  0040f188  00018898  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00018898  2**0
                  CONTENTS, READONLY
  6 .comment      0000005b  00000000  00000000  000188c6  2**0
                  CONTENTS, READONLY
  7 .debug_info   00013b45  00000000  00000000  00018921  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003b7b  00000000  00000000  0002c466  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000995a  00000000  00000000  0002ffe1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000e00  00000000  00000000  0003993b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000cf0  00000000  00000000  0003a73b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00019352  00000000  00000000  0003b42b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00013a62  00000000  00000000  0005477d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0005861f  00000000  00000000  000681df  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003048  00000000  00000000  000c0800  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20007f20 	.word	0x20007f20
  400004:	00401751 	.word	0x00401751
  400008:	0040174d 	.word	0x0040174d
  40000c:	0040174d 	.word	0x0040174d
  400010:	0040174d 	.word	0x0040174d
  400014:	0040174d 	.word	0x0040174d
  400018:	0040174d 	.word	0x0040174d
	...
  40002c:	00401f29 	.word	0x00401f29
  400030:	0040174d 	.word	0x0040174d
  400034:	00000000 	.word	0x00000000
  400038:	00401fa1 	.word	0x00401fa1
  40003c:	00401ff1 	.word	0x00401ff1
  400040:	0040174d 	.word	0x0040174d
  400044:	0040174d 	.word	0x0040174d
  400048:	0040174d 	.word	0x0040174d
  40004c:	0040174d 	.word	0x0040174d
  400050:	0040174d 	.word	0x0040174d
  400054:	0040174d 	.word	0x0040174d
  400058:	0040174d 	.word	0x0040174d
  40005c:	0040115d 	.word	0x0040115d
  400060:	0040114d 	.word	0x0040114d
  400064:	0040174d 	.word	0x0040174d
  400068:	00000000 	.word	0x00000000
  40006c:	0040174d 	.word	0x0040174d
  400070:	0040174d 	.word	0x0040174d
  400074:	0040174d 	.word	0x0040174d
  400078:	0040174d 	.word	0x0040174d
  40007c:	0040174d 	.word	0x0040174d
  400080:	0040174d 	.word	0x0040174d
  400084:	0040174d 	.word	0x0040174d
  400088:	0040174d 	.word	0x0040174d
  40008c:	0040174d 	.word	0x0040174d
  400090:	0040174d 	.word	0x0040174d
  400094:	0040174d 	.word	0x0040174d
  400098:	0040174d 	.word	0x0040174d
  40009c:	0040174d 	.word	0x0040174d
  4000a0:	0040174d 	.word	0x0040174d
  4000a4:	0040174d 	.word	0x0040174d
  4000a8:	0040174d 	.word	0x0040174d
  4000ac:	0040174d 	.word	0x0040174d
  4000b0:	0040174d 	.word	0x0040174d
  4000b4:	0040174d 	.word	0x0040174d
  4000b8:	0040174d 	.word	0x0040174d
	...
  4000fc:	0040174d 	.word	0x0040174d
  400100:	0040174d 	.word	0x0040174d
  400104:	0040174d 	.word	0x0040174d
	...

00400148 <__do_global_dtors_aux>:
  400148:	b510      	push	{r4, lr}
  40014a:	4c05      	ldr	r4, [pc, #20]	; (400160 <__do_global_dtors_aux+0x18>)
  40014c:	7823      	ldrb	r3, [r4, #0]
  40014e:	b933      	cbnz	r3, 40015e <__do_global_dtors_aux+0x16>
  400150:	4b04      	ldr	r3, [pc, #16]	; (400164 <__do_global_dtors_aux+0x1c>)
  400152:	b113      	cbz	r3, 40015a <__do_global_dtors_aux+0x12>
  400154:	4804      	ldr	r0, [pc, #16]	; (400168 <__do_global_dtors_aux+0x20>)
  400156:	f3af 8000 	nop.w
  40015a:	2301      	movs	r3, #1
  40015c:	7023      	strb	r3, [r4, #0]
  40015e:	bd10      	pop	{r4, pc}
  400160:	20000898 	.word	0x20000898
  400164:	00000000 	.word	0x00000000
  400168:	0040a264 	.word	0x0040a264

0040016c <frame_dummy>:
  40016c:	4b08      	ldr	r3, [pc, #32]	; (400190 <frame_dummy+0x24>)
  40016e:	b510      	push	{r4, lr}
  400170:	b11b      	cbz	r3, 40017a <frame_dummy+0xe>
  400172:	4808      	ldr	r0, [pc, #32]	; (400194 <frame_dummy+0x28>)
  400174:	4908      	ldr	r1, [pc, #32]	; (400198 <frame_dummy+0x2c>)
  400176:	f3af 8000 	nop.w
  40017a:	4808      	ldr	r0, [pc, #32]	; (40019c <frame_dummy+0x30>)
  40017c:	6803      	ldr	r3, [r0, #0]
  40017e:	b903      	cbnz	r3, 400182 <frame_dummy+0x16>
  400180:	bd10      	pop	{r4, pc}
  400182:	4b07      	ldr	r3, [pc, #28]	; (4001a0 <frame_dummy+0x34>)
  400184:	2b00      	cmp	r3, #0
  400186:	d0fb      	beq.n	400180 <frame_dummy+0x14>
  400188:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  40018c:	4718      	bx	r3
  40018e:	bf00      	nop
  400190:	00000000 	.word	0x00000000
  400194:	0040a264 	.word	0x0040a264
  400198:	2000089c 	.word	0x2000089c
  40019c:	0040a264 	.word	0x0040a264
  4001a0:	00000000 	.word	0x00000000

004001a4 <freertos_twi_master_init>:
 *     be used with FreeRTOS TWI read and write functions is returned.  If
 *     the initialisation fails then NULL is returned.
 */
freertos_twi_if freertos_twi_master_init(Twi *p_twi,
		const freertos_peripheral_options_t *const freertos_driver_parameters)
{
  4001a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4001a8:	b083      	sub	sp, #12
  4001aa:	4681      	mov	r9, r0
  4001ac:	460d      	mov	r5, r1
	portBASE_TYPE twi_index;
	bool is_valid_operating_mode;
	freertos_twi_if return_value;
	const enum peripheral_operation_mode valid_operating_modes[] = {TWI_I2C_MASTER};
  4001ae:	ae02      	add	r6, sp, #8
  4001b0:	2303      	movs	r3, #3
  4001b2:	f806 3d04 	strb.w	r3, [r6, #-4]!

	/* Find the index into the all_twi_definitions array that holds details of
	the p_twi peripheral. */
	twi_index = get_pdc_peripheral_details(all_twi_definitions, MAX_TWIS,
  4001b6:	4834      	ldr	r0, [pc, #208]	; (400288 <freertos_twi_master_init+0xe4>)
  4001b8:	2108      	movs	r1, #8
  4001ba:	464a      	mov	r2, r9
  4001bc:	4b33      	ldr	r3, [pc, #204]	; (40028c <freertos_twi_master_init+0xe8>)
  4001be:	4798      	blx	r3
  4001c0:	4604      	mov	r4, r0
			(void *) p_twi);

	/* Check the requested operating mode is valid for the peripheral. */
	is_valid_operating_mode = check_requested_operating_mode(
  4001c2:	7b28      	ldrb	r0, [r5, #12]
  4001c4:	4631      	mov	r1, r6
  4001c6:	2201      	movs	r2, #1
  4001c8:	4b31      	ldr	r3, [pc, #196]	; (400290 <freertos_twi_master_init+0xec>)
  4001ca:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_twi pointer was used, and a valid
	operating mode was requested. */
	if ((twi_index < MAX_TWIS) && (is_valid_operating_mode == true)) {
  4001cc:	2c07      	cmp	r4, #7
  4001ce:	dc52      	bgt.n	400276 <freertos_twi_master_init+0xd2>
  4001d0:	2800      	cmp	r0, #0
  4001d2:	d053      	beq.n	40027c <freertos_twi_master_init+0xd8>
		/* This function must be called exactly once per supported twi.  Check
		it has not been called	before. */
		configASSERT(memcmp((void *)&(tx_dma_control[twi_index]),
  4001d4:	4b2f      	ldr	r3, [pc, #188]	; (400294 <freertos_twi_master_init+0xf0>)
  4001d6:	eb03 08c4 	add.w	r8, r3, r4, lsl #3
  4001da:	4640      	mov	r0, r8
  4001dc:	492e      	ldr	r1, [pc, #184]	; (400298 <freertos_twi_master_init+0xf4>)
  4001de:	2208      	movs	r2, #8
  4001e0:	4b2e      	ldr	r3, [pc, #184]	; (40029c <freertos_twi_master_init+0xf8>)
  4001e2:	4798      	blx	r3
  4001e4:	b120      	cbz	r0, 4001f0 <freertos_twi_master_init+0x4c>
  4001e6:	482e      	ldr	r0, [pc, #184]	; (4002a0 <freertos_twi_master_init+0xfc>)
  4001e8:	f44f 7181 	mov.w	r1, #258	; 0x102
  4001ec:	4b2d      	ldr	r3, [pc, #180]	; (4002a4 <freertos_twi_master_init+0x100>)
  4001ee:	4798      	blx	r3
				&null_dma_control,
				sizeof(null_dma_control)) == 0);
		configASSERT(memcmp((void *)&(rx_dma_control[twi_index]),
  4001f0:	4f2d      	ldr	r7, [pc, #180]	; (4002a8 <freertos_twi_master_init+0x104>)
  4001f2:	eb07 07c4 	add.w	r7, r7, r4, lsl #3
  4001f6:	4638      	mov	r0, r7
  4001f8:	4927      	ldr	r1, [pc, #156]	; (400298 <freertos_twi_master_init+0xf4>)
  4001fa:	2208      	movs	r2, #8
  4001fc:	4b27      	ldr	r3, [pc, #156]	; (40029c <freertos_twi_master_init+0xf8>)
  4001fe:	4798      	blx	r3
  400200:	b120      	cbz	r0, 40020c <freertos_twi_master_init+0x68>
  400202:	4827      	ldr	r0, [pc, #156]	; (4002a0 <freertos_twi_master_init+0xfc>)
  400204:	f240 1105 	movw	r1, #261	; 0x105
  400208:	4b26      	ldr	r3, [pc, #152]	; (4002a4 <freertos_twi_master_init+0x100>)
  40020a:	4798      	blx	r3
				sizeof(null_dma_control)) == 0);

		/* Enable the peripheral's clock. */
#if (SAMG55)
		/* Enable the peripheral and set TWI mode. */
		uint32_t temp = (uint32_t)(all_twi_definitions[twi_index].peripheral_base_address - 0x600);
  40020c:	4a1e      	ldr	r2, [pc, #120]	; (400288 <freertos_twi_master_init+0xe4>)
  40020e:	0123      	lsls	r3, r4, #4
  400210:	eb02 0b03 	add.w	fp, r2, r3
  400214:	58d6      	ldr	r6, [r2, r3]
		Flexcom *p_flexcom = (Flexcom *)temp;
  400216:	f5a6 6ac0 	sub.w	sl, r6, #1536	; 0x600
		flexcom_enable(p_flexcom);
  40021a:	4650      	mov	r0, sl
  40021c:	4b23      	ldr	r3, [pc, #140]	; (4002ac <freertos_twi_master_init+0x108>)
  40021e:	4798      	blx	r3
		flexcom_set_opmode(p_flexcom, FLEXCOM_TWI);
  400220:	4650      	mov	r0, sl
  400222:	2103      	movs	r1, #3
  400224:	4b22      	ldr	r3, [pc, #136]	; (4002b0 <freertos_twi_master_init+0x10c>)
  400226:	4798      	blx	r3
#else
		pmc_enable_periph_clk(
				all_twi_definitions[twi_index].peripheral_id);
#endif
		/* Ensure everything is disabled before configuration. */
		pdc_disable_transfer(
  400228:	f8db 0004 	ldr.w	r0, [fp, #4]
  40022c:	f240 2102 	movw	r1, #514	; 0x202
  400230:	4b20      	ldr	r3, [pc, #128]	; (4002b4 <freertos_twi_master_init+0x110>)
  400232:	4798      	blx	r3
				all_twi_definitions[twi_index].pdc_base_address,
				(PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS));
		twi_disable_interrupt(
  400234:	4630      	mov	r0, r6
  400236:	f04f 31ff 	mov.w	r1, #4294967295
  40023a:	4b1f      	ldr	r3, [pc, #124]	; (4002b8 <freertos_twi_master_init+0x114>)
  40023c:	4798      	blx	r3
				all_twi_definitions[twi_index].peripheral_base_address,
				MASK_ALL_INTERRUPTS);
		twi_reset(
  40023e:	4630      	mov	r0, r6
  400240:	4b1e      	ldr	r3, [pc, #120]	; (4002bc <freertos_twi_master_init+0x118>)
  400242:	4798      	blx	r3
				all_twi_definitions[twi_index].peripheral_base_address);

		switch (freertos_driver_parameters->operation_mode) {
  400244:	7b2b      	ldrb	r3, [r5, #12]
  400246:	2b03      	cmp	r3, #3
  400248:	d102      	bne.n	400250 <freertos_twi_master_init+0xac>
		case TWI_I2C_MASTER:
			/* Call the standard ASF init function. */
			twi_enable_master_mode(
  40024a:	4630      	mov	r0, r6
  40024c:	4b1c      	ldr	r3, [pc, #112]	; (4002c0 <freertos_twi_master_init+0x11c>)
  40024e:	4798      	blx	r3
		}

		/* Create any required peripheral access mutexes and transaction complete
		semaphores.  This peripheral is half duplex so only a single access
		mutex is required. */
		create_peripheral_control_semaphores(
  400250:	7b68      	ldrb	r0, [r5, #13]
  400252:	4641      	mov	r1, r8
  400254:	463a      	mov	r2, r7
  400256:	4b1b      	ldr	r3, [pc, #108]	; (4002c4 <freertos_twi_master_init+0x120>)
  400258:	4798      	blx	r3
				freertos_driver_parameters->options_flags,
				&(tx_dma_control[twi_index]),
				&(rx_dma_control[twi_index]));

		/* Error interrupts are always enabled. */
		twi_enable_interrupt(
  40025a:	4630      	mov	r0, r6
  40025c:	f44f 7150 	mov.w	r1, #832	; 0x340
  400260:	4b19      	ldr	r3, [pc, #100]	; (4002c8 <freertos_twi_master_init+0x124>)
  400262:	4798      	blx	r3
				all_twi_definitions[twi_index].peripheral_base_address,
				IER_ERROR_INTERRUPTS);

		/* Configure and enable the TWI interrupt in the interrupt controller. */
		configure_interrupt_controller(
  400264:	4b08      	ldr	r3, [pc, #32]	; (400288 <freertos_twi_master_init+0xe4>)
  400266:	eb03 1404 	add.w	r4, r3, r4, lsl #4
  40026a:	f994 000c 	ldrsb.w	r0, [r4, #12]
  40026e:	68a9      	ldr	r1, [r5, #8]
  400270:	4b16      	ldr	r3, [pc, #88]	; (4002cc <freertos_twi_master_init+0x128>)
  400272:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_twi pointer was used, and a valid
	operating mode was requested. */
	if ((twi_index < MAX_TWIS) && (is_valid_operating_mode == true)) {
  400274:	e004      	b.n	400280 <freertos_twi_master_init+0xdc>
				all_twi_definitions[twi_index].peripheral_irq,
				freertos_driver_parameters->interrupt_priority);

		return_value = (freertos_twi_if) p_twi;
	} else {
		return_value = NULL;
  400276:	f04f 0900 	mov.w	r9, #0
  40027a:	e001      	b.n	400280 <freertos_twi_master_init+0xdc>
  40027c:	f04f 0900 	mov.w	r9, #0
	}

	return return_value;
}
  400280:	4648      	mov	r0, r9
  400282:	b003      	add	sp, #12
  400284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400288:	004094ac 	.word	0x004094ac
  40028c:	004007fd 	.word	0x004007fd
  400290:	0040082d 	.word	0x0040082d
  400294:	20000934 	.word	0x20000934
  400298:	0040952c 	.word	0x0040952c
  40029c:	0040403d 	.word	0x0040403d
  4002a0:	00409534 	.word	0x00409534
  4002a4:	00403de1 	.word	0x00403de1
  4002a8:	200008b4 	.word	0x200008b4
  4002ac:	004012dd 	.word	0x004012dd
  4002b0:	00401459 	.word	0x00401459
  4002b4:	00401499 	.word	0x00401499
  4002b8:	004005d5 	.word	0x004005d5
  4002bc:	004005e5 	.word	0x004005e5
  4002c0:	004004b1 	.word	0x004004b1
  4002c4:	00400861 	.word	0x00400861
  4002c8:	004005d1 	.word	0x004005d1
  4002cc:	00400915 	.word	0x00400915

004002d0 <freertos_twi_read_packet_async>:
 *     the PDC was successfully configured to perform the TWI read operation.
 */
status_code_t freertos_twi_read_packet_async(freertos_twi_if p_twi,
		twi_packet_t *p_packet, portTickType block_time_ticks,
		xSemaphoreHandle notification_semaphore)
{
  4002d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4002d4:	b085      	sub	sp, #20
  4002d6:	4604      	mov	r4, r0
  4002d8:	460f      	mov	r7, r1
  4002da:	9203      	str	r2, [sp, #12]
  4002dc:	4698      	mov	r8, r3
	portBASE_TYPE twi_index;
	Twi *twi_base;
	uint32_t internal_address = 0;

	twi_base = (Twi *) p_twi;
	twi_index = get_pdc_peripheral_details(all_twi_definitions, MAX_TWIS,
  4002de:	4868      	ldr	r0, [pc, #416]	; (400480 <freertos_twi_read_packet_async+0x1b0>)
  4002e0:	2108      	movs	r1, #8
  4002e2:	4622      	mov	r2, r4
  4002e4:	4b67      	ldr	r3, [pc, #412]	; (400484 <freertos_twi_read_packet_async+0x1b4>)
  4002e6:	4798      	blx	r3
  4002e8:	4606      	mov	r6, r0
			(void *) twi_base);

	/* Don't do anything unless a valid TWI pointer was used. */
	if ((twi_index < MAX_TWIS) && (p_packet->length > 0)) {
  4002ea:	2807      	cmp	r0, #7
  4002ec:	f300 80c0 	bgt.w	400470 <freertos_twi_read_packet_async+0x1a0>
  4002f0:	68fb      	ldr	r3, [r7, #12]
  4002f2:	2b00      	cmp	r3, #0
  4002f4:	f000 80be 	beq.w	400474 <freertos_twi_read_packet_async+0x1a4>
		/* Because the peripheral is half duplex, there is only one access mutex
		and the rx uses the tx mutex. */
		return_value = freertos_obtain_peripheral_access_mutex(
  4002f8:	4863      	ldr	r0, [pc, #396]	; (400488 <freertos_twi_read_packet_async+0x1b8>)
  4002fa:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
  4002fe:	a903      	add	r1, sp, #12
  400300:	4b62      	ldr	r3, [pc, #392]	; (40048c <freertos_twi_read_packet_async+0x1bc>)
  400302:	4798      	blx	r3
				&(tx_dma_control[twi_index]), &block_time_ticks);

		if (return_value == STATUS_OK) {
  400304:	4605      	mov	r5, r0
  400306:	2800      	cmp	r0, #0
  400308:	f040 80b6 	bne.w	400478 <freertos_twi_read_packet_async+0x1a8>
			/* Ensure Rx is already empty. */
			twi_read_byte(twi_base);
  40030c:	4620      	mov	r0, r4
  40030e:	4b60      	ldr	r3, [pc, #384]	; (400490 <freertos_twi_read_packet_async+0x1c0>)
  400310:	4798      	blx	r3

			/* Set read mode and slave address. */
			twi_base->TWI_MMR = 0;
  400312:	2300      	movs	r3, #0
  400314:	6063      	str	r3, [r4, #4]
			twi_base->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(
					p_packet->chip) |
					((p_packet->addr_length <<
  400316:	687b      	ldr	r3, [r7, #4]
  400318:	021b      	lsls	r3, r3, #8
					TWI_MMR_IADRSZ_Pos) &
  40031a:	f403 7340 	and.w	r3, r3, #768	; 0x300
  40031e:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
			/* Ensure Rx is already empty. */
			twi_read_byte(twi_base);

			/* Set read mode and slave address. */
			twi_base->TWI_MMR = 0;
			twi_base->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(
  400322:	7c3b      	ldrb	r3, [r7, #16]
  400324:	041b      	lsls	r3, r3, #16
					p_packet->chip) |
  400326:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  40032a:	4313      	orrs	r3, r2
			/* Ensure Rx is already empty. */
			twi_read_byte(twi_base);

			/* Set read mode and slave address. */
			twi_base->TWI_MMR = 0;
			twi_base->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(
  40032c:	6063      	str	r3, [r4, #4]
					((p_packet->addr_length <<
					TWI_MMR_IADRSZ_Pos) &
					TWI_MMR_IADRSZ_Msk);

			/* Set internal address if any. */
			if (p_packet->addr_length) {
  40032e:	687a      	ldr	r2, [r7, #4]
  400330:	b15a      	cbz	r2, 40034a <freertos_twi_read_packet_async+0x7a>
				internal_address = p_packet->addr [0];
  400332:	783b      	ldrb	r3, [r7, #0]
				if (p_packet->addr_length > 1) {
  400334:	2a01      	cmp	r2, #1
					internal_address <<= 8;
					internal_address |= p_packet->addr[1];
  400336:	bf84      	itt	hi
  400338:	7879      	ldrbhi	r1, [r7, #1]
  40033a:	ea41 2303 	orrhi.w	r3, r1, r3, lsl #8
				}

				if (p_packet->addr_length > 2) {
  40033e:	2a02      	cmp	r2, #2
  400340:	d904      	bls.n	40034c <freertos_twi_read_packet_async+0x7c>
					internal_address <<= 8;
					internal_address |= p_packet->addr[2];
  400342:	78ba      	ldrb	r2, [r7, #2]
  400344:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
  400348:	e000      	b.n	40034c <freertos_twi_read_packet_async+0x7c>
		xSemaphoreHandle notification_semaphore)
{
	status_code_t return_value;
	portBASE_TYPE twi_index;
	Twi *twi_base;
	uint32_t internal_address = 0;
  40034a:	2300      	movs	r3, #0
				if (p_packet->addr_length > 2) {
					internal_address <<= 8;
					internal_address |= p_packet->addr[2];
				}
			}
			twi_base->TWI_IADR = internal_address;
  40034c:	60e3      	str	r3, [r4, #12]

			if (p_packet->length <= 2) {
  40034e:	68fa      	ldr	r2, [r7, #12]
  400350:	2a02      	cmp	r2, #2
  400352:	d86b      	bhi.n	40042c <freertos_twi_read_packet_async+0x15c>
				/* Do not handle errors for short packets in interrupt handler */
				twi_disable_interrupt(
						all_twi_definitions[twi_index].peripheral_base_address,
  400354:	0133      	lsls	r3, r6, #4
  400356:	4a4a      	ldr	r2, [pc, #296]	; (400480 <freertos_twi_read_packet_async+0x1b0>)
  400358:	f852 8003 	ldr.w	r8, [r2, r3]
			}
			twi_base->TWI_IADR = internal_address;

			if (p_packet->length <= 2) {
				/* Do not handle errors for short packets in interrupt handler */
				twi_disable_interrupt(
  40035c:	4640      	mov	r0, r8
  40035e:	f44f 7150 	mov.w	r1, #832	; 0x340
  400362:	4b4c      	ldr	r3, [pc, #304]	; (400494 <freertos_twi_read_packet_async+0x1c4>)
  400364:	4798      	blx	r3
						all_twi_definitions[twi_index].peripheral_base_address,
						IER_ERROR_INTERRUPTS);

				/* Cannot use PDC transfer, use normal transfer */
				uint8_t stop_sent = 0;
				uint32_t cnt = p_packet->length;
  400366:	68fb      	ldr	r3, [r7, #12]
				uint32_t status;
				uint8_t *buffer = p_packet->buffer;
  400368:	68b8      	ldr	r0, [r7, #8]
				uint32_t timeout_counter = 0;

				/* Start the transfer. */
				if (cnt == 1) {
  40036a:	2b01      	cmp	r3, #1
  40036c:	d10f      	bne.n	40038e <freertos_twi_read_packet_async+0xbe>
					twi_base->TWI_CR = TWI_CR_START | TWI_CR_STOP;
  40036e:	2203      	movs	r2, #3
  400370:	6022      	str	r2, [r4, #0]
					stop_sent = 1;
  400372:	f04f 0e01 	mov.w	lr, #1
  400376:	e7ff      	b.n	400378 <freertos_twi_read_packet_async+0xa8>
				} else {
					twi_base->TWI_CR = TWI_CR_START;
				}

				while (cnt > 0) {
					status = twi_base->TWI_SR;
  400378:	6a22      	ldr	r2, [r4, #32]
					if (status & TWI_SR_NACK) {
  40037a:	f412 7f80 	tst.w	r2, #256	; 0x100
  40037e:	d111      	bne.n	4003a4 <freertos_twi_read_packet_async+0xd4>
  400380:	2100      	movs	r1, #0
						xSemaphoreGive(tx_dma_control[twi_index].peripheral_access_mutex);
						return ERR_BUSY;
					}
					/* Last byte ? */
					if (cnt == 1 && !stop_sent) {
						twi_base->TWI_CR = TWI_CR_STOP;
  400382:	f04f 0902 	mov.w	r9, #2
						stop_sent = 1;
  400386:	f04f 0c01 	mov.w	ip, #1
						}
						continue;
					}
					*buffer++ = twi_base->TWI_RHR;
					cnt--;
					timeout_counter = 0;
  40038a:	460f      	mov	r7, r1
  40038c:	e01a      	b.n	4003c4 <freertos_twi_read_packet_async+0xf4>
				/* Start the transfer. */
				if (cnt == 1) {
					twi_base->TWI_CR = TWI_CR_START | TWI_CR_STOP;
					stop_sent = 1;
				} else {
					twi_base->TWI_CR = TWI_CR_START;
  40038e:	2201      	movs	r2, #1
  400390:	6022      	str	r2, [r4, #0]
				twi_disable_interrupt(
						all_twi_definitions[twi_index].peripheral_base_address,
						IER_ERROR_INTERRUPTS);

				/* Cannot use PDC transfer, use normal transfer */
				uint8_t stop_sent = 0;
  400392:	f04f 0e00 	mov.w	lr, #0
					stop_sent = 1;
				} else {
					twi_base->TWI_CR = TWI_CR_START;
				}

				while (cnt > 0) {
  400396:	2b00      	cmp	r3, #0
  400398:	d1ee      	bne.n	400378 <freertos_twi_read_packet_async+0xa8>
  40039a:	e02c      	b.n	4003f6 <freertos_twi_read_packet_async+0x126>
					status = twi_base->TWI_SR;
  40039c:	6a22      	ldr	r2, [r4, #32]
					if (status & TWI_SR_NACK) {
  40039e:	f412 7f80 	tst.w	r2, #256	; 0x100
  4003a2:	d00f      	beq.n	4003c4 <freertos_twi_read_packet_async+0xf4>
						/* Re-enable interrupts */
						twi_enable_interrupt(
  4003a4:	4640      	mov	r0, r8
  4003a6:	f44f 7150 	mov.w	r1, #832	; 0x340
  4003aa:	4b3b      	ldr	r3, [pc, #236]	; (400498 <freertos_twi_read_packet_async+0x1c8>)
  4003ac:	4798      	blx	r3
								all_twi_definitions[twi_index].peripheral_base_address,
								IER_ERROR_INTERRUPTS);
						/* Release semaphore */
						xSemaphoreGive(tx_dma_control[twi_index].peripheral_access_mutex);
  4003ae:	4b36      	ldr	r3, [pc, #216]	; (400488 <freertos_twi_read_packet_async+0x1b8>)
  4003b0:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  4003b4:	6870      	ldr	r0, [r6, #4]
  4003b6:	2100      	movs	r1, #0
  4003b8:	460a      	mov	r2, r1
  4003ba:	460b      	mov	r3, r1
  4003bc:	4c37      	ldr	r4, [pc, #220]	; (40049c <freertos_twi_read_packet_async+0x1cc>)
  4003be:	47a0      	blx	r4
						return ERR_BUSY;
  4003c0:	20f6      	movs	r0, #246	; 0xf6
  4003c2:	e059      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
					}
					/* Last byte ? */
					if (cnt == 1 && !stop_sent) {
  4003c4:	2b01      	cmp	r3, #1
  4003c6:	d105      	bne.n	4003d4 <freertos_twi_read_packet_async+0x104>
  4003c8:	f1be 0f00 	cmp.w	lr, #0
  4003cc:	d102      	bne.n	4003d4 <freertos_twi_read_packet_async+0x104>
						twi_base->TWI_CR = TWI_CR_STOP;
  4003ce:	f8c4 9000 	str.w	r9, [r4]
						stop_sent = 1;
  4003d2:	46e6      	mov	lr, ip
					}
					if (!(status & TWI_SR_RXRDY)) {
  4003d4:	f012 0f02 	tst.w	r2, #2
  4003d8:	d104      	bne.n	4003e4 <freertos_twi_read_packet_async+0x114>
						if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4003da:	3101      	adds	r1, #1
  4003dc:	f1b1 3fff 	cmp.w	r1, #4294967295
  4003e0:	d105      	bne.n	4003ee <freertos_twi_read_packet_async+0x11e>
  4003e2:	e007      	b.n	4003f4 <freertos_twi_read_packet_async+0x124>
							return_value = ERR_TIMEOUT;
							break;
						}
						continue;
					}
					*buffer++ = twi_base->TWI_RHR;
  4003e4:	6b22      	ldr	r2, [r4, #48]	; 0x30
  4003e6:	7002      	strb	r2, [r0, #0]
					cnt--;
  4003e8:	3b01      	subs	r3, #1
							return_value = ERR_TIMEOUT;
							break;
						}
						continue;
					}
					*buffer++ = twi_base->TWI_RHR;
  4003ea:	3001      	adds	r0, #1
					cnt--;
					timeout_counter = 0;
  4003ec:	4639      	mov	r1, r7
					stop_sent = 1;
				} else {
					twi_base->TWI_CR = TWI_CR_START;
				}

				while (cnt > 0) {
  4003ee:	2b00      	cmp	r3, #0
  4003f0:	d1d4      	bne.n	40039c <freertos_twi_read_packet_async+0xcc>
  4003f2:	e000      	b.n	4003f6 <freertos_twi_read_packet_async+0x126>
						twi_base->TWI_CR = TWI_CR_STOP;
						stop_sent = 1;
					}
					if (!(status & TWI_SR_RXRDY)) {
						if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
							return_value = ERR_TIMEOUT;
  4003f4:	25fd      	movs	r5, #253	; 0xfd
					timeout_counter = 0;
				}

				timeout_counter = 0;
				/* Wait for stop to be sent */
				while (!(twi_base->TWI_SR & TWI_SR_TXCOMP)) {
  4003f6:	f04f 33ff 	mov.w	r3, #4294967295
  4003fa:	e001      	b.n	400400 <freertos_twi_read_packet_async+0x130>
					/* Check timeout condition. */
					if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4003fc:	3b01      	subs	r3, #1
  4003fe:	d004      	beq.n	40040a <freertos_twi_read_packet_async+0x13a>
					timeout_counter = 0;
				}

				timeout_counter = 0;
				/* Wait for stop to be sent */
				while (!(twi_base->TWI_SR & TWI_SR_TXCOMP)) {
  400400:	6a22      	ldr	r2, [r4, #32]
  400402:	f012 0f01 	tst.w	r2, #1
  400406:	d0f9      	beq.n	4003fc <freertos_twi_read_packet_async+0x12c>
  400408:	e000      	b.n	40040c <freertos_twi_read_packet_async+0x13c>
					/* Check timeout condition. */
					if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
						return_value = ERR_TIMEOUT;
  40040a:	25fd      	movs	r5, #253	; 0xfd
						break;
					}
				}
				/* Re-enable interrupts */
				twi_enable_interrupt(
  40040c:	4640      	mov	r0, r8
  40040e:	f44f 7150 	mov.w	r1, #832	; 0x340
  400412:	4b21      	ldr	r3, [pc, #132]	; (400498 <freertos_twi_read_packet_async+0x1c8>)
  400414:	4798      	blx	r3
						all_twi_definitions[twi_index].peripheral_base_address,
						IER_ERROR_INTERRUPTS);
				/* Release semaphores */
				xSemaphoreGive(tx_dma_control[twi_index].peripheral_access_mutex);
  400416:	4b1c      	ldr	r3, [pc, #112]	; (400488 <freertos_twi_read_packet_async+0x1b8>)
  400418:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  40041c:	6870      	ldr	r0, [r6, #4]
  40041e:	2100      	movs	r1, #0
  400420:	460a      	mov	r2, r1
  400422:	460b      	mov	r3, r1
  400424:	4c1d      	ldr	r4, [pc, #116]	; (40049c <freertos_twi_read_packet_async+0x1cc>)
  400426:	47a0      	blx	r4
  400428:	4628      	mov	r0, r5
  40042a:	e025      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
			} else {
				/* Start the PDC reception. */
				twis[twi_index].buffer = p_packet->buffer;
  40042c:	68b9      	ldr	r1, [r7, #8]
  40042e:	4b1c      	ldr	r3, [pc, #112]	; (4004a0 <freertos_twi_read_packet_async+0x1d0>)
  400430:	f843 1036 	str.w	r1, [r3, r6, lsl #3]
				twis[twi_index].length = p_packet->length;
  400434:	00f0      	lsls	r0, r6, #3
  400436:	4403      	add	r3, r0
  400438:	605a      	str	r2, [r3, #4]
				freertos_start_pdc_rx(&(rx_dma_control[twi_index]),
  40043a:	4d1a      	ldr	r5, [pc, #104]	; (4004a4 <freertos_twi_read_packet_async+0x1d4>)
  40043c:	4405      	add	r5, r0
  40043e:	4b10      	ldr	r3, [pc, #64]	; (400480 <freertos_twi_read_packet_async+0x1b0>)
  400440:	eb03 1606 	add.w	r6, r3, r6, lsl #4
  400444:	6873      	ldr	r3, [r6, #4]
  400446:	f8cd 8000 	str.w	r8, [sp]
  40044a:	2000      	movs	r0, #0
  40044c:	9001      	str	r0, [sp, #4]
  40044e:	4628      	mov	r0, r5
  400450:	3a02      	subs	r2, #2
  400452:	4e15      	ldr	r6, [pc, #84]	; (4004a8 <freertos_twi_read_packet_async+0x1d8>)
  400454:	47b0      	blx	r6
						p_packet->buffer, (p_packet->length)-2,
						all_twi_definitions[twi_index].pdc_base_address,
						notification_semaphore);

				/* Start the transfer. */
				twi_base->TWI_CR = TWI_CR_START;
  400456:	2301      	movs	r3, #1
  400458:	6023      	str	r3, [r4, #0]
				/* Catch the end of reception so the access mutex can be returned,
				and the task notified (if it supplied a notification semaphore).
				The interrupt can be enabled here because the ENDRX	signal from the
				PDC to the peripheral will have been de-asserted when the next
				transfer was configured. */
				twi_enable_interrupt(twi_base, TWI_IER_ENDRX);
  40045a:	4620      	mov	r0, r4
  40045c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  400460:	4b0d      	ldr	r3, [pc, #52]	; (400498 <freertos_twi_read_packet_async+0x1c8>)
  400462:	4798      	blx	r3

				return_value = freertos_optionally_wait_transfer_completion(
  400464:	4628      	mov	r0, r5
  400466:	4641      	mov	r1, r8
  400468:	9a03      	ldr	r2, [sp, #12]
  40046a:	4b10      	ldr	r3, [pc, #64]	; (4004ac <freertos_twi_read_packet_async+0x1dc>)
  40046c:	4798      	blx	r3
  40046e:	e003      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
						notification_semaphore,
						block_time_ticks);
			}
		}
	} else {
		return_value = ERR_INVALID_ARG;
  400470:	20f8      	movs	r0, #248	; 0xf8
  400472:	e001      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
  400474:	20f8      	movs	r0, #248	; 0xf8
  400476:	e7ff      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
	}

	return return_value;
}
  400478:	b240      	sxtb	r0, r0
  40047a:	b005      	add	sp, #20
  40047c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  400480:	004094ac 	.word	0x004094ac
  400484:	004007fd 	.word	0x004007fd
  400488:	20000934 	.word	0x20000934
  40048c:	00400a05 	.word	0x00400a05
  400490:	004005dd 	.word	0x004005dd
  400494:	004005d5 	.word	0x004005d5
  400498:	004005d1 	.word	0x004005d1
  40049c:	00402415 	.word	0x00402415
  4004a0:	200008f4 	.word	0x200008f4
  4004a4:	200008b4 	.word	0x200008b4
  4004a8:	00400a55 	.word	0x00400a55
  4004ac:	00400ad5 	.word	0x00400ad5

004004b0 <twi_enable_master_mode>:
 * \param p_twi Pointer to a TWI instance.
 */
void twi_enable_master_mode(Twi *p_twi)
{
	/* Set Master Disable bit and Slave Disable bit */
	p_twi->TWI_CR = TWI_CR_MSDIS;
  4004b0:	2308      	movs	r3, #8
  4004b2:	6003      	str	r3, [r0, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  4004b4:	2320      	movs	r3, #32
  4004b6:	6003      	str	r3, [r0, #0]

	/* Set Master Enable bit */
	p_twi->TWI_CR = TWI_CR_MSEN;
  4004b8:	2304      	movs	r3, #4
  4004ba:	6003      	str	r3, [r0, #0]
  4004bc:	4770      	bx	lr
  4004be:	bf00      	nop

004004c0 <twi_set_speed>:
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  4004c0:	4b0f      	ldr	r3, [pc, #60]	; (400500 <twi_set_speed+0x40>)
  4004c2:	4299      	cmp	r1, r3
  4004c4:	d819      	bhi.n	4004fa <twi_set_speed+0x3a>
		return FAIL;
	}

	c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  4004c6:	0049      	lsls	r1, r1, #1
  4004c8:	fbb2 f2f1 	udiv	r2, r2, r1
  4004cc:	3a04      	subs	r2, #4

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  4004ce:	2aff      	cmp	r2, #255	; 0xff
  4004d0:	d907      	bls.n	4004e2 <twi_set_speed+0x22>
  4004d2:	2300      	movs	r3, #0
		/* Increase clock divider */
		ckdiv++;
  4004d4:	3301      	adds	r3, #1
		/* Divide cldiv value */
		c_lh_div /= TWI_CLK_DIVIDER;
  4004d6:	0852      	lsrs	r2, r2, #1
	}

	c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  4004d8:	2aff      	cmp	r2, #255	; 0xff
  4004da:	d903      	bls.n	4004e4 <twi_set_speed+0x24>
  4004dc:	2b07      	cmp	r3, #7
  4004de:	d1f9      	bne.n	4004d4 <twi_set_speed+0x14>
  4004e0:	e000      	b.n	4004e4 <twi_set_speed+0x24>
 * \retval PASS New speed setting is accepted.
 * \retval FAIL New speed setting is rejected.
 */
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
	uint32_t ckdiv = 0;
  4004e2:	2300      	movs	r3, #0
		c_lh_div /= TWI_CLK_DIVIDER;
	}

	/* set clock waveform generator register */
	p_twi->TWI_CWGR =
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  4004e4:	0211      	lsls	r1, r2, #8
  4004e6:	b289      	uxth	r1, r1
			TWI_CWGR_CKDIV(ckdiv);
  4004e8:	041b      	lsls	r3, r3, #16
  4004ea:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
  4004ee:	430b      	orrs	r3, r1
		c_lh_div /= TWI_CLK_DIVIDER;
	}

	/* set clock waveform generator register */
	p_twi->TWI_CWGR =
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  4004f0:	b2d2      	uxtb	r2, r2
  4004f2:	431a      	orrs	r2, r3
		/* Divide cldiv value */
		c_lh_div /= TWI_CLK_DIVIDER;
	}

	/* set clock waveform generator register */
	p_twi->TWI_CWGR =
  4004f4:	6102      	str	r2, [r0, #16]
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
			TWI_CWGR_CKDIV(ckdiv);

	return PASS;
  4004f6:	2000      	movs	r0, #0
  4004f8:	4770      	bx	lr
{
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
		return FAIL;
  4004fa:	2001      	movs	r0, #1
	p_twi->TWI_CWGR =
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
			TWI_CWGR_CKDIV(ckdiv);

	return PASS;
}
  4004fc:	4770      	bx	lr
  4004fe:	bf00      	nop
  400500:	00061a80 	.word	0x00061a80

00400504 <twi_master_write>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  400504:	4603      	mov	r3, r0
	uint32_t status;
	uint32_t cnt = p_packet->length;
  400506:	68ca      	ldr	r2, [r1, #12]
	uint8_t *buffer = p_packet->buffer;
  400508:	6888      	ldr	r0, [r1, #8]

	/* Check argument */
	if (cnt == 0) {
  40050a:	2a00      	cmp	r2, #0
  40050c:	d040      	beq.n	400590 <twi_master_write+0x8c>
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  40050e:	b470      	push	{r4, r5, r6}
	if (cnt == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  400510:	2600      	movs	r6, #0
  400512:	605e      	str	r6, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  400514:	7c0c      	ldrb	r4, [r1, #16]
  400516:	0424      	lsls	r4, r4, #16
  400518:	f404 05fe 	and.w	r5, r4, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  40051c:	684c      	ldr	r4, [r1, #4]
  40051e:	0224      	lsls	r4, r4, #8
  400520:	f404 7440 	and.w	r4, r4, #768	; 0x300
		return TWI_INVALID_ARGUMENT;
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  400524:	432c      	orrs	r4, r5
  400526:	605c      	str	r4, [r3, #4]
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  400528:	60de      	str	r6, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  40052a:	684d      	ldr	r5, [r1, #4]
 */
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
	uint32_t val;

	if (len == 0)
  40052c:	b15d      	cbz	r5, 400546 <twi_master_write+0x42>
		return 0;

	val = addr[0];
  40052e:	780c      	ldrb	r4, [r1, #0]
	if (len > 1) {
  400530:	2d01      	cmp	r5, #1
		val <<= 8;
		val |= addr[1];
  400532:	bfc4      	itt	gt
  400534:	784e      	ldrbgt	r6, [r1, #1]
  400536:	ea46 2404 	orrgt.w	r4, r6, r4, lsl #8
	}
	if (len > 2) {
  40053a:	2d02      	cmp	r5, #2
  40053c:	dd04      	ble.n	400548 <twi_master_write+0x44>
		val <<= 8;
		val |= addr[2];
  40053e:	7889      	ldrb	r1, [r1, #2]
  400540:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
  400544:	e000      	b.n	400548 <twi_master_write+0x44>
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
	uint32_t val;

	if (len == 0)
		return 0;
  400546:	2400      	movs	r4, #0
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  400548:	60dc      	str	r4, [r3, #12]
  40054a:	e00b      	b.n	400564 <twi_master_write+0x60>

	/* Send all bytes */
	while (cnt > 0) {
		status = p_twi->TWI_SR;
  40054c:	6a19      	ldr	r1, [r3, #32]
		if (status & TWI_SR_NACK) {
  40054e:	f411 7f80 	tst.w	r1, #256	; 0x100
  400552:	d11f      	bne.n	400594 <twi_master_write+0x90>
			return TWI_RECEIVE_NACK;
		}

		if (!(status & TWI_SR_TXRDY)) {
  400554:	f011 0f04 	tst.w	r1, #4
  400558:	d0f8      	beq.n	40054c <twi_master_write+0x48>
			continue;
		}
		p_twi->TWI_THR = *buffer++;
  40055a:	f810 1b01 	ldrb.w	r1, [r0], #1
  40055e:	6359      	str	r1, [r3, #52]	; 0x34
	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);

	/* Send all bytes */
	while (cnt > 0) {
  400560:	3a01      	subs	r2, #1
  400562:	d007      	beq.n	400574 <twi_master_write+0x70>
		status = p_twi->TWI_SR;
  400564:	6a19      	ldr	r1, [r3, #32]
		if (status & TWI_SR_NACK) {
  400566:	f411 7f80 	tst.w	r1, #256	; 0x100
  40056a:	d115      	bne.n	400598 <twi_master_write+0x94>
			return TWI_RECEIVE_NACK;
		}

		if (!(status & TWI_SR_TXRDY)) {
  40056c:	f011 0f04 	tst.w	r1, #4
  400570:	d0ec      	beq.n	40054c <twi_master_write+0x48>
  400572:	e7f2      	b.n	40055a <twi_master_write+0x56>

		cnt--;
	}

	while (1) {
		status = p_twi->TWI_SR;
  400574:	6a1a      	ldr	r2, [r3, #32]
		if (status & TWI_SR_NACK) {
  400576:	f412 7080 	ands.w	r0, r2, #256	; 0x100
  40057a:	d10f      	bne.n	40059c <twi_master_write+0x98>
			return TWI_RECEIVE_NACK;
		}

		if (status & TWI_SR_TXRDY) {
  40057c:	f012 0f04 	tst.w	r2, #4
  400580:	d0f8      	beq.n	400574 <twi_master_write+0x70>
			break;
		}
	}

	p_twi->TWI_CR = TWI_CR_STOP;
  400582:	2202      	movs	r2, #2
  400584:	601a      	str	r2, [r3, #0]

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  400586:	6a1a      	ldr	r2, [r3, #32]
  400588:	f012 0f01 	tst.w	r2, #1
  40058c:	d0fb      	beq.n	400586 <twi_master_write+0x82>
  40058e:	e006      	b.n	40059e <twi_master_write+0x9a>
	uint32_t cnt = p_packet->length;
	uint8_t *buffer = p_packet->buffer;

	/* Check argument */
	if (cnt == 0) {
		return TWI_INVALID_ARGUMENT;
  400590:	2001      	movs	r0, #1

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
	}

	return TWI_SUCCESS;
}
  400592:	4770      	bx	lr

	/* Send all bytes */
	while (cnt > 0) {
		status = p_twi->TWI_SR;
		if (status & TWI_SR_NACK) {
			return TWI_RECEIVE_NACK;
  400594:	2005      	movs	r0, #5
  400596:	e002      	b.n	40059e <twi_master_write+0x9a>
  400598:	2005      	movs	r0, #5
  40059a:	e000      	b.n	40059e <twi_master_write+0x9a>
	}

	while (1) {
		status = p_twi->TWI_SR;
		if (status & TWI_SR_NACK) {
			return TWI_RECEIVE_NACK;
  40059c:	2005      	movs	r0, #5

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
	}

	return TWI_SUCCESS;
}
  40059e:	bc70      	pop	{r4, r5, r6}
  4005a0:	4770      	bx	lr
  4005a2:	bf00      	nop

004005a4 <twi_probe>:
 * \param uc_slave_addr Address of the remote chip to search for.
 *
 * \return TWI_SUCCESS if a chip was found, error code otherwise.
 */
uint32_t twi_probe(Twi *p_twi, uint8_t uc_slave_addr)
{
  4005a4:	b500      	push	{lr}
  4005a6:	b087      	sub	sp, #28
	twi_packet_t packet;
	uint8_t data = 0;
  4005a8:	2300      	movs	r3, #0
  4005aa:	aa06      	add	r2, sp, #24
  4005ac:	f802 3d15 	strb.w	r3, [r2, #-21]!

	/* Data to send */
	packet.buffer = &data;
  4005b0:	9203      	str	r2, [sp, #12]
	/* Data length */
	packet.length = 1;
  4005b2:	2201      	movs	r2, #1
  4005b4:	9204      	str	r2, [sp, #16]
	/* Slave chip address */
	packet.chip = (uint32_t) uc_slave_addr;
  4005b6:	f88d 1014 	strb.w	r1, [sp, #20]
	/* Internal chip address */
	packet.addr[0] = 0;
  4005ba:	f88d 3004 	strb.w	r3, [sp, #4]
	/* Address length */
	packet.addr_length = 0;
  4005be:	9302      	str	r3, [sp, #8]

	/* Perform a master write access */
	return (twi_master_write(p_twi, &packet));
  4005c0:	a901      	add	r1, sp, #4
  4005c2:	4b02      	ldr	r3, [pc, #8]	; (4005cc <twi_probe+0x28>)
  4005c4:	4798      	blx	r3
}
  4005c6:	b007      	add	sp, #28
  4005c8:	f85d fb04 	ldr.w	pc, [sp], #4
  4005cc:	00400505 	.word	0x00400505

004005d0 <twi_enable_interrupt>:
 * \param ul_sources Interrupts to be enabled.
 */
void twi_enable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Enable the specified interrupts */
	p_twi->TWI_IER = ul_sources;
  4005d0:	6241      	str	r1, [r0, #36]	; 0x24
  4005d2:	4770      	bx	lr

004005d4 <twi_disable_interrupt>:
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
  4005d4:	6281      	str	r1, [r0, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
  4005d6:	6a03      	ldr	r3, [r0, #32]
  4005d8:	4770      	bx	lr
  4005da:	bf00      	nop

004005dc <twi_read_byte>:
 *
 * \return The byte read.
 */
uint8_t twi_read_byte(Twi *p_twi)
{
	return p_twi->TWI_RHR;
  4005dc:	6b00      	ldr	r0, [r0, #48]	; 0x30
}
  4005de:	b2c0      	uxtb	r0, r0
  4005e0:	4770      	bx	lr
  4005e2:	bf00      	nop

004005e4 <twi_reset>:
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  4005e4:	2380      	movs	r3, #128	; 0x80
  4005e6:	6003      	str	r3, [r0, #0]
	p_twi->TWI_RHR;
  4005e8:	6b03      	ldr	r3, [r0, #48]	; 0x30
  4005ea:	4770      	bx	lr

004005ec <twi_mgc_task>:
			stack_depth_words, (void *) freertos_twi, task_priority,
			NULL);
}

static void twi_mgc_task(void *pvParameters)
{
  4005ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4005f0:	b092      	sub	sp, #72	; 0x48
  4005f2:	4680      	mov	r8, r0
	vTaskDelay(100);
	ioport_set_pin_level(EXT1_PIN_6, IOPORT_PIN_LEVEL_HIGH);
	vTaskDelay(50);
	*/
	
	if (twi_probe(TWI4, 0x4F) == TWI_SUCCESS) {
  4005f4:	4820      	ldr	r0, [pc, #128]	; (400678 <twi_mgc_task+0x8c>)
  4005f6:	214f      	movs	r1, #79	; 0x4f
  4005f8:	4b20      	ldr	r3, [pc, #128]	; (40067c <twi_mgc_task+0x90>)
  4005fa:	4798      	blx	r3
  4005fc:	b930      	cbnz	r0, 40060c <twi_mgc_task+0x20>
		usart_cli_output("chipfound\r\n");
  4005fe:	4820      	ldr	r0, [pc, #128]	; (400680 <twi_mgc_task+0x94>)
  400600:	4b20      	ldr	r3, [pc, #128]	; (400684 <twi_mgc_task+0x98>)
  400602:	4798      	blx	r3
		
		twi_packet_t read_parameters;
		const portTickType max_block_time_ticks = 100 / portTICK_RATE_MS;

		read_parameters.chip = 0x4F;//BOARD_MGC_ADDRESS;
		read_parameters.buffer = temp_data_buffer;//mgc_data_buffer;
  400604:	4c20      	ldr	r4, [pc, #128]	; (400688 <twi_mgc_task+0x9c>)
			}
			usart_cli_output("\r\n");
		}*/

				
		if (freertos_twi_read_packet(freertos_twi, &read_parameters, max_block_time_ticks) != STATUS_OK) {
  400606:	4e21      	ldr	r6, [pc, #132]	; (40068c <twi_mgc_task+0xa0>)
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  400608:	4f21      	ldr	r7, [pc, #132]	; (400690 <twi_mgc_task+0xa4>)
  40060a:	e003      	b.n	400614 <twi_mgc_task+0x28>
	*/
	
	if (twi_probe(TWI4, 0x4F) == TWI_SUCCESS) {
		usart_cli_output("chipfound\r\n");
	} else {
		usart_cli_output("not found\r\n");
  40060c:	4821      	ldr	r0, [pc, #132]	; (400694 <twi_mgc_task+0xa8>)
  40060e:	4b1d      	ldr	r3, [pc, #116]	; (400684 <twi_mgc_task+0x98>)
  400610:	4798      	blx	r3
  400612:	e7f7      	b.n	400604 <twi_mgc_task+0x18>
	{
		
		twi_packet_t read_parameters;
		const portTickType max_block_time_ticks = 100 / portTICK_RATE_MS;

		read_parameters.chip = 0x4F;//BOARD_MGC_ADDRESS;
  400614:	234f      	movs	r3, #79	; 0x4f
  400616:	f88d 3010 	strb.w	r3, [sp, #16]
		read_parameters.buffer = temp_data_buffer;//mgc_data_buffer;
  40061a:	9402      	str	r4, [sp, #8]
		read_parameters.length = 3;//PAGE_SIZE;
  40061c:	2303      	movs	r3, #3
  40061e:	9303      	str	r3, [sp, #12]
		read_parameters.addr[0] = 0;
  400620:	2300      	movs	r3, #0
  400622:	f88d 3000 	strb.w	r3, [sp]
		read_parameters.addr_length = 1;
  400626:	2201      	movs	r2, #1
  400628:	9201      	str	r2, [sp, #4]
			}
			usart_cli_output("\r\n");
		}*/

				
		if (freertos_twi_read_packet(freertos_twi, &read_parameters, max_block_time_ticks) != STATUS_OK) {
  40062a:	4640      	mov	r0, r8
  40062c:	4669      	mov	r1, sp
  40062e:	2264      	movs	r2, #100	; 0x64
  400630:	47b0      	blx	r6
  400632:	b128      	cbz	r0, 400640 <twi_mgc_task+0x54>
			error_detected = pdTRUE;
  400634:	2201      	movs	r2, #1
  400636:	4b18      	ldr	r3, [pc, #96]	; (400698 <twi_mgc_task+0xac>)
  400638:	601a      	str	r2, [r3, #0]
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40063a:	2340      	movs	r3, #64	; 0x40
  40063c:	637b      	str	r3, [r7, #52]	; 0x34
  40063e:	e016      	b.n	40066e <twi_mgc_task+0x82>
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  400640:	2340      	movs	r3, #64	; 0x40
  400642:	633b      	str	r3, [r7, #48]	; 0x30
			LED_Off(LED0);
			int i = 0;
			int n = 0;
			char buffer [50];
			for(i=0; i<=1; i++){
				n = sprintf(buffer,"byte [%d]: %X\t",i,temp_data_buffer[i]);
  400644:	f8df a05c 	ldr.w	sl, [pc, #92]	; 4006a4 <twi_mgc_task+0xb8>
  400648:	a805      	add	r0, sp, #20
  40064a:	4651      	mov	r1, sl
  40064c:	2200      	movs	r2, #0
  40064e:	7823      	ldrb	r3, [r4, #0]
  400650:	f8df 9054 	ldr.w	r9, [pc, #84]	; 4006a8 <twi_mgc_task+0xbc>
  400654:	47c8      	blx	r9
				usart_cli_output(buffer);
  400656:	a805      	add	r0, sp, #20
  400658:	4d0a      	ldr	r5, [pc, #40]	; (400684 <twi_mgc_task+0x98>)
  40065a:	47a8      	blx	r5
			LED_Off(LED0);
			int i = 0;
			int n = 0;
			char buffer [50];
			for(i=0; i<=1; i++){
				n = sprintf(buffer,"byte [%d]: %X\t",i,temp_data_buffer[i]);
  40065c:	a805      	add	r0, sp, #20
  40065e:	4651      	mov	r1, sl
  400660:	2201      	movs	r2, #1
  400662:	7863      	ldrb	r3, [r4, #1]
  400664:	47c8      	blx	r9
				usart_cli_output(buffer);
  400666:	a805      	add	r0, sp, #20
  400668:	47a8      	blx	r5
		}
		
		usart_cli_output("\r\n");
  40066a:	480c      	ldr	r0, [pc, #48]	; (40069c <twi_mgc_task+0xb0>)
  40066c:	47a8      	blx	r5
		}
		
		vTaskDelay(500);
  40066e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  400672:	4b0b      	ldr	r3, [pc, #44]	; (4006a0 <twi_mgc_task+0xb4>)
  400674:	4798      	blx	r3

	}
  400676:	e7cd      	b.n	400614 <twi_mgc_task+0x28>
  400678:	4001c600 	.word	0x4001c600
  40067c:	004005a5 	.word	0x004005a5
  400680:	004095a4 	.word	0x004095a4
  400684:	00401c11 	.word	0x00401c11
  400688:	2000097c 	.word	0x2000097c
  40068c:	004002d1 	.word	0x004002d1
  400690:	400e0e00 	.word	0x400e0e00
  400694:	004095b0 	.word	0x004095b0
  400698:	20000974 	.word	0x20000974
  40069c:	00409d34 	.word	0x00409d34
  4006a0:	00402f3d 	.word	0x00402f3d
  4006a4:	004095bc 	.word	0x004095bc
  4006a8:	00404379 	.word	0x00404379

004006ac <prepare_twi_task>:

/*-----------------------------------------------------------*/
void prepare_twi_task(Twi *twi_base, uint16_t stack_depth_words,
		unsigned portBASE_TYPE task_priority,
		portBASE_TYPE set_asynchronous_api)
{
  4006ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4006b0:	b08d      	sub	sp, #52	; 0x34
  4006b2:	4606      	mov	r6, r0
  4006b4:	4688      	mov	r8, r1
  4006b6:	4691      	mov	r9, r2
  4006b8:	461f      	mov	r7, r3
	freertos_twi_if freertos_twi;

	/* blocking_driver_options is used if set_asynchronous_api is passed in
	as 0. */
	const freertos_peripheral_options_t blocking_driver_options = {
  4006ba:	4c27      	ldr	r4, [pc, #156]	; (400758 <prepare_twi_task+0xac>)
  4006bc:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  4006c0:	ad0c      	add	r5, sp, #48	; 0x30
  4006c2:	e905 000f 	stmdb	r5, {r0, r1, r2, r3}
		(USE_TX_ACCESS_MUTEX | USE_RX_ACCESS_MUTEX | WAIT_TX_COMPLETE | WAIT_RX_COMPLETE)	/* The blocking driver is to be used, so WAIT_TX_COMPLETE and WAIT_RX_COMPLETE are set. */
	};

	/* asynchronous_driver_options is used if set_asynchronous_api is passed
	in as 1. */
	const freertos_peripheral_options_t asynchronous_driver_options = {
  4006c6:	ad04      	add	r5, sp, #16
  4006c8:	3410      	adds	r4, #16
  4006ca:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  4006ce:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
		TWI_I2C_MASTER,									/* Communicating with the EEPROM requires the TWI to be configured as an I2C master. */
		(USE_TX_ACCESS_MUTEX | USE_RX_ACCESS_MUTEX)	/* The asynchronous driver is to be used, so WAIT_TX_COMPLETE and WAIT_RX_COMPLETE are not set. */
	};

	/* Remember if the asynchronous or blocking API is being used. */
	twi_use_asynchronous_api = set_asynchronous_api;
  4006d2:	4b22      	ldr	r3, [pc, #136]	; (40075c <prepare_twi_task+0xb0>)
  4006d4:	601f      	str	r7, [r3, #0]

	/* The freertos_peripheral_options_t structure used to initialize the
	FreeRTOS driver differs depending on the twi_use_asynchronous_api setting. */
	if (twi_use_asynchronous_api == pdFALSE) {
  4006d6:	b92f      	cbnz	r7, 4006e4 <prepare_twi_task+0x38>
				
		/* Initialize the FreeRTOS driver for blocking operation.  The
		peripheral clock is configured in this function call. */
		freertos_twi = freertos_twi_master_init(twi_base,
  4006d8:	4630      	mov	r0, r6
  4006da:	a908      	add	r1, sp, #32
  4006dc:	4b20      	ldr	r3, [pc, #128]	; (400760 <prepare_twi_task+0xb4>)
  4006de:	4798      	blx	r3
  4006e0:	4604      	mov	r4, r0
  4006e2:	e01f      	b.n	400724 <prepare_twi_task+0x78>
				&blocking_driver_options);
				
	} else {
		/* Initialize the FreeRTOS driver for asynchronous operation.  The
		peripheral clock is configured in this function call. */
		freertos_twi = freertos_twi_master_init(twi_base,
  4006e4:	4630      	mov	r0, r6
  4006e6:	a904      	add	r1, sp, #16
  4006e8:	4b1d      	ldr	r3, [pc, #116]	; (400760 <prepare_twi_task+0xb4>)
  4006ea:	4798      	blx	r3
  4006ec:	4604      	mov	r4, r0
				&asynchronous_driver_options);

		/* Asynchronous operation requires a notification semaphore.  First,
		create the semaphore. */
		vSemaphoreCreateBinary(twi_notification_semaphore);
  4006ee:	2001      	movs	r0, #1
  4006f0:	2100      	movs	r1, #0
  4006f2:	2203      	movs	r2, #3
  4006f4:	4b1b      	ldr	r3, [pc, #108]	; (400764 <prepare_twi_task+0xb8>)
  4006f6:	4798      	blx	r3
  4006f8:	4b1b      	ldr	r3, [pc, #108]	; (400768 <prepare_twi_task+0xbc>)
  4006fa:	6018      	str	r0, [r3, #0]
  4006fc:	b138      	cbz	r0, 40070e <prepare_twi_task+0x62>
  4006fe:	2100      	movs	r1, #0
  400700:	460a      	mov	r2, r1
  400702:	460b      	mov	r3, r1
  400704:	4d19      	ldr	r5, [pc, #100]	; (40076c <prepare_twi_task+0xc0>)
  400706:	47a8      	blx	r5

		/* Check the semaphore was created. */
		configASSERT(twi_notification_semaphore);
  400708:	4b17      	ldr	r3, [pc, #92]	; (400768 <prepare_twi_task+0xbc>)
  40070a:	681b      	ldr	r3, [r3, #0]
  40070c:	b91b      	cbnz	r3, 400716 <prepare_twi_task+0x6a>
  40070e:	4818      	ldr	r0, [pc, #96]	; (400770 <prepare_twi_task+0xc4>)
  400710:	21ab      	movs	r1, #171	; 0xab
  400712:	4b18      	ldr	r3, [pc, #96]	; (400774 <prepare_twi_task+0xc8>)
  400714:	4798      	blx	r3

		/* Then set the semaphore into the correct initial state. */
		xSemaphoreTake(twi_notification_semaphore, 0);
  400716:	4b14      	ldr	r3, [pc, #80]	; (400768 <prepare_twi_task+0xbc>)
  400718:	6818      	ldr	r0, [r3, #0]
  40071a:	2100      	movs	r1, #0
  40071c:	460a      	mov	r2, r1
  40071e:	460b      	mov	r3, r1
  400720:	4d15      	ldr	r5, [pc, #84]	; (400778 <prepare_twi_task+0xcc>)
  400722:	47a8      	blx	r5
	}

	/* Check the port was initialized successfully. */
	configASSERT(freertos_twi);
  400724:	b91c      	cbnz	r4, 40072e <prepare_twi_task+0x82>
  400726:	4812      	ldr	r0, [pc, #72]	; (400770 <prepare_twi_task+0xc4>)
  400728:	21b2      	movs	r1, #178	; 0xb2
  40072a:	4b12      	ldr	r3, [pc, #72]	; (400774 <prepare_twi_task+0xc8>)
  40072c:	4798      	blx	r3

	/* Configure the TWI bus parameters.  Do this after calling
	freertos_twi_master_init(). */
	twi_set_speed(twi_base, TWI_CLOCK_HZ, sysclk_get_cpu_hz());
  40072e:	4630      	mov	r0, r6
  400730:	4912      	ldr	r1, [pc, #72]	; (40077c <prepare_twi_task+0xd0>)
  400732:	4a13      	ldr	r2, [pc, #76]	; (400780 <prepare_twi_task+0xd4>)
  400734:	4b13      	ldr	r3, [pc, #76]	; (400784 <prepare_twi_task+0xd8>)
  400736:	4798      	blx	r3

	/* Create the task as described above. */
	xTaskCreate(twi_mgc_task, (const signed char *const) "MGCTask",
  400738:	f8cd 9000 	str.w	r9, [sp]
  40073c:	2300      	movs	r3, #0
  40073e:	9301      	str	r3, [sp, #4]
  400740:	9302      	str	r3, [sp, #8]
  400742:	9303      	str	r3, [sp, #12]
  400744:	4810      	ldr	r0, [pc, #64]	; (400788 <prepare_twi_task+0xdc>)
  400746:	4911      	ldr	r1, [pc, #68]	; (40078c <prepare_twi_task+0xe0>)
  400748:	4642      	mov	r2, r8
  40074a:	4623      	mov	r3, r4
  40074c:	4c10      	ldr	r4, [pc, #64]	; (400790 <prepare_twi_task+0xe4>)
  40074e:	47a0      	blx	r4
			stack_depth_words, (void *) freertos_twi, task_priority,
			NULL);
}
  400750:	b00d      	add	sp, #52	; 0x34
  400752:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  400756:	bf00      	nop
  400758:	00409574 	.word	0x00409574
  40075c:	20004f04 	.word	0x20004f04
  400760:	004001a5 	.word	0x004001a5
  400764:	00402385 	.word	0x00402385
  400768:	20000978 	.word	0x20000978
  40076c:	00402415 	.word	0x00402415
  400770:	004095cc 	.word	0x004095cc
  400774:	00403de1 	.word	0x00403de1
  400778:	00402649 	.word	0x00402649
  40077c:	00061a80 	.word	0x00061a80
  400780:	07270000 	.word	0x07270000
  400784:	004004c1 	.word	0x004004c1
  400788:	004005ed 	.word	0x004005ed
  40078c:	00409620 	.word	0x00409620
  400790:	0040298d 	.word	0x0040298d

00400794 <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE
#endif

void sysclk_init(void)
{
  400794:	b510      	push	{r4, lr}
	uint32_t unique_id[32];
	uint32_t trim_value;
#endif

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  400796:	480e      	ldr	r0, [pc, #56]	; (4007d0 <sysclk_init+0x3c>)
  400798:	4b0e      	ldr	r3, [pc, #56]	; (4007d4 <sysclk_init+0x40>)
  40079a:	4798      	blx	r3
	switch (ul_id) {
	case OSC_SLCK_32K_RC:
		break;

	case OSC_SLCK_32K_XTAL:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  40079c:	2000      	movs	r0, #0
  40079e:	4b0e      	ldr	r3, [pc, #56]	; (4007d8 <sysclk_init+0x44>)
  4007a0:	4798      	blx	r3
	case OSC_SLCK_32K_RC:
		return 1;

	case OSC_SLCK_32K_XTAL:
	case OSC_SLCK_32K_BYPASS:
		return pmc_osc_is_ready_32kxtal();
  4007a2:	4c0e      	ldr	r4, [pc, #56]	; (4007dc <sysclk_init+0x48>)
  4007a4:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  4007a6:	2800      	cmp	r0, #0
  4007a8:	d0fc      	beq.n	4007a4 <sysclk_init+0x10>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  4007aa:	4b0d      	ldr	r3, [pc, #52]	; (4007e0 <sysclk_init+0x4c>)
  4007ac:	4798      	blx	r3
		PMC->CKGR_PLLAR = p_cfg->ctrl;
  4007ae:	4a0d      	ldr	r2, [pc, #52]	; (4007e4 <sysclk_init+0x50>)
  4007b0:	4b0d      	ldr	r3, [pc, #52]	; (4007e8 <sysclk_init+0x54>)
  4007b2:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  4007b4:	4c0d      	ldr	r4, [pc, #52]	; (4007ec <sysclk_init+0x58>)
  4007b6:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  4007b8:	2800      	cmp	r0, #0
  4007ba:	d0fc      	beq.n	4007b6 <sysclk_init+0x22>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  4007bc:	2000      	movs	r0, #0
  4007be:	4b0c      	ldr	r3, [pc, #48]	; (4007f0 <sysclk_init+0x5c>)
  4007c0:	4798      	blx	r3
	}
#endif
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  4007c2:	4b0c      	ldr	r3, [pc, #48]	; (4007f4 <sysclk_init+0x60>)
  4007c4:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  4007c6:	480c      	ldr	r0, [pc, #48]	; (4007f8 <sysclk_init+0x64>)
  4007c8:	4b02      	ldr	r3, [pc, #8]	; (4007d4 <sysclk_init+0x40>)
  4007ca:	4798      	blx	r3
  4007cc:	bd10      	pop	{r4, pc}
  4007ce:	bf00      	nop
  4007d0:	07270e00 	.word	0x07270e00
  4007d4:	0040191d 	.word	0x0040191d
  4007d8:	00401511 	.word	0x00401511
  4007dc:	00401535 	.word	0x00401535
  4007e0:	00401555 	.word	0x00401555
  4007e4:	0e4d3f01 	.word	0x0e4d3f01
  4007e8:	400e0400 	.word	0x400e0400
  4007ec:	00401561 	.word	0x00401561
  4007f0:	004014a9 	.word	0x004014a9
  4007f4:	00401835 	.word	0x00401835
  4007f8:	07270000 	.word	0x07270000

004007fc <get_pdc_peripheral_details>:
 * peripheral that has the start address specified by peripheral_to_find.
 */
portBASE_TYPE get_pdc_peripheral_details(
		const freertos_pdc_peripheral_parameters_t peripheral_array[],
		size_t array_size, void *peripheral_to_find)
{
  4007fc:	b430      	push	{r4, r5}
	size_t x;

	for (x = 0; x < array_size; x++) {
  4007fe:	460d      	mov	r5, r1
  400800:	b181      	cbz	r1, 400824 <get_pdc_peripheral_details+0x28>
		if (peripheral_array[x].peripheral_base_address ==
  400802:	6803      	ldr	r3, [r0, #0]
  400804:	4293      	cmp	r3, r2
  400806:	d00a      	beq.n	40081e <get_pdc_peripheral_details+0x22>
  400808:	4601      	mov	r1, r0
  40080a:	2300      	movs	r3, #0
  40080c:	e003      	b.n	400816 <get_pdc_peripheral_details+0x1a>
  40080e:	f851 4f10 	ldr.w	r4, [r1, #16]!
  400812:	4294      	cmp	r4, r2
  400814:	d005      	beq.n	400822 <get_pdc_peripheral_details+0x26>
		const freertos_pdc_peripheral_parameters_t peripheral_array[],
		size_t array_size, void *peripheral_to_find)
{
	size_t x;

	for (x = 0; x < array_size; x++) {
  400816:	3301      	adds	r3, #1
  400818:	42ab      	cmp	r3, r5
  40081a:	d1f8      	bne.n	40080e <get_pdc_peripheral_details+0x12>
  40081c:	e002      	b.n	400824 <get_pdc_peripheral_details+0x28>
  40081e:	2500      	movs	r5, #0
  400820:	e000      	b.n	400824 <get_pdc_peripheral_details+0x28>
  400822:	461d      	mov	r5, r3
			break;
		}
	}

	return x;
}
  400824:	4628      	mov	r0, r5
  400826:	bc30      	pop	{r4, r5}
  400828:	4770      	bx	lr
  40082a:	bf00      	nop

0040082c <check_requested_operating_mode>:
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
  40082c:	2a00      	cmp	r2, #0
  40082e:	dd0e      	ble.n	40084e <check_requested_operating_mode+0x22>
			index_position++) {
		if (requested_operation_mode ==
  400830:	780b      	ldrb	r3, [r1, #0]
  400832:	4283      	cmp	r3, r0
  400834:	d00d      	beq.n	400852 <check_requested_operating_mode+0x26>
 */
bool check_requested_operating_mode(
		const enum peripheral_operation_mode requested_operation_mode,
		const enum peripheral_operation_mode valid_operating_modes[],
		portBASE_TYPE num_valid_operating_modes)
{
  400836:	b410      	push	{r4}
  400838:	1c4b      	adds	r3, r1, #1
  40083a:	4411      	add	r1, r2
  40083c:	e003      	b.n	400846 <check_requested_operating_mode+0x1a>
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
			index_position++) {
		if (requested_operation_mode ==
  40083e:	f813 4b01 	ldrb.w	r4, [r3], #1
  400842:	4284      	cmp	r4, r0
  400844:	d007      	beq.n	400856 <check_requested_operating_mode+0x2a>
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
  400846:	428b      	cmp	r3, r1
  400848:	d1f9      	bne.n	40083e <check_requested_operating_mode+0x12>
bool check_requested_operating_mode(
		const enum peripheral_operation_mode requested_operation_mode,
		const enum peripheral_operation_mode valid_operating_modes[],
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
  40084a:	2000      	movs	r0, #0
  40084c:	e004      	b.n	400858 <check_requested_operating_mode+0x2c>
  40084e:	2000      	movs	r0, #0
			break;
		}
	}

	return return_value;
}
  400850:	4770      	bx	lr

	for (index_position = 0; index_position < num_valid_operating_modes;
			index_position++) {
		if (requested_operation_mode ==
				valid_operating_modes[index_position]) {
			return_value = true;
  400852:	2001      	movs	r0, #1
  400854:	4770      	bx	lr
  400856:	2001      	movs	r0, #1
			break;
		}
	}

	return return_value;
}
  400858:	f85d 4b04 	ldr.w	r4, [sp], #4
  40085c:	4770      	bx	lr
  40085e:	bf00      	nop

00400860 <create_peripheral_control_semaphores>:
 * with the bits set in the options_flags value.
 */
void create_peripheral_control_semaphores(const uint8_t options_flags,
		freertos_dma_event_control_t *tx_dma_control,
		freertos_dma_event_control_t *rx_dma_control)
{
  400860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400862:	4604      	mov	r4, r0
  400864:	460e      	mov	r6, r1
  400866:	4615      	mov	r5, r2
	/* If the tx driver is to be thread aware then create an access control
	mutex.  An Rx access mutex is not created in this function as half duplex
	peripherals need only use a single access mutex, and the Tx mutex is used
	for the purpose.  Full duplex peripherals have extra configuration steps
	that are performed separately. */
	if ((options_flags & USE_TX_ACCESS_MUTEX) != 0) {
  400868:	f010 0f01 	tst.w	r0, #1
  40086c:	d008      	beq.n	400880 <create_peripheral_control_semaphores+0x20>
		tx_dma_control->peripheral_access_mutex = xSemaphoreCreateMutex();
  40086e:	2001      	movs	r0, #1
  400870:	4b22      	ldr	r3, [pc, #136]	; (4008fc <create_peripheral_control_semaphores+0x9c>)
  400872:	4798      	blx	r3
  400874:	6070      	str	r0, [r6, #4]
		configASSERT(tx_dma_control->peripheral_access_mutex);
  400876:	b918      	cbnz	r0, 400880 <create_peripheral_control_semaphores+0x20>
  400878:	4821      	ldr	r0, [pc, #132]	; (400900 <create_peripheral_control_semaphores+0xa0>)
  40087a:	217a      	movs	r1, #122	; 0x7a
  40087c:	4b21      	ldr	r3, [pc, #132]	; (400904 <create_peripheral_control_semaphores+0xa4>)
  40087e:	4798      	blx	r3
	}

	/* If the transmit function is only going to return once the transmit is
	complete then create an internal notification semaphore. */
	if ((options_flags & WAIT_TX_COMPLETE) != 0) {
  400880:	f014 0f04 	tst.w	r4, #4
  400884:	d018      	beq.n	4008b8 <create_peripheral_control_semaphores+0x58>
		vSemaphoreCreateBinary(
  400886:	2001      	movs	r0, #1
  400888:	2100      	movs	r1, #0
  40088a:	2203      	movs	r2, #3
  40088c:	4b1e      	ldr	r3, [pc, #120]	; (400908 <create_peripheral_control_semaphores+0xa8>)
  40088e:	4798      	blx	r3
  400890:	6030      	str	r0, [r6, #0]
  400892:	b130      	cbz	r0, 4008a2 <create_peripheral_control_semaphores+0x42>
  400894:	2100      	movs	r1, #0
  400896:	460a      	mov	r2, r1
  400898:	460b      	mov	r3, r1
  40089a:	4f1c      	ldr	r7, [pc, #112]	; (40090c <create_peripheral_control_semaphores+0xac>)
  40089c:	47b8      	blx	r7
				tx_dma_control->transaction_complete_notification_semaphore);
		configASSERT(
  40089e:	6833      	ldr	r3, [r6, #0]
  4008a0:	b91b      	cbnz	r3, 4008aa <create_peripheral_control_semaphores+0x4a>
  4008a2:	4817      	ldr	r0, [pc, #92]	; (400900 <create_peripheral_control_semaphores+0xa0>)
  4008a4:	2183      	movs	r1, #131	; 0x83
  4008a6:	4b17      	ldr	r3, [pc, #92]	; (400904 <create_peripheral_control_semaphores+0xa4>)
  4008a8:	4798      	blx	r3
				tx_dma_control->transaction_complete_notification_semaphore);

		/* Ensure the semaphore starts in the expected state.  A block time
		of zero can be used here as the semaphore is guaranteed to be
		available (it has only just been created). */
		xSemaphoreTake(
  4008aa:	6830      	ldr	r0, [r6, #0]
  4008ac:	2100      	movs	r1, #0
  4008ae:	460a      	mov	r2, r1
  4008b0:	460b      	mov	r3, r1
  4008b2:	4e17      	ldr	r6, [pc, #92]	; (400910 <create_peripheral_control_semaphores+0xb0>)
  4008b4:	47b0      	blx	r6
  4008b6:	e001      	b.n	4008bc <create_peripheral_control_semaphores+0x5c>
				tx_dma_control->transaction_complete_notification_semaphore,
				0);
	} else {
		tx_dma_control->transaction_complete_notification_semaphore = NULL;
  4008b8:	2300      	movs	r3, #0
  4008ba:	6033      	str	r3, [r6, #0]
	}

	/* If the receive function is only going to return once the receive
	is complete then create an internal notification semaphore. */
	if (((options_flags & WAIT_RX_COMPLETE) != 0) &&
  4008bc:	f014 0f08 	tst.w	r4, #8
  4008c0:	d019      	beq.n	4008f6 <create_peripheral_control_semaphores+0x96>
  4008c2:	b1c5      	cbz	r5, 4008f6 <create_peripheral_control_semaphores+0x96>
			(rx_dma_control != NULL)) {
		vSemaphoreCreateBinary(
  4008c4:	2001      	movs	r0, #1
  4008c6:	2100      	movs	r1, #0
  4008c8:	2203      	movs	r2, #3
  4008ca:	4b0f      	ldr	r3, [pc, #60]	; (400908 <create_peripheral_control_semaphores+0xa8>)
  4008cc:	4798      	blx	r3
  4008ce:	6028      	str	r0, [r5, #0]
  4008d0:	b130      	cbz	r0, 4008e0 <create_peripheral_control_semaphores+0x80>
  4008d2:	2100      	movs	r1, #0
  4008d4:	460a      	mov	r2, r1
  4008d6:	460b      	mov	r3, r1
  4008d8:	4c0c      	ldr	r4, [pc, #48]	; (40090c <create_peripheral_control_semaphores+0xac>)
  4008da:	47a0      	blx	r4
				rx_dma_control->transaction_complete_notification_semaphore);
		configASSERT(
  4008dc:	682b      	ldr	r3, [r5, #0]
  4008de:	b91b      	cbnz	r3, 4008e8 <create_peripheral_control_semaphores+0x88>
  4008e0:	4807      	ldr	r0, [pc, #28]	; (400900 <create_peripheral_control_semaphores+0xa0>)
  4008e2:	2196      	movs	r1, #150	; 0x96
  4008e4:	4b07      	ldr	r3, [pc, #28]	; (400904 <create_peripheral_control_semaphores+0xa4>)
  4008e6:	4798      	blx	r3
				rx_dma_control->transaction_complete_notification_semaphore);

		/* Ensure the semaphore starts in the expected state.  A block time
		of zero can be used here as the semaphore is guaranteed to be
		available (it has only just been created. */
		xSemaphoreTake(
  4008e8:	6828      	ldr	r0, [r5, #0]
  4008ea:	2100      	movs	r1, #0
  4008ec:	460a      	mov	r2, r1
  4008ee:	460b      	mov	r3, r1
  4008f0:	4c07      	ldr	r4, [pc, #28]	; (400910 <create_peripheral_control_semaphores+0xb0>)
  4008f2:	47a0      	blx	r4
  4008f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				rx_dma_control->transaction_complete_notification_semaphore,
				0);
	} else {
		rx_dma_control->transaction_complete_notification_semaphore = NULL;
  4008f6:	2300      	movs	r3, #0
  4008f8:	602b      	str	r3, [r5, #0]
  4008fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4008fc:	00402545 	.word	0x00402545
  400900:	0040962c 	.word	0x0040962c
  400904:	00403de1 	.word	0x00403de1
  400908:	00402385 	.word	0x00402385
  40090c:	00402415 	.word	0x00402415
  400910:	00402649 	.word	0x00402649

00400914 <configure_interrupt_controller>:
 * Configure the NVIC to enable, and set the priority of, the interrupt
 * specified by peripheral_irq.
 */
void configure_interrupt_controller(const enum IRQn peripheral_irq,
		uint32_t interrupt_priority)
{
  400914:	b538      	push	{r3, r4, r5, lr}
  400916:	4604      	mov	r4, r0
  400918:	460d      	mov	r5, r1
	configASSERT(interrupt_priority <=
  40091a:	290f      	cmp	r1, #15
  40091c:	d903      	bls.n	400926 <configure_interrupt_controller+0x12>
  40091e:	4815      	ldr	r0, [pc, #84]	; (400974 <configure_interrupt_controller+0x60>)
  400920:	21ac      	movs	r1, #172	; 0xac
  400922:	4b15      	ldr	r3, [pc, #84]	; (400978 <configure_interrupt_controller+0x64>)
  400924:	4798      	blx	r3
            configLIBRARY_LOWEST_INTERRUPT_PRIORITY);
	configASSERT(interrupt_priority >=
  400926:	2d09      	cmp	r5, #9
  400928:	d803      	bhi.n	400932 <configure_interrupt_controller+0x1e>
  40092a:	4812      	ldr	r0, [pc, #72]	; (400974 <configure_interrupt_controller+0x60>)
  40092c:	21ae      	movs	r1, #174	; 0xae
  40092e:	4b12      	ldr	r3, [pc, #72]	; (400978 <configure_interrupt_controller+0x64>)
  400930:	4798      	blx	r3

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  400932:	b2e1      	uxtb	r1, r4
  400934:	f001 031f 	and.w	r3, r1, #31
  400938:	2201      	movs	r2, #1
  40093a:	409a      	lsls	r2, r3
  40093c:	0963      	lsrs	r3, r4, #5
  40093e:	009b      	lsls	r3, r3, #2
  400940:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
  400944:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  400948:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
  40094c:	2c00      	cmp	r4, #0
  40094e:	da06      	bge.n	40095e <configure_interrupt_controller+0x4a>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  400950:	f001 010f 	and.w	r1, r1, #15
  400954:	012d      	lsls	r5, r5, #4
  400956:	b2ed      	uxtb	r5, r5
  400958:	4808      	ldr	r0, [pc, #32]	; (40097c <configure_interrupt_controller+0x68>)
  40095a:	5445      	strb	r5, [r0, r1]
  40095c:	e007      	b.n	40096e <configure_interrupt_controller+0x5a>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  40095e:	012d      	lsls	r5, r5, #4
  400960:	b2ed      	uxtb	r5, r5
  400962:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  400966:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
  40096a:	f884 5300 	strb.w	r5, [r4, #768]	; 0x300
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  40096e:	601a      	str	r2, [r3, #0]
  400970:	bd38      	pop	{r3, r4, r5, pc}
  400972:	bf00      	nop
  400974:	0040962c 	.word	0x0040962c
  400978:	00403de1 	.word	0x00403de1
  40097c:	e000ed14 	.word	0xe000ed14

00400980 <freertos_copy_bytes_from_pdc_circular_buffer>:
 */
uint32_t freertos_copy_bytes_from_pdc_circular_buffer(
		freertos_pdc_rx_control_t *p_rx_buffer_details,
		uint32_t next_byte_to_be_written, uint8_t *buf,
		uint32_t bytes_to_read)
{
  400980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400984:	4606      	mov	r6, r0
  400986:	4690      	mov	r8, r2
  400988:	461f      	mov	r7, r3
	uint32_t number_of_bytes_available, next_byte_to_read;

	/* Locate the position that data will be read from next. */
	next_byte_to_read = (uint32_t) p_rx_buffer_details->next_byte_to_read;
  40098a:	6985      	ldr	r5, [r0, #24]

	if (next_byte_to_be_written == next_byte_to_read) {
  40098c:	42a9      	cmp	r1, r5
  40098e:	d104      	bne.n	40099a <freertos_copy_bytes_from_pdc_circular_buffer+0x1a>
		if (p_rx_buffer_details->rx_pdc_parameters.ul_size == 0) {
  400990:	68c3      	ldr	r3, [r0, #12]
  400992:	b943      	cbnz	r3, 4009a6 <freertos_copy_bytes_from_pdc_circular_buffer+0x26>
			/* The read and write pointers are equal, but as the Rx DMA has been
			stopped, the buffer must be full, not empty.  Data from the read
			pointer up to the end of the buffer is available. */
			number_of_bytes_available =
  400994:	6844      	ldr	r4, [r0, #4]
  400996:	1a64      	subs	r4, r4, r1
  400998:	e006      	b.n	4009a8 <freertos_copy_bytes_from_pdc_circular_buffer+0x28>
		} else {
			/* The read and write pointers are equal, but the Rx DMA is still
			in operation, so the buffer must be empty. */
			number_of_bytes_available = 0;
		}
	} else if (next_byte_to_be_written > next_byte_to_read) {
  40099a:	428d      	cmp	r5, r1
		/* The write pointer has not wrapped around from the read pointer, or
		the write and read pointer are the same indicating a buffer overflow.
		Calculate the bytes available between the write and read pointers. */
		number_of_bytes_available = next_byte_to_be_written -
  40099c:	bf32      	itee	cc
  40099e:	1b4c      	subcc	r4, r1, r5
				next_byte_to_read;
	} else {
		/* The write pointer has wrapped around from the read pointer.
		Calculate the bytes available between the end of the buffer and the
		read pointer. */
		number_of_bytes_available =
  4009a0:	6844      	ldrcs	r4, [r0, #4]
  4009a2:	1b64      	subcs	r4, r4, r5
  4009a4:	e000      	b.n	4009a8 <freertos_copy_bytes_from_pdc_circular_buffer+0x28>
					p_rx_buffer_details->past_rx_buffer_end_address
					- next_byte_to_read;
		} else {
			/* The read and write pointers are equal, but the Rx DMA is still
			in operation, so the buffer must be empty. */
			number_of_bytes_available = 0;
  4009a6:	2400      	movs	r4, #0
				p_rx_buffer_details->past_rx_buffer_end_address
				- next_byte_to_read;
	}

	/* Cap the number of requested bytes to those available. */
	if (bytes_to_read > number_of_bytes_available) {
  4009a8:	42bc      	cmp	r4, r7
  4009aa:	d30a      	bcc.n	4009c2 <freertos_copy_bytes_from_pdc_circular_buffer+0x42>
		bytes_to_read = number_of_bytes_available;
	} else if (bytes_to_read != number_of_bytes_available) {
  4009ac:	42a7      	cmp	r7, r4
  4009ae:	d007      	beq.n	4009c0 <freertos_copy_bytes_from_pdc_circular_buffer+0x40>
		/* There are more bytes available than being read now, so there is no
		need to wait for the interrupt to give the semaphore to indicate that
		new data is available. */
		xSemaphoreGive(p_rx_buffer_details->rx_event_semaphore);
  4009b0:	6930      	ldr	r0, [r6, #16]
  4009b2:	2100      	movs	r1, #0
  4009b4:	460a      	mov	r2, r1
  4009b6:	460b      	mov	r3, r1
  4009b8:	4c0e      	ldr	r4, [pc, #56]	; (4009f4 <freertos_copy_bytes_from_pdc_circular_buffer+0x74>)
  4009ba:	47a0      	blx	r4
  4009bc:	463c      	mov	r4, r7
  4009be:	e000      	b.n	4009c2 <freertos_copy_bytes_from_pdc_circular_buffer+0x42>
  4009c0:	463c      	mov	r4, r7
	}

	/* Copy the bytes into the user buffer. */
	memcpy(buf, (void *) p_rx_buffer_details->next_byte_to_read,
  4009c2:	4640      	mov	r0, r8
  4009c4:	69b1      	ldr	r1, [r6, #24]
  4009c6:	4622      	mov	r2, r4
  4009c8:	4b0b      	ldr	r3, [pc, #44]	; (4009f8 <freertos_copy_bytes_from_pdc_circular_buffer+0x78>)
  4009ca:	4798      	blx	r3
			bytes_to_read);

	/* Move up the read buffer accordingly, wrapping around if it reaches the
	end of the buffer. */
	next_byte_to_read += bytes_to_read;
  4009cc:	4425      	add	r5, r4

	if (next_byte_to_read >=
  4009ce:	6873      	ldr	r3, [r6, #4]
  4009d0:	429d      	cmp	r5, r3
  4009d2:	d306      	bcc.n	4009e2 <freertos_copy_bytes_from_pdc_circular_buffer+0x62>
			p_rx_buffer_details->past_rx_buffer_end_address) {
		/* The next_byte_to_read pointer is only read by the ISR, so the
		critical section is probably not needed on 32-bit machines. */
		taskENTER_CRITICAL();
  4009d4:	4b09      	ldr	r3, [pc, #36]	; (4009fc <freertos_copy_bytes_from_pdc_circular_buffer+0x7c>)
  4009d6:	4798      	blx	r3
		{
			p_rx_buffer_details->next_byte_to_read =
  4009d8:	6833      	ldr	r3, [r6, #0]
  4009da:	61b3      	str	r3, [r6, #24]
					(uint8_t *) p_rx_buffer_details->rx_buffer_start_address;
		}
		taskEXIT_CRITICAL();
  4009dc:	4b08      	ldr	r3, [pc, #32]	; (400a00 <freertos_copy_bytes_from_pdc_circular_buffer+0x80>)
  4009de:	4798      	blx	r3
  4009e0:	e004      	b.n	4009ec <freertos_copy_bytes_from_pdc_circular_buffer+0x6c>
	} else {
		/* The next_byte_to_read pointer is only read by the ISR, so the
		critical section is probably not needed on 32-bit machines. */
		taskENTER_CRITICAL();
  4009e2:	4b06      	ldr	r3, [pc, #24]	; (4009fc <freertos_copy_bytes_from_pdc_circular_buffer+0x7c>)
  4009e4:	4798      	blx	r3
		{
			p_rx_buffer_details->next_byte_to_read =
  4009e6:	61b5      	str	r5, [r6, #24]
					(uint8_t *) next_byte_to_read;
		}
		taskEXIT_CRITICAL();
  4009e8:	4b05      	ldr	r3, [pc, #20]	; (400a00 <freertos_copy_bytes_from_pdc_circular_buffer+0x80>)
  4009ea:	4798      	blx	r3
	}

	/* Return the number of bytes actually read. */
	return bytes_to_read;
}
  4009ec:	4620      	mov	r0, r4
  4009ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4009f2:	bf00      	nop
  4009f4:	00402415 	.word	0x00402415
  4009f8:	004040a1 	.word	0x004040a1
  4009fc:	00401f65 	.word	0x00401f65
  400a00:	00401f85 	.word	0x00401f85

00400a04 <freertos_obtain_peripheral_access_mutex>:
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
	xTimeOutType time_out_definition;

	if (dma_event_control->peripheral_access_mutex != NULL) {
  400a04:	6843      	ldr	r3, [r0, #4]
  400a06:	b1b3      	cbz	r3, 400a36 <freertos_obtain_peripheral_access_mutex+0x32>
 * did not become available within max_block_time_ticks tick periods.
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
  400a08:	b530      	push	{r4, r5, lr}
  400a0a:	b083      	sub	sp, #12
  400a0c:	460d      	mov	r5, r1
  400a0e:	4604      	mov	r4, r0
	status_code_t return_value = STATUS_OK;
	xTimeOutType time_out_definition;

	if (dma_event_control->peripheral_access_mutex != NULL) {
		/* Remember the time on entry. */
		vTaskSetTimeOutState(&time_out_definition);
  400a10:	4668      	mov	r0, sp
  400a12:	4b0d      	ldr	r3, [pc, #52]	; (400a48 <freertos_obtain_peripheral_access_mutex+0x44>)
  400a14:	4798      	blx	r3

		/* Wait to get exclusive access to the peripheral. */
		if (xSemaphoreTake(dma_event_control->peripheral_access_mutex,
  400a16:	6860      	ldr	r0, [r4, #4]
  400a18:	2100      	movs	r1, #0
  400a1a:	682a      	ldr	r2, [r5, #0]
  400a1c:	460b      	mov	r3, r1
  400a1e:	4c0b      	ldr	r4, [pc, #44]	; (400a4c <freertos_obtain_peripheral_access_mutex+0x48>)
  400a20:	47a0      	blx	r4
  400a22:	b158      	cbz	r0, 400a3c <freertos_obtain_peripheral_access_mutex+0x38>
				*max_block_time_ticks) == pdFAIL) {
			return_value = ERR_TIMEOUT;
		} else {
			/* Adjust the time out value in case the task had to block to
			wait for the semaphore. */
			if (xTaskCheckForTimeOut(&time_out_definition,
  400a24:	4668      	mov	r0, sp
  400a26:	4629      	mov	r1, r5
  400a28:	4b09      	ldr	r3, [pc, #36]	; (400a50 <freertos_obtain_peripheral_access_mutex+0x4c>)
  400a2a:	4798      	blx	r3
  400a2c:	2801      	cmp	r0, #1
  400a2e:	d107      	bne.n	400a40 <freertos_obtain_peripheral_access_mutex+0x3c>
					max_block_time_ticks) == pdTRUE) {
				*max_block_time_ticks = 0;
  400a30:	2000      	movs	r0, #0
  400a32:	6028      	str	r0, [r5, #0]
  400a34:	e005      	b.n	400a42 <freertos_obtain_peripheral_access_mutex+0x3e>
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
  400a36:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
  400a38:	b240      	sxtb	r0, r0
  400a3a:	4770      	bx	lr
		vTaskSetTimeOutState(&time_out_definition);

		/* Wait to get exclusive access to the peripheral. */
		if (xSemaphoreTake(dma_event_control->peripheral_access_mutex,
				*max_block_time_ticks) == pdFAIL) {
			return_value = ERR_TIMEOUT;
  400a3c:	20fd      	movs	r0, #253	; 0xfd
  400a3e:	e000      	b.n	400a42 <freertos_obtain_peripheral_access_mutex+0x3e>
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
  400a40:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
  400a42:	b240      	sxtb	r0, r0
  400a44:	b003      	add	sp, #12
  400a46:	bd30      	pop	{r4, r5, pc}
  400a48:	00403439 	.word	0x00403439
  400a4c:	00402649 	.word	0x00402649
  400a50:	00403469 	.word	0x00403469

00400a54 <freertos_start_pdc_transfer>:
 */
void freertos_start_pdc_transfer(
		freertos_dma_event_control_t *dma_event_control,
		const uint8_t *data, size_t len, void *pdc_base_address,
		xSemaphoreHandle notification_semaphore, bool is_transmitting)
{
  400a54:	b5f0      	push	{r4, r5, r6, r7, lr}
  400a56:	b083      	sub	sp, #12
  400a58:	460e      	mov	r6, r1
  400a5a:	4615      	mov	r5, r2
  400a5c:	461c      	mov	r4, r3
  400a5e:	9b08      	ldr	r3, [sp, #32]
	/* Remember which semaphore is to be used to indicate the end of
	transmission.  If notification_semaphore is NULL then either no
	semaphore is being used, or the driver is using an internal notification
	semaphore because it is configured to wait until the transmit has
	completed before returning. */
	if (notification_semaphore != NULL) {
  400a60:	b113      	cbz	r3, 400a68 <freertos_start_pdc_transfer+0x14>
		dma_event_control->transaction_complete_notification_semaphore =
  400a62:	6003      	str	r3, [r0, #0]
				notification_semaphore;
	}

	/* Ensure the notification semaphore starts in the expected state in case
	the previous PDC transfer didn't complete for any reason. */
	if (dma_event_control->transaction_complete_notification_semaphore !=
  400a64:	4618      	mov	r0, r3
  400a66:	e001      	b.n	400a6c <freertos_start_pdc_transfer+0x18>
  400a68:	6800      	ldr	r0, [r0, #0]
  400a6a:	b120      	cbz	r0, 400a76 <freertos_start_pdc_transfer+0x22>
			NULL) {
		xSemaphoreTake(
  400a6c:	2100      	movs	r1, #0
  400a6e:	460a      	mov	r2, r1
  400a70:	460b      	mov	r3, r1
  400a72:	4f13      	ldr	r7, [pc, #76]	; (400ac0 <freertos_start_pdc_transfer+0x6c>)
  400a74:	47b8      	blx	r7
				dma_event_control->transaction_complete_notification_semaphore,
				0);
	}

	/* Configure the PDC to transmit or receive parameters. */
	pdc_packet.ul_addr = (uint32_t) data;
  400a76:	9600      	str	r6, [sp, #0]
	pdc_packet.ul_size = (uint32_t) len;
  400a78:	9501      	str	r5, [sp, #4]

	if (is_transmitting == true) {
  400a7a:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
  400a7e:	b17b      	cbz	r3, 400aa0 <freertos_start_pdc_transfer+0x4c>
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_TXTDIS);
  400a80:	4620      	mov	r0, r4
  400a82:	f44f 7100 	mov.w	r1, #512	; 0x200
  400a86:	4b0f      	ldr	r3, [pc, #60]	; (400ac4 <freertos_start_pdc_transfer+0x70>)
  400a88:	4798      	blx	r3
		pdc_tx_init(pdc_base_address, &pdc_packet, NULL);
  400a8a:	4620      	mov	r0, r4
  400a8c:	4669      	mov	r1, sp
  400a8e:	2200      	movs	r2, #0
  400a90:	4b0d      	ldr	r3, [pc, #52]	; (400ac8 <freertos_start_pdc_transfer+0x74>)
  400a92:	4798      	blx	r3
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_TXTEN);
  400a94:	4620      	mov	r0, r4
  400a96:	f44f 7180 	mov.w	r1, #256	; 0x100
  400a9a:	4b0c      	ldr	r3, [pc, #48]	; (400acc <freertos_start_pdc_transfer+0x78>)
  400a9c:	4798      	blx	r3
  400a9e:	e00c      	b.n	400aba <freertos_start_pdc_transfer+0x66>
	} else {
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_RXTDIS);
  400aa0:	4620      	mov	r0, r4
  400aa2:	2102      	movs	r1, #2
  400aa4:	4b07      	ldr	r3, [pc, #28]	; (400ac4 <freertos_start_pdc_transfer+0x70>)
  400aa6:	4798      	blx	r3
		pdc_rx_init(pdc_base_address, &pdc_packet, NULL);
  400aa8:	4620      	mov	r0, r4
  400aaa:	4669      	mov	r1, sp
  400aac:	2200      	movs	r2, #0
  400aae:	4b08      	ldr	r3, [pc, #32]	; (400ad0 <freertos_start_pdc_transfer+0x7c>)
  400ab0:	4798      	blx	r3
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_RXTEN);
  400ab2:	4620      	mov	r0, r4
  400ab4:	2101      	movs	r1, #1
  400ab6:	4b05      	ldr	r3, [pc, #20]	; (400acc <freertos_start_pdc_transfer+0x78>)
  400ab8:	4798      	blx	r3
	}
}
  400aba:	b003      	add	sp, #12
  400abc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400abe:	bf00      	nop
  400ac0:	00402649 	.word	0x00402649
  400ac4:	00401499 	.word	0x00401499
  400ac8:	0040145d 	.word	0x0040145d
  400acc:	0040148d 	.word	0x0040148d
  400ad0:	00401475 	.word	0x00401475

00400ad4 <freertos_optionally_wait_transfer_completion>:
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;

	if (notification_semaphore == NULL) {
  400ad4:	b951      	cbnz	r1, 400aec <freertos_optionally_wait_transfer_completion+0x18>
		if (dma_event_control->transaction_complete_notification_semaphore !=
  400ad6:	6800      	ldr	r0, [r0, #0]
  400ad8:	b150      	cbz	r0, 400af0 <freertos_optionally_wait_transfer_completion+0x1c>
 */
status_code_t freertos_optionally_wait_transfer_completion(
		freertos_dma_event_control_t *dma_event_control,
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
  400ada:	b510      	push	{r4, lr}
	if (notification_semaphore == NULL) {
		if (dma_event_control->transaction_complete_notification_semaphore !=
				NULL) {
			/* Wait until notified by the ISR that transmission is
			complete. */
			if (xSemaphoreTake(dma_event_control->
  400adc:	460b      	mov	r3, r1
  400ade:	4c07      	ldr	r4, [pc, #28]	; (400afc <freertos_optionally_wait_transfer_completion+0x28>)
  400ae0:	47a0      	blx	r4
					transaction_complete_notification_semaphore,
					max_block_time_ticks) != pdPASS) {
				return_value = ERR_TIMEOUT;
  400ae2:	2801      	cmp	r0, #1
  400ae4:	bf0c      	ite	eq
  400ae6:	2000      	moveq	r0, #0
  400ae8:	20fd      	movne	r0, #253	; 0xfd
  400aea:	e004      	b.n	400af6 <freertos_optionally_wait_transfer_completion+0x22>
status_code_t freertos_optionally_wait_transfer_completion(
		freertos_dma_event_control_t *dma_event_control,
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
  400aec:	2000      	movs	r0, #0
  400aee:	e000      	b.n	400af2 <freertos_optionally_wait_transfer_completion+0x1e>
  400af0:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
  400af2:	b240      	sxtb	r0, r0
  400af4:	4770      	bx	lr
  400af6:	b240      	sxtb	r0, r0
  400af8:	bd10      	pop	{r4, pc}
  400afa:	bf00      	nop
  400afc:	00402649 	.word	0x00402649

00400b00 <configure_rx_dma>:
 * For internal use only.
 * Configures the Rx DMA to receive data into free space within the Rx buffer.
 */
static void configure_rx_dma(uint32_t usart_index,
		enum buffer_operations operation_performed)
{
  400b00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400b02:	4604      	mov	r4, r0
	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
  400b04:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
  400b08:	4b31      	ldr	r3, [pc, #196]	; (400bd0 <configure_rx_dma+0xd0>)
  400b0a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  400b0e:	699a      	ldr	r2, [r3, #24]
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
  400b10:	6898      	ldr	r0, [r3, #8]
	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
  400b12:	4282      	cmp	r2, r0
  400b14:	d114      	bne.n	400b40 <configure_rx_dma+0x40>
		/* The read pointer and the write pointer are equal.  If this function
		was called because data was added to the buffer, then there is no free
		space in the buffer remaining.  If this function was called because data
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
  400b16:	b951      	cbnz	r1, 400b2e <configure_rx_dma+0x2e>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
  400b18:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b1c:	492c      	ldr	r1, [pc, #176]	; (400bd0 <configure_rx_dma+0xd0>)
  400b1e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
  400b22:	2000      	movs	r0, #0
  400b24:	60d8      	str	r0, [r3, #12]
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr +
  400b26:	685b      	ldr	r3, [r3, #4]
  400b28:	429a      	cmp	r2, r3
  400b2a:	d948      	bls.n	400bbe <configure_rx_dma+0xbe>
  400b2c:	e024      	b.n	400b78 <configure_rx_dma+0x78>
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b2e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b32:	4927      	ldr	r1, [pc, #156]	; (400bd0 <configure_rx_dma+0xd0>)
  400b34:	eb01 0383 	add.w	r3, r1, r3, lsl #2
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
  400b38:	6859      	ldr	r1, [r3, #4]
  400b3a:	1a8a      	subs	r2, r1, r2
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b3c:	60da      	str	r2, [r3, #12]
  400b3e:	e011      	b.n	400b64 <configure_rx_dma+0x64>
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
  400b40:	4282      	cmp	r2, r0
  400b42:	d907      	bls.n	400b54 <configure_rx_dma+0x54>
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
		/* The read pointer is ahead of the write pointer.  The space available
		is up to the write pointer to ensure unread data is not overwritten. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b44:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b48:	4921      	ldr	r1, [pc, #132]	; (400bd0 <configure_rx_dma+0xd0>)
  400b4a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
  400b4e:	1a12      	subs	r2, r2, r0
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
		/* The read pointer is ahead of the write pointer.  The space available
		is up to the write pointer to ensure unread data is not overwritten. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b50:	60da      	str	r2, [r3, #12]
  400b52:	e007      	b.n	400b64 <configure_rx_dma+0x64>
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b54:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b58:	4a1d      	ldr	r2, [pc, #116]	; (400bd0 <configure_rx_dma+0xd0>)
  400b5a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
  400b5e:	685a      	ldr	r2, [r3, #4]
  400b60:	1a12      	subs	r2, r2, r0
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b62:	60da      	str	r2, [r3, #12]
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr +
  400b64:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b68:	4a19      	ldr	r2, [pc, #100]	; (400bd0 <configure_rx_dma+0xd0>)
  400b6a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400b6e:	68da      	ldr	r2, [r3, #12]
  400b70:	4410      	add	r0, r2
  400b72:	685b      	ldr	r3, [r3, #4]
  400b74:	4298      	cmp	r0, r3
  400b76:	d904      	bls.n	400b82 <configure_rx_dma+0x82>
  400b78:	4816      	ldr	r0, [pc, #88]	; (400bd4 <configure_rx_dma+0xd4>)
  400b7a:	f240 219b 	movw	r1, #667	; 0x29b
  400b7e:	4b16      	ldr	r3, [pc, #88]	; (400bd8 <configure_rx_dma+0xd8>)
  400b80:	4798      	blx	r3
			rx_buffer_definition->rx_pdc_parameters.ul_size) <=
			rx_buffer_definition->past_rx_buffer_end_address);

	if (rx_buffer_definition->rx_pdc_parameters.ul_size > 0) {
  400b82:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b86:	4a12      	ldr	r2, [pc, #72]	; (400bd0 <configure_rx_dma+0xd0>)
  400b88:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400b8c:	68db      	ldr	r3, [r3, #12]
  400b8e:	b1b3      	cbz	r3, 400bbe <configure_rx_dma+0xbe>
		/* Restart the DMA to receive into whichever space was calculated
		as remaining.  First clear any characters that might already be in the
		registers. */
		pdc_rx_init(
  400b90:	4e12      	ldr	r6, [pc, #72]	; (400bdc <configure_rx_dma+0xdc>)
  400b92:	0125      	lsls	r5, r4, #4
  400b94:	1973      	adds	r3, r6, r5
  400b96:	685f      	ldr	r7, [r3, #4]
  400b98:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  400b9c:	eb02 0184 	add.w	r1, r2, r4, lsl #2
  400ba0:	4638      	mov	r0, r7
  400ba2:	3108      	adds	r1, #8
  400ba4:	2200      	movs	r2, #0
  400ba6:	4b0e      	ldr	r3, [pc, #56]	; (400be0 <configure_rx_dma+0xe0>)
  400ba8:	4798      	blx	r3
				all_usart_definitions[usart_index].pdc_base_address, &rx_buffer_definition->rx_pdc_parameters,
				NULL);
		pdc_enable_transfer(
  400baa:	4638      	mov	r0, r7
  400bac:	2101      	movs	r1, #1
  400bae:	4b0d      	ldr	r3, [pc, #52]	; (400be4 <configure_rx_dma+0xe4>)
  400bb0:	4798      	blx	r3
				all_usart_definitions[usart_index].pdc_base_address,
				PERIPH_PTCR_RXTEN);
		usart_enable_interrupt(
  400bb2:	5970      	ldr	r0, [r6, r5]
  400bb4:	f44f 7184 	mov.w	r1, #264	; 0x108
  400bb8:	4b0b      	ldr	r3, [pc, #44]	; (400be8 <configure_rx_dma+0xe8>)
  400bba:	4798      	blx	r3
  400bbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		usart_disable_interrupt(
				all_usart_definitions[usart_index].peripheral_base_address, US_IER_ENDRX |
  400bbe:	0124      	lsls	r4, r4, #4
				US_IER_TIMEOUT);
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		usart_disable_interrupt(
  400bc0:	4b06      	ldr	r3, [pc, #24]	; (400bdc <configure_rx_dma+0xdc>)
  400bc2:	5918      	ldr	r0, [r3, r4]
  400bc4:	f44f 7184 	mov.w	r1, #264	; 0x108
  400bc8:	4b08      	ldr	r3, [pc, #32]	; (400bec <configure_rx_dma+0xec>)
  400bca:	4798      	blx	r3
  400bcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400bce:	bf00      	nop
  400bd0:	20000980 	.word	0x20000980
  400bd4:	00409674 	.word	0x00409674
  400bd8:	00403de1 	.word	0x00403de1
  400bdc:	004096b4 	.word	0x004096b4
  400be0:	00401475 	.word	0x00401475
  400be4:	0040148d 	.word	0x0040148d
  400be8:	0040172d 	.word	0x0040172d
  400bec:	00401731 	.word	0x00401731

00400bf0 <local_usart_handler>:
/*
 * For internal use only.
 * A common USART interrupt handler that is called for all USART peripherals.
 */
static void local_usart_handler(const portBASE_TYPE usart_index)
{
  400bf0:	b5f0      	push	{r4, r5, r6, r7, lr}
  400bf2:	b083      	sub	sp, #12
  400bf4:	4604      	mov	r4, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400bf6:	2300      	movs	r3, #0
  400bf8:	9301      	str	r3, [sp, #4]
	uint32_t usart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	usart_status = usart_get_status(
			all_usart_definitions[usart_index].peripheral_base_address);
  400bfa:	0103      	lsls	r3, r0, #4
  400bfc:	4a45      	ldr	r2, [pc, #276]	; (400d14 <local_usart_handler+0x124>)
  400bfe:	58d6      	ldr	r6, [r2, r3]
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t usart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	usart_status = usart_get_status(
  400c00:	4630      	mov	r0, r6
  400c02:	4b45      	ldr	r3, [pc, #276]	; (400d18 <local_usart_handler+0x128>)
  400c04:	4798      	blx	r3
  400c06:	4605      	mov	r5, r0
			all_usart_definitions[usart_index].peripheral_base_address);
	usart_status &= usart_get_interrupt_mask(
  400c08:	4630      	mov	r0, r6
  400c0a:	4b44      	ldr	r3, [pc, #272]	; (400d1c <local_usart_handler+0x12c>)
  400c0c:	4798      	blx	r3
  400c0e:	4005      	ands	r5, r0
			all_usart_definitions[usart_index].peripheral_base_address);

	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* Has the PDC completed a transmission? */
	if ((usart_status & US_CSR_ENDTX) != 0UL) {
  400c10:	f015 0f10 	tst.w	r5, #16
  400c14:	d016      	beq.n	400c44 <local_usart_handler+0x54>
		usart_disable_interrupt(
  400c16:	4630      	mov	r0, r6
  400c18:	2110      	movs	r1, #16
  400c1a:	4b41      	ldr	r3, [pc, #260]	; (400d20 <local_usart_handler+0x130>)
  400c1c:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address,
				US_IER_ENDTX);

		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[usart_index].peripheral_access_mutex != NULL) {
  400c1e:	4b41      	ldr	r3, [pc, #260]	; (400d24 <local_usart_handler+0x134>)
  400c20:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
  400c24:	6858      	ldr	r0, [r3, #4]
  400c26:	b120      	cbz	r0, 400c32 <local_usart_handler+0x42>
			xSemaphoreGiveFromISR(
  400c28:	2100      	movs	r1, #0
  400c2a:	aa01      	add	r2, sp, #4
  400c2c:	460b      	mov	r3, r1
  400c2e:	4f3e      	ldr	r7, [pc, #248]	; (400d28 <local_usart_handler+0x138>)
  400c30:	47b8      	blx	r7
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (tx_dma_control[usart_index].transaction_complete_notification_semaphore != NULL) {
  400c32:	4b3c      	ldr	r3, [pc, #240]	; (400d24 <local_usart_handler+0x134>)
  400c34:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
  400c38:	b120      	cbz	r0, 400c44 <local_usart_handler+0x54>
			xSemaphoreGiveFromISR(
  400c3a:	2100      	movs	r1, #0
  400c3c:	aa01      	add	r2, sp, #4
  400c3e:	460b      	mov	r3, r1
  400c40:	4f39      	ldr	r7, [pc, #228]	; (400d28 <local_usart_handler+0x138>)
  400c42:	47b8      	blx	r7
					tx_dma_control[usart_index].transaction_complete_notification_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & US_CSR_ENDRX) != 0UL) {
  400c44:	f015 0f08 	tst.w	r5, #8
  400c48:	d03b      	beq.n	400cc2 <local_usart_handler+0xd2>
		/* It is possible to initialise the peripheral to only use Tx and not Rx.
		Check that Rx has been initialised. */
		configASSERT(rx_buffer_definition->next_byte_to_read);
  400c4a:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400c4e:	4a37      	ldr	r2, [pc, #220]	; (400d2c <local_usart_handler+0x13c>)
  400c50:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400c54:	699b      	ldr	r3, [r3, #24]
  400c56:	b923      	cbnz	r3, 400c62 <local_usart_handler+0x72>
  400c58:	4835      	ldr	r0, [pc, #212]	; (400d30 <local_usart_handler+0x140>)
  400c5a:	f240 21df 	movw	r1, #735	; 0x2df
  400c5e:	4b35      	ldr	r3, [pc, #212]	; (400d34 <local_usart_handler+0x144>)
  400c60:	4798      	blx	r3
		configASSERT(rx_buffer_definition->next_byte_to_read !=
  400c62:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400c66:	4a31      	ldr	r2, [pc, #196]	; (400d2c <local_usart_handler+0x13c>)
  400c68:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400c6c:	699b      	ldr	r3, [r3, #24]
  400c6e:	2b01      	cmp	r3, #1
  400c70:	d104      	bne.n	400c7c <local_usart_handler+0x8c>
  400c72:	482f      	ldr	r0, [pc, #188]	; (400d30 <local_usart_handler+0x140>)
  400c74:	f240 21e1 	movw	r1, #737	; 0x2e1
  400c78:	4b2e      	ldr	r3, [pc, #184]	; (400d34 <local_usart_handler+0x144>)
  400c7a:	4798      	blx	r3

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
				rx_buffer_definition->rx_pdc_parameters.ul_size;
  400c7c:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400c80:	4a2a      	ldr	r2, [pc, #168]	; (400d2c <local_usart_handler+0x13c>)
  400c82:	eb02 0383 	add.w	r3, r2, r3, lsl #2
				RX_NOT_USED);

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
  400c86:	68d9      	ldr	r1, [r3, #12]
  400c88:	689a      	ldr	r2, [r3, #8]
  400c8a:	440a      	add	r2, r1
  400c8c:	609a      	str	r2, [r3, #8]
				rx_buffer_definition->rx_pdc_parameters.ul_size;

		/* If the end of the buffer has been reached, wrap back to the start. */
		if (rx_buffer_definition->rx_pdc_parameters.ul_addr >=
  400c8e:	685b      	ldr	r3, [r3, #4]
  400c90:	429a      	cmp	r2, r3
  400c92:	d306      	bcc.n	400ca2 <local_usart_handler+0xb2>
				rx_buffer_definition->past_rx_buffer_end_address)
		{
			rx_buffer_definition->rx_pdc_parameters.ul_addr =
  400c94:	4a25      	ldr	r2, [pc, #148]	; (400d2c <local_usart_handler+0x13c>)
  400c96:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400c9a:	009b      	lsls	r3, r3, #2
  400c9c:	18d1      	adds	r1, r2, r3
  400c9e:	58d3      	ldr	r3, [r2, r3]
  400ca0:	608b      	str	r3, [r1, #8]
					rx_buffer_definition->rx_buffer_start_address;
		}

		/* Reset the Rx DMA to receive data into whatever free space remains in
		the Rx buffer. */
		configure_rx_dma(usart_index, data_added);
  400ca2:	4620      	mov	r0, r4
  400ca4:	2100      	movs	r1, #0
  400ca6:	4b24      	ldr	r3, [pc, #144]	; (400d38 <local_usart_handler+0x148>)
  400ca8:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
  400caa:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400cae:	4a1f      	ldr	r2, [pc, #124]	; (400d2c <local_usart_handler+0x13c>)
  400cb0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400cb4:	6918      	ldr	r0, [r3, #16]
  400cb6:	b120      	cbz	r0, 400cc2 <local_usart_handler+0xd2>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
  400cb8:	2100      	movs	r1, #0
  400cba:	aa01      	add	r2, sp, #4
  400cbc:	460b      	mov	r3, r1
  400cbe:	4f1a      	ldr	r7, [pc, #104]	; (400d28 <local_usart_handler+0x138>)
  400cc0:	47b8      	blx	r7
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & US_IER_TIMEOUT) != 0UL) {
  400cc2:	f415 7f80 	tst.w	r5, #256	; 0x100
  400cc6:	d00e      	beq.n	400ce6 <local_usart_handler+0xf6>
		/* More characters have been placed into the Rx buffer.

		Restart the timeout after more data has been received. */
		usart_start_rx_timeout(all_usart_definitions[usart_index].peripheral_base_address);
  400cc8:	4630      	mov	r0, r6
  400cca:	4b1c      	ldr	r3, [pc, #112]	; (400d3c <local_usart_handler+0x14c>)
  400ccc:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
  400cce:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400cd2:	4a16      	ldr	r2, [pc, #88]	; (400d2c <local_usart_handler+0x13c>)
  400cd4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400cd8:	6918      	ldr	r0, [r3, #16]
  400cda:	b120      	cbz	r0, 400ce6 <local_usart_handler+0xf6>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
  400cdc:	2100      	movs	r1, #0
  400cde:	aa01      	add	r2, sp, #4
  400ce0:	460b      	mov	r3, r1
  400ce2:	4f11      	ldr	r7, [pc, #68]	; (400d28 <local_usart_handler+0x138>)
  400ce4:	47b8      	blx	r7
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & SR_ERROR_INTERRUPTS) != 0) {
  400ce6:	f015 0fe0 	tst.w	r5, #224	; 0xe0
  400cea:	d00c      	beq.n	400d06 <local_usart_handler+0x116>
		/* An error occurred in either a transmission or reception.  Abort, and
		ensure the peripheral access mutex is made available to tasks. */
		usart_reset_status(
  400cec:	4630      	mov	r0, r6
  400cee:	4b14      	ldr	r3, [pc, #80]	; (400d40 <local_usart_handler+0x150>)
  400cf0:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address);
		if (tx_dma_control[usart_index].peripheral_access_mutex != NULL) {
  400cf2:	4b0c      	ldr	r3, [pc, #48]	; (400d24 <local_usart_handler+0x134>)
  400cf4:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
  400cf8:	6860      	ldr	r0, [r4, #4]
  400cfa:	b120      	cbz	r0, 400d06 <local_usart_handler+0x116>
			xSemaphoreGiveFromISR(
  400cfc:	2100      	movs	r1, #0
  400cfe:	aa01      	add	r2, sp, #4
  400d00:	460b      	mov	r3, r1
  400d02:	4c09      	ldr	r4, [pc, #36]	; (400d28 <local_usart_handler+0x138>)
  400d04:	47a0      	blx	r4
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
  400d06:	9b01      	ldr	r3, [sp, #4]
  400d08:	b10b      	cbz	r3, 400d0e <local_usart_handler+0x11e>
  400d0a:	4b0e      	ldr	r3, [pc, #56]	; (400d44 <local_usart_handler+0x154>)
  400d0c:	4798      	blx	r3
}
  400d0e:	b003      	add	sp, #12
  400d10:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400d12:	bf00      	nop
  400d14:	004096b4 	.word	0x004096b4
  400d18:	00401739 	.word	0x00401739
  400d1c:	00401735 	.word	0x00401735
  400d20:	00401731 	.word	0x00401731
  400d24:	20000a60 	.word	0x20000a60
  400d28:	004025ad 	.word	0x004025ad
  400d2c:	20000980 	.word	0x20000980
  400d30:	00409674 	.word	0x00409674
  400d34:	00403de1 	.word	0x00403de1
  400d38:	00400b01 	.word	0x00400b01
  400d3c:	00401745 	.word	0x00401745
  400d40:	0040173d 	.word	0x0040173d
  400d44:	00401f45 	.word	0x00401f45

00400d48 <freertos_usart_serial_init>:
 *     the initialisation fails then NULL is returned.
 */
freertos_usart_if freertos_usart_serial_init(Usart *p_usart,
		const sam_usart_opt_t *const uart_parameters,
		const freertos_peripheral_options_t *const freertos_driver_parameters)
{
  400d48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  400d4c:	b082      	sub	sp, #8
  400d4e:	4605      	mov	r5, r0
  400d50:	4689      	mov	r9, r1
  400d52:	4616      	mov	r6, r2
	portBASE_TYPE usart_index;
	bool is_valid_operating_mode;
	freertos_usart_if return_value;
	const enum peripheral_operation_mode valid_operating_modes[] = {USART_RS232};
  400d54:	af02      	add	r7, sp, #8
  400d56:	2300      	movs	r3, #0
  400d58:	f807 3d04 	strb.w	r3, [r7, #-4]!

	/* Find the index into the all_usart_definitions array that holds details of
	the p_usart peripheral. */
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
  400d5c:	4862      	ldr	r0, [pc, #392]	; (400ee8 <freertos_usart_serial_init+0x1a0>)
  400d5e:	2108      	movs	r1, #8
  400d60:	462a      	mov	r2, r5
  400d62:	4b62      	ldr	r3, [pc, #392]	; (400eec <freertos_usart_serial_init+0x1a4>)
  400d64:	4798      	blx	r3
  400d66:	4604      	mov	r4, r0
			MAX_USARTS,
			(void *) p_usart);

	/* Check the requested operating mode is valid for the peripheral. */
	is_valid_operating_mode = check_requested_operating_mode(
  400d68:	7b30      	ldrb	r0, [r6, #12]
  400d6a:	4639      	mov	r1, r7
  400d6c:	2201      	movs	r2, #1
  400d6e:	4b60      	ldr	r3, [pc, #384]	; (400ef0 <freertos_usart_serial_init+0x1a8>)
  400d70:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_usart pointer was used, and a valid
	operating mode was requested. */
	if ((usart_index < MAX_USARTS) && (is_valid_operating_mode == true)) {
  400d72:	2c07      	cmp	r4, #7
  400d74:	f300 80b1 	bgt.w	400eda <freertos_usart_serial_init+0x192>
  400d78:	2800      	cmp	r0, #0
  400d7a:	f000 80b0 	beq.w	400ede <freertos_usart_serial_init+0x196>
		/* This function must be called exactly once per supported USART.  Check it
		has not been called	before. */
		configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read == NULL);
  400d7e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400d82:	4a5c      	ldr	r2, [pc, #368]	; (400ef4 <freertos_usart_serial_init+0x1ac>)
  400d84:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400d88:	699b      	ldr	r3, [r3, #24]
  400d8a:	b11b      	cbz	r3, 400d94 <freertos_usart_serial_init+0x4c>
  400d8c:	485a      	ldr	r0, [pc, #360]	; (400ef8 <freertos_usart_serial_init+0x1b0>)
  400d8e:	21e7      	movs	r1, #231	; 0xe7
  400d90:	4b5a      	ldr	r3, [pc, #360]	; (400efc <freertos_usart_serial_init+0x1b4>)
  400d92:	4798      	blx	r3

		/* Disable everything before enabling the clock. */
		usart_disable_tx(p_usart);
  400d94:	4628      	mov	r0, r5
  400d96:	4b5a      	ldr	r3, [pc, #360]	; (400f00 <freertos_usart_serial_init+0x1b8>)
  400d98:	4798      	blx	r3
		usart_disable_rx(p_usart);
  400d9a:	4628      	mov	r0, r5
  400d9c:	4b59      	ldr	r3, [pc, #356]	; (400f04 <freertos_usart_serial_init+0x1bc>)
  400d9e:	4798      	blx	r3
		pdc_disable_transfer(all_usart_definitions[usart_index].pdc_base_address,
  400da0:	f8df a144 	ldr.w	sl, [pc, #324]	; 400ee8 <freertos_usart_serial_init+0x1a0>
  400da4:	0127      	lsls	r7, r4, #4
  400da6:	eb0a 0307 	add.w	r3, sl, r7
  400daa:	f8d3 8004 	ldr.w	r8, [r3, #4]
  400dae:	4640      	mov	r0, r8
  400db0:	f240 2102 	movw	r1, #514	; 0x202
  400db4:	4b54      	ldr	r3, [pc, #336]	; (400f08 <freertos_usart_serial_init+0x1c0>)
  400db6:	4798      	blx	r3
				(PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS));

#if (SAMG55)
		/* Enable the peripheral and set USART mode. */
		uint32_t temp = (uint32_t)all_usart_definitions[usart_index].peripheral_base_address - 0x200;
  400db8:	f85a 7007 	ldr.w	r7, [sl, r7]
  400dbc:	f5a7 7700 	sub.w	r7, r7, #512	; 0x200
		Flexcom *p_flexcom = (Flexcom *)temp;
		flexcom_enable(p_flexcom);
  400dc0:	4638      	mov	r0, r7
  400dc2:	4b52      	ldr	r3, [pc, #328]	; (400f0c <freertos_usart_serial_init+0x1c4>)
  400dc4:	4798      	blx	r3
		flexcom_set_opmode(p_flexcom, FLEXCOM_USART);
  400dc6:	4638      	mov	r0, r7
  400dc8:	2101      	movs	r1, #1
  400dca:	4b51      	ldr	r3, [pc, #324]	; (400f10 <freertos_usart_serial_init+0x1c8>)
  400dcc:	4798      	blx	r3
		/* Enable the peripheral clock in the PMC. */
		pmc_enable_periph_clk(
				all_usart_definitions[usart_index].peripheral_id);
#endif

		switch (freertos_driver_parameters->operation_mode) {
  400dce:	7b33      	ldrb	r3, [r6, #12]
  400dd0:	b923      	cbnz	r3, 400ddc <freertos_usart_serial_init+0x94>
		case USART_RS232:
			/* Call the standard ASF init function. */
			usart_init_rs232(p_usart, uart_parameters,
  400dd2:	4628      	mov	r0, r5
  400dd4:	4649      	mov	r1, r9
  400dd6:	4a4f      	ldr	r2, [pc, #316]	; (400f14 <freertos_usart_serial_init+0x1cc>)
  400dd8:	4b4f      	ldr	r3, [pc, #316]	; (400f18 <freertos_usart_serial_init+0x1d0>)
  400dda:	4798      	blx	r3
			/* Other modes are not currently supported. */
			break;
		}

		/* Disable all the interrupts. */
		usart_disable_interrupt(p_usart, MASK_ALL_INTERRUPTS);
  400ddc:	4628      	mov	r0, r5
  400dde:	f04f 31ff 	mov.w	r1, #4294967295
  400de2:	4b4e      	ldr	r3, [pc, #312]	; (400f1c <freertos_usart_serial_init+0x1d4>)
  400de4:	4798      	blx	r3

		/* Create any required peripheral access mutexes and transaction complete
		semaphores.  This peripheral is full duplex so only the Tx semaphores
		are created in the following function.  The the Rx semaphores are
		created	separately. */
		create_peripheral_control_semaphores(
  400de6:	7b70      	ldrb	r0, [r6, #13]
  400de8:	494d      	ldr	r1, [pc, #308]	; (400f20 <freertos_usart_serial_init+0x1d8>)
  400dea:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
  400dee:	2200      	movs	r2, #0
  400df0:	4b4c      	ldr	r3, [pc, #304]	; (400f24 <freertos_usart_serial_init+0x1dc>)
  400df2:	4798      	blx	r3
				freertos_driver_parameters->options_flags,
				&(tx_dma_control[usart_index]),
				NULL /* The rx structures are not created in this function. */);

		/* Is the driver also going to receive? */
		if (freertos_driver_parameters->receive_buffer != NULL) {
  400df4:	6833      	ldr	r3, [r6, #0]
  400df6:	2b00      	cmp	r3, #0
  400df8:	d055      	beq.n	400ea6 <freertos_usart_serial_init+0x15e>
			capped to that available up to the end of the buffer only.  If this
			semaphore was a binary semaphore, it would then be 'taken' even
			though, unknown to the reading task, unread and therefore available
			data remained at the beginning of the buffer. */
			rx_buffer_definitions[usart_index].rx_event_semaphore =
					xSemaphoreCreateCounting(portMAX_DELAY, 0);
  400dfa:	f04f 30ff 	mov.w	r0, #4294967295
  400dfe:	2100      	movs	r1, #0
  400e00:	4b49      	ldr	r3, [pc, #292]	; (400f28 <freertos_usart_serial_init+0x1e0>)
  400e02:	4798      	blx	r3
			and the end of the buffer, the actual amount returned will be
			capped to that available up to the end of the buffer only.  If this
			semaphore was a binary semaphore, it would then be 'taken' even
			though, unknown to the reading task, unread and therefore available
			data remained at the beginning of the buffer. */
			rx_buffer_definitions[usart_index].rx_event_semaphore =
  400e04:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400e08:	4a3a      	ldr	r2, [pc, #232]	; (400ef4 <freertos_usart_serial_init+0x1ac>)
  400e0a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400e0e:	6118      	str	r0, [r3, #16]
					xSemaphoreCreateCounting(portMAX_DELAY, 0);
			configASSERT(rx_buffer_definitions[usart_index].rx_event_semaphore);
  400e10:	b920      	cbnz	r0, 400e1c <freertos_usart_serial_init+0xd4>
  400e12:	4839      	ldr	r0, [pc, #228]	; (400ef8 <freertos_usart_serial_init+0x1b0>)
  400e14:	f44f 7192 	mov.w	r1, #292	; 0x124
  400e18:	4b38      	ldr	r3, [pc, #224]	; (400efc <freertos_usart_serial_init+0x1b4>)
  400e1a:	4798      	blx	r3

			/* Set the timeout to 5ms, then start waiting for a character (the
			timeout is not started until characters have started to	be
			received). */
			usart_set_rx_timeout(p_usart,
  400e1c:	f8d9 3000 	ldr.w	r3, [r9]
  400e20:	4942      	ldr	r1, [pc, #264]	; (400f2c <freertos_usart_serial_init+0x1e4>)
  400e22:	fba1 3103 	umull	r3, r1, r1, r3
  400e26:	4628      	mov	r0, r5
  400e28:	0989      	lsrs	r1, r1, #6
  400e2a:	4b41      	ldr	r3, [pc, #260]	; (400f30 <freertos_usart_serial_init+0x1e8>)
  400e2c:	4798      	blx	r3
					(uart_parameters->baudrate / BITS_PER_5_MS));
			usart_start_rx_timeout(p_usart);
  400e2e:	4628      	mov	r0, r5
  400e30:	4b40      	ldr	r3, [pc, #256]	; (400f34 <freertos_usart_serial_init+0x1ec>)
  400e32:	4798      	blx	r3

			/* The receive buffer is currently empty, so the DMA has control
			over the entire buffer. */
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr =
  400e34:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 400ef4 <freertos_usart_serial_init+0x1ac>
  400e38:	00e1      	lsls	r1, r4, #3
  400e3a:	ebc4 0901 	rsb	r9, r4, r1
  400e3e:	ea4f 0989 	mov.w	r9, r9, lsl #2
  400e42:	eb0a 0709 	add.w	r7, sl, r9
  400e46:	6833      	ldr	r3, [r6, #0]
  400e48:	60bb      	str	r3, [r7, #8]
					(uint32_t)freertos_driver_parameters->receive_buffer;
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size =
					freertos_driver_parameters->receive_buffer_size;
  400e4a:	6873      	ldr	r3, [r6, #4]

			/* The receive buffer is currently empty, so the DMA has control
			over the entire buffer. */
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr =
					(uint32_t)freertos_driver_parameters->receive_buffer;
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size =
  400e4c:	60fb      	str	r3, [r7, #12]
					freertos_driver_parameters->receive_buffer_size;
			pdc_rx_init(
  400e4e:	1b09      	subs	r1, r1, r4
  400e50:	eb0a 0181 	add.w	r1, sl, r1, lsl #2
  400e54:	4640      	mov	r0, r8
  400e56:	3108      	adds	r1, #8
  400e58:	2200      	movs	r2, #0
  400e5a:	4b37      	ldr	r3, [pc, #220]	; (400f38 <freertos_usart_serial_init+0x1f0>)
  400e5c:	4798      	blx	r3
					NULL);

			/* Set the next byte to read to the start of the buffer as no data
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
					freertos_driver_parameters->receive_buffer;
  400e5e:	6833      	ldr	r3, [r6, #0]
					&(rx_buffer_definitions[usart_index].rx_pdc_parameters),
					NULL);

			/* Set the next byte to read to the start of the buffer as no data
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
  400e60:	61bb      	str	r3, [r7, #24]
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
  400e62:	68bb      	ldr	r3, [r7, #8]
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
  400e64:	f84a 3009 	str.w	r3, [sl, r9]
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
			rx_buffer_definitions[usart_index].past_rx_buffer_end_address =
					rx_buffer_definitions[usart_index].rx_buffer_start_address +
  400e68:	6872      	ldr	r2, [r6, #4]
  400e6a:	4413      	add	r3, r2
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
			rx_buffer_definitions[usart_index].past_rx_buffer_end_address =
  400e6c:	607b      	str	r3, [r7, #4]
					rx_buffer_definitions[usart_index].rx_buffer_start_address +
					freertos_driver_parameters->receive_buffer_size;

			/* If the rx driver is to be thread aware, create an access control
			mutex. */
			if ((freertos_driver_parameters->options_flags &
  400e6e:	7b73      	ldrb	r3, [r6, #13]
  400e70:	f013 0f02 	tst.w	r3, #2
  400e74:	d00d      	beq.n	400e92 <freertos_usart_serial_init+0x14a>
					USE_RX_ACCESS_MUTEX) != 0) {
				rx_buffer_definitions[usart_index].rx_access_mutex =
					xSemaphoreCreateMutex();
  400e76:	2001      	movs	r0, #1
  400e78:	4b30      	ldr	r3, [pc, #192]	; (400f3c <freertos_usart_serial_init+0x1f4>)
  400e7a:	4798      	blx	r3

			/* If the rx driver is to be thread aware, create an access control
			mutex. */
			if ((freertos_driver_parameters->options_flags &
					USE_RX_ACCESS_MUTEX) != 0) {
				rx_buffer_definitions[usart_index].rx_access_mutex =
  400e7c:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400e80:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
  400e84:	6158      	str	r0, [r3, #20]
					xSemaphoreCreateMutex();
				configASSERT(rx_buffer_definitions[usart_index].rx_access_mutex);
  400e86:	b920      	cbnz	r0, 400e92 <freertos_usart_serial_init+0x14a>
  400e88:	481b      	ldr	r0, [pc, #108]	; (400ef8 <freertos_usart_serial_init+0x1b0>)
  400e8a:	f44f 71a5 	mov.w	r1, #330	; 0x14a
  400e8e:	4b1b      	ldr	r3, [pc, #108]	; (400efc <freertos_usart_serial_init+0x1b4>)
  400e90:	4798      	blx	r3
			}

			/* Catch the DMA running out of Rx space, and gaps in the
			reception.  These events are both used to signal that there is
			data available in the Rx buffer. */
			usart_enable_interrupt(p_usart, US_IER_ENDRX | US_IER_TIMEOUT);
  400e92:	4628      	mov	r0, r5
  400e94:	f44f 7184 	mov.w	r1, #264	; 0x108
  400e98:	4b29      	ldr	r3, [pc, #164]	; (400f40 <freertos_usart_serial_init+0x1f8>)
  400e9a:	4798      	blx	r3

			/* The Rx DMA is running all the time, so enable it now. */
			pdc_enable_transfer(
  400e9c:	4640      	mov	r0, r8
  400e9e:	2101      	movs	r1, #1
  400ea0:	4b28      	ldr	r3, [pc, #160]	; (400f44 <freertos_usart_serial_init+0x1fc>)
  400ea2:	4798      	blx	r3
  400ea4:	e006      	b.n	400eb4 <freertos_usart_serial_init+0x16c>
		} else {
			/* next_byte_to_read is used to check to see if this function
			has been called before, so it must be set to something, even if
			it is not going to be used.  The value it is set to is not
			important, provided it is not zero (NULL). */
			rx_buffer_definitions[usart_index].next_byte_to_read = RX_NOT_USED;
  400ea6:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400eaa:	4a12      	ldr	r2, [pc, #72]	; (400ef4 <freertos_usart_serial_init+0x1ac>)
  400eac:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400eb0:	2201      	movs	r2, #1
  400eb2:	619a      	str	r2, [r3, #24]
		}

		/* Configure and enable the USART interrupt in the interrupt controller. */
		configure_interrupt_controller(all_usart_definitions[usart_index].peripheral_irq,
  400eb4:	4f0c      	ldr	r7, [pc, #48]	; (400ee8 <freertos_usart_serial_init+0x1a0>)
  400eb6:	0124      	lsls	r4, r4, #4
  400eb8:	193b      	adds	r3, r7, r4
  400eba:	f993 000c 	ldrsb.w	r0, [r3, #12]
  400ebe:	68b1      	ldr	r1, [r6, #8]
  400ec0:	4b21      	ldr	r3, [pc, #132]	; (400f48 <freertos_usart_serial_init+0x200>)
  400ec2:	4798      	blx	r3
				freertos_driver_parameters->interrupt_priority);

		/* Error interrupts are always enabled. */
		usart_enable_interrupt(
  400ec4:	5938      	ldr	r0, [r7, r4]
  400ec6:	21e0      	movs	r1, #224	; 0xe0
  400ec8:	4b1d      	ldr	r3, [pc, #116]	; (400f40 <freertos_usart_serial_init+0x1f8>)
  400eca:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address,
				IER_ERROR_INTERRUPTS);

		/* Finally, enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  400ecc:	4628      	mov	r0, r5
  400ece:	4b1f      	ldr	r3, [pc, #124]	; (400f4c <freertos_usart_serial_init+0x204>)
  400ed0:	4798      	blx	r3
		usart_enable_rx(p_usart);
  400ed2:	4628      	mov	r0, r5
  400ed4:	4b1e      	ldr	r3, [pc, #120]	; (400f50 <freertos_usart_serial_init+0x208>)
  400ed6:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_usart pointer was used, and a valid
	operating mode was requested. */
	if ((usart_index < MAX_USARTS) && (is_valid_operating_mode == true)) {
  400ed8:	e002      	b.n	400ee0 <freertos_usart_serial_init+0x198>
		usart_enable_tx(p_usart);
		usart_enable_rx(p_usart);

		return_value = (freertos_usart_if) p_usart;
	} else {
		return_value = NULL;
  400eda:	2500      	movs	r5, #0
  400edc:	e000      	b.n	400ee0 <freertos_usart_serial_init+0x198>
  400ede:	2500      	movs	r5, #0
	}

	return return_value;
}
  400ee0:	4628      	mov	r0, r5
  400ee2:	b002      	add	sp, #8
  400ee4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  400ee8:	004096b4 	.word	0x004096b4
  400eec:	004007fd 	.word	0x004007fd
  400ef0:	0040082d 	.word	0x0040082d
  400ef4:	20000980 	.word	0x20000980
  400ef8:	00409674 	.word	0x00409674
  400efc:	00403de1 	.word	0x00403de1
  400f00:	00401711 	.word	0x00401711
  400f04:	00401721 	.word	0x00401721
  400f08:	00401499 	.word	0x00401499
  400f0c:	004012dd 	.word	0x004012dd
  400f10:	00401459 	.word	0x00401459
  400f14:	07270000 	.word	0x07270000
  400f18:	004016b5 	.word	0x004016b5
  400f1c:	00401731 	.word	0x00401731
  400f20:	20000a60 	.word	0x20000a60
  400f24:	00400861 	.word	0x00400861
  400f28:	004023e5 	.word	0x004023e5
  400f2c:	51eb851f 	.word	0x51eb851f
  400f30:	00401729 	.word	0x00401729
  400f34:	00401745 	.word	0x00401745
  400f38:	00401475 	.word	0x00401475
  400f3c:	00402545 	.word	0x00402545
  400f40:	0040172d 	.word	0x0040172d
  400f44:	0040148d 	.word	0x0040148d
  400f48:	00400915 	.word	0x00400915
  400f4c:	00401709 	.word	0x00401709
  400f50:	00401719 	.word	0x00401719

00400f54 <freertos_usart_write_packet_async>:
 *     operation.
 */
status_code_t freertos_usart_write_packet_async(freertos_usart_if p_usart,
		const uint8_t *data, size_t len, portTickType block_time_ticks,
		xSemaphoreHandle notification_semaphore)
{
  400f54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400f58:	b084      	sub	sp, #16
  400f5a:	4605      	mov	r5, r0
  400f5c:	460f      	mov	r7, r1
  400f5e:	4616      	mov	r6, r2
  400f60:	9303      	str	r3, [sp, #12]
	status_code_t return_value;
	portBASE_TYPE usart_index;
	Usart *usart_base;

	usart_base = (Usart *) p_usart;
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
  400f62:	4817      	ldr	r0, [pc, #92]	; (400fc0 <freertos_usart_write_packet_async+0x6c>)
  400f64:	2108      	movs	r1, #8
  400f66:	462a      	mov	r2, r5
  400f68:	4b16      	ldr	r3, [pc, #88]	; (400fc4 <freertos_usart_write_packet_async+0x70>)
  400f6a:	4798      	blx	r3
  400f6c:	4680      	mov	r8, r0
			MAX_USARTS,
			(void *) usart_base);

	/* Don't do anything unless a valid USART pointer was used. */
	if (usart_index < MAX_USARTS) {
  400f6e:	2807      	cmp	r0, #7
  400f70:	dc21      	bgt.n	400fb6 <freertos_usart_write_packet_async+0x62>
		return_value = freertos_obtain_peripheral_access_mutex(
  400f72:	4c15      	ldr	r4, [pc, #84]	; (400fc8 <freertos_usart_write_packet_async+0x74>)
  400f74:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
  400f78:	4620      	mov	r0, r4
  400f7a:	a903      	add	r1, sp, #12
  400f7c:	4b13      	ldr	r3, [pc, #76]	; (400fcc <freertos_usart_write_packet_async+0x78>)
  400f7e:	4798      	blx	r3
				&(tx_dma_control[usart_index]),
				&block_time_ticks);

		if (return_value == STATUS_OK) {
  400f80:	4603      	mov	r3, r0
  400f82:	b9c8      	cbnz	r0, 400fb8 <freertos_usart_write_packet_async+0x64>
			freertos_start_pdc_tx(&(tx_dma_control[usart_index]),
  400f84:	4b0e      	ldr	r3, [pc, #56]	; (400fc0 <freertos_usart_write_packet_async+0x6c>)
  400f86:	eb03 1808 	add.w	r8, r3, r8, lsl #4
  400f8a:	f8d8 3004 	ldr.w	r3, [r8, #4]
  400f8e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  400f90:	9200      	str	r2, [sp, #0]
  400f92:	2201      	movs	r2, #1
  400f94:	9201      	str	r2, [sp, #4]
  400f96:	4620      	mov	r0, r4
  400f98:	4639      	mov	r1, r7
  400f9a:	4632      	mov	r2, r6
  400f9c:	4e0c      	ldr	r6, [pc, #48]	; (400fd0 <freertos_usart_write_packet_async+0x7c>)
  400f9e:	47b0      	blx	r6
			/* Catch the end of transmission so the access mutex can be
			returned, and the task notified (if it supplied a notification
			semaphore).  The interrupt can be enabled here because the ENDTX
			signal from the PDC to the USART will have been de-asserted when
			the next transfer was configured. */
			usart_enable_interrupt(usart_base, US_IER_ENDTX);
  400fa0:	4628      	mov	r0, r5
  400fa2:	2110      	movs	r1, #16
  400fa4:	4b0b      	ldr	r3, [pc, #44]	; (400fd4 <freertos_usart_write_packet_async+0x80>)
  400fa6:	4798      	blx	r3

			return_value = freertos_optionally_wait_transfer_completion(
  400fa8:	4620      	mov	r0, r4
  400faa:	990a      	ldr	r1, [sp, #40]	; 0x28
  400fac:	9a03      	ldr	r2, [sp, #12]
  400fae:	4b0a      	ldr	r3, [pc, #40]	; (400fd8 <freertos_usart_write_packet_async+0x84>)
  400fb0:	4798      	blx	r3
  400fb2:	4603      	mov	r3, r0
  400fb4:	e000      	b.n	400fb8 <freertos_usart_write_packet_async+0x64>
					&(tx_dma_control[usart_index]),
					notification_semaphore,
					block_time_ticks);
		}
	} else {
		return_value = ERR_INVALID_ARG;
  400fb6:	23f8      	movs	r3, #248	; 0xf8
	}

	return return_value;
}
  400fb8:	b258      	sxtb	r0, r3
  400fba:	b004      	add	sp, #16
  400fbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  400fc0:	004096b4 	.word	0x004096b4
  400fc4:	004007fd 	.word	0x004007fd
  400fc8:	20000a60 	.word	0x20000a60
  400fcc:	00400a05 	.word	0x00400a05
  400fd0:	00400a55 	.word	0x00400a55
  400fd4:	0040172d 	.word	0x0040172d
  400fd8:	00400ad5 	.word	0x00400ad5

00400fdc <freertos_usart_serial_read_packet>:
 * \return     The number of bytes that were copied into data.  This will be
 *     less than the requested number of bytes if a time out occurred.
 */
uint32_t freertos_usart_serial_read_packet(freertos_usart_if p_usart,
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
  400fdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400fe0:	b085      	sub	sp, #20
  400fe2:	4604      	mov	r4, r0
  400fe4:	460f      	mov	r7, r1
  400fe6:	4616      	mov	r6, r2
  400fe8:	9301      	str	r3, [sp, #4]
	Usart *usart_base;
	xTimeOutType time_out_definition;
	uint32_t bytes_read = 0;

	usart_base = (Usart *) p_usart;
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
  400fea:	484b      	ldr	r0, [pc, #300]	; (401118 <freertos_usart_serial_read_packet+0x13c>)
  400fec:	2108      	movs	r1, #8
  400fee:	4622      	mov	r2, r4
  400ff0:	4b4a      	ldr	r3, [pc, #296]	; (40111c <freertos_usart_serial_read_packet+0x140>)
  400ff2:	4798      	blx	r3
  400ff4:	4604      	mov	r4, r0
			MAX_USARTS,
			(void *) usart_base);

	/* It is possible to initialise the peripheral to only use Tx and not Rx.
	Check that Rx has been initialised. */
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read);
  400ff6:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
  400ffa:	4b49      	ldr	r3, [pc, #292]	; (401120 <freertos_usart_serial_read_packet+0x144>)
  400ffc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  401000:	699b      	ldr	r3, [r3, #24]
  401002:	b923      	cbnz	r3, 40100e <freertos_usart_serial_read_packet+0x32>
  401004:	4847      	ldr	r0, [pc, #284]	; (401124 <freertos_usart_serial_read_packet+0x148>)
  401006:	f44f 7108 	mov.w	r1, #544	; 0x220
  40100a:	4b47      	ldr	r3, [pc, #284]	; (401128 <freertos_usart_serial_read_packet+0x14c>)
  40100c:	4798      	blx	r3
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read !=
  40100e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  401012:	4a43      	ldr	r2, [pc, #268]	; (401120 <freertos_usart_serial_read_packet+0x144>)
  401014:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401018:	699b      	ldr	r3, [r3, #24]
  40101a:	2b01      	cmp	r3, #1
  40101c:	d104      	bne.n	401028 <freertos_usart_serial_read_packet+0x4c>
  40101e:	4841      	ldr	r0, [pc, #260]	; (401124 <freertos_usart_serial_read_packet+0x148>)
  401020:	f240 2122 	movw	r1, #546	; 0x222
  401024:	4b40      	ldr	r3, [pc, #256]	; (401128 <freertos_usart_serial_read_packet+0x14c>)
  401026:	4798      	blx	r3
			RX_NOT_USED);

	/* Only do anything if the USART is valid. */
	if (usart_index < MAX_USARTS) {
  401028:	2c07      	cmp	r4, #7
  40102a:	dc5c      	bgt.n	4010e6 <freertos_usart_serial_read_packet+0x10a>
		/* Must not request more bytes than will fit in the buffer. */
		if (len <=
				(rx_buffer_definitions[usart_index].past_rx_buffer_end_address
  40102c:	493c      	ldr	r1, [pc, #240]	; (401120 <freertos_usart_serial_read_packet+0x144>)
  40102e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  401032:	009b      	lsls	r3, r3, #2
  401034:	18ca      	adds	r2, r1, r3
				- rx_buffer_definitions[usart_index].rx_buffer_start_address)) {
  401036:	6852      	ldr	r2, [r2, #4]
  401038:	58cb      	ldr	r3, [r1, r3]
  40103a:	1ad3      	subs	r3, r2, r3
			RX_NOT_USED);

	/* Only do anything if the USART is valid. */
	if (usart_index < MAX_USARTS) {
		/* Must not request more bytes than will fit in the buffer. */
		if (len <=
  40103c:	42b3      	cmp	r3, r6
  40103e:	d354      	bcc.n	4010ea <freertos_usart_serial_read_packet+0x10e>
				(rx_buffer_definitions[usart_index].past_rx_buffer_end_address
				- rx_buffer_definitions[usart_index].rx_buffer_start_address)) {
			/* Remember the time on entry. */
			vTaskSetTimeOutState(&time_out_definition);
  401040:	a802      	add	r0, sp, #8
  401042:	4b3a      	ldr	r3, [pc, #232]	; (40112c <freertos_usart_serial_read_packet+0x150>)
  401044:	4798      	blx	r3

			/* If an Rx mutex is in use, attempt to obtain it. */
			if (rx_buffer_definitions[usart_index].rx_access_mutex != NULL) {
  401046:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  40104a:	4a35      	ldr	r2, [pc, #212]	; (401120 <freertos_usart_serial_read_packet+0x144>)
  40104c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401050:	6958      	ldr	r0, [r3, #20]
  401052:	2800      	cmp	r0, #0
  401054:	d04d      	beq.n	4010f2 <freertos_usart_serial_read_packet+0x116>
				/* Attempt to obtain the mutex. */
				attempt_read = xSemaphoreTake(
  401056:	2100      	movs	r1, #0
  401058:	9a01      	ldr	r2, [sp, #4]
  40105a:	460b      	mov	r3, r1
  40105c:	4d34      	ldr	r5, [pc, #208]	; (401130 <freertos_usart_serial_read_packet+0x154>)
  40105e:	47a8      	blx	r5
						rx_buffer_definitions[usart_index].rx_access_mutex,
						block_time_ticks);

				if (attempt_read == pdTRUE) {
  401060:	2801      	cmp	r0, #1
  401062:	d144      	bne.n	4010ee <freertos_usart_serial_read_packet+0x112>
					/* The semaphore was obtained, adjust the block_time_ticks to take
					into account the time taken to obtain the semaphore. */
					if (xTaskCheckForTimeOut(&time_out_definition,
  401064:	a802      	add	r0, sp, #8
  401066:	a901      	add	r1, sp, #4
  401068:	4b32      	ldr	r3, [pc, #200]	; (401134 <freertos_usart_serial_read_packet+0x158>)
  40106a:	4798      	blx	r3
  40106c:	2801      	cmp	r0, #1
  40106e:	d140      	bne.n	4010f2 <freertos_usart_serial_read_packet+0x116>
							&block_time_ticks) == pdTRUE) {
						attempt_read = pdFALSE;

						/* The port is not going to be used, so return the
						mutex now. */
						xSemaphoreGive(rx_buffer_definitions[usart_index].rx_access_mutex);
  401070:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  401074:	4b2a      	ldr	r3, [pc, #168]	; (401120 <freertos_usart_serial_read_packet+0x144>)
  401076:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  40107a:	6958      	ldr	r0, [r3, #20]
  40107c:	2100      	movs	r1, #0
  40107e:	460a      	mov	r2, r1
  401080:	460b      	mov	r3, r1
  401082:	4c2d      	ldr	r4, [pc, #180]	; (401138 <freertos_usart_serial_read_packet+0x15c>)
  401084:	47a0      	blx	r4
  401086:	e032      	b.n	4010ee <freertos_usart_serial_read_packet+0x112>
			}

			if (attempt_read == pdTRUE) {
				do {
					/* Wait until data is available. */
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
  401088:	f8d8 0010 	ldr.w	r0, [r8, #16]
  40108c:	2100      	movs	r1, #0
  40108e:	9a01      	ldr	r2, [sp, #4]
  401090:	460b      	mov	r3, r1
  401092:	47d8      	blx	fp

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
							&(rx_buffer_definitions[usart_index]),
							all_usart_definitions[usart_index].pdc_base_address->PERIPH_RPR,
  401094:	f8d9 3004 	ldr.w	r3, [r9, #4]
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
							block_time_ticks);

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
  401098:	6819      	ldr	r1, [r3, #0]
  40109a:	4640      	mov	r0, r8
  40109c:	197a      	adds	r2, r7, r5
  40109e:	1b73      	subs	r3, r6, r5
  4010a0:	47d0      	blx	sl

					/* The Rx DMA will have stopped if the Rx buffer had become
					full before this read operation.  If bytes were removed by
					this read then there is guaranteed to be space in the Rx
					buffer and the Rx DMA can be restarted. */
					if (bytes_read > 0) {
  4010a2:	182d      	adds	r5, r5, r0
  4010a4:	d00a      	beq.n	4010bc <freertos_usart_serial_read_packet+0xe0>
						taskENTER_CRITICAL();
  4010a6:	4b25      	ldr	r3, [pc, #148]	; (40113c <freertos_usart_serial_read_packet+0x160>)
  4010a8:	4798      	blx	r3
						{
							if(rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size == 0UL) {
  4010aa:	f8d8 300c 	ldr.w	r3, [r8, #12]
  4010ae:	b91b      	cbnz	r3, 4010b8 <freertos_usart_serial_read_packet+0xdc>
								configure_rx_dma(usart_index, data_removed);
  4010b0:	4620      	mov	r0, r4
  4010b2:	2101      	movs	r1, #1
  4010b4:	4b22      	ldr	r3, [pc, #136]	; (401140 <freertos_usart_serial_read_packet+0x164>)
  4010b6:	4798      	blx	r3
							}
						}
						taskEXIT_CRITICAL();
  4010b8:	4b22      	ldr	r3, [pc, #136]	; (401144 <freertos_usart_serial_read_packet+0x168>)
  4010ba:	4798      	blx	r3

				  /* Until all the requested bytes are received, or the function
				  runs out of time. */
				} while ((bytes_read < len) && (xTaskCheckForTimeOut(
						&time_out_definition,
						&block_time_ticks) == pdFALSE));
  4010bc:	42ae      	cmp	r6, r5
  4010be:	d905      	bls.n	4010cc <freertos_usart_serial_read_packet+0xf0>
						taskEXIT_CRITICAL();
					}

				  /* Until all the requested bytes are received, or the function
				  runs out of time. */
				} while ((bytes_read < len) && (xTaskCheckForTimeOut(
  4010c0:	a802      	add	r0, sp, #8
  4010c2:	a901      	add	r1, sp, #4
  4010c4:	4b1b      	ldr	r3, [pc, #108]	; (401134 <freertos_usart_serial_read_packet+0x158>)
  4010c6:	4798      	blx	r3
  4010c8:	2800      	cmp	r0, #0
  4010ca:	d0dd      	beq.n	401088 <freertos_usart_serial_read_packet+0xac>
						&time_out_definition,
						&block_time_ticks) == pdFALSE));

				if (rx_buffer_definitions[usart_index].rx_access_mutex != NULL) {
  4010cc:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  4010d0:	4b13      	ldr	r3, [pc, #76]	; (401120 <freertos_usart_serial_read_packet+0x144>)
  4010d2:	eb03 0484 	add.w	r4, r3, r4, lsl #2
  4010d6:	6960      	ldr	r0, [r4, #20]
  4010d8:	b1c8      	cbz	r0, 40110e <freertos_usart_serial_read_packet+0x132>
					/* Return the mutex. */
					xSemaphoreGive(rx_buffer_definitions[usart_index].rx_access_mutex);
  4010da:	2100      	movs	r1, #0
  4010dc:	460a      	mov	r2, r1
  4010de:	460b      	mov	r3, r1
  4010e0:	4c15      	ldr	r4, [pc, #84]	; (401138 <freertos_usart_serial_read_packet+0x15c>)
  4010e2:	47a0      	blx	r4
  4010e4:	e013      	b.n	40110e <freertos_usart_serial_read_packet+0x132>
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
	portBASE_TYPE usart_index, attempt_read;
	Usart *usart_base;
	xTimeOutType time_out_definition;
	uint32_t bytes_read = 0;
  4010e6:	2500      	movs	r5, #0
  4010e8:	e011      	b.n	40110e <freertos_usart_serial_read_packet+0x132>
  4010ea:	2500      	movs	r5, #0
  4010ec:	e00f      	b.n	40110e <freertos_usart_serial_read_packet+0x132>
  4010ee:	2500      	movs	r5, #0
  4010f0:	e00d      	b.n	40110e <freertos_usart_serial_read_packet+0x132>
 * \return     The number of bytes that were copied into data.  This will be
 *     less than the requested number of bytes if a time out occurred.
 */
uint32_t freertos_usart_serial_read_packet(freertos_usart_if p_usart,
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
  4010f2:	2500      	movs	r5, #0
			}

			if (attempt_read == pdTRUE) {
				do {
					/* Wait until data is available. */
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
  4010f4:	ebc4 08c4 	rsb	r8, r4, r4, lsl #3
  4010f8:	4b09      	ldr	r3, [pc, #36]	; (401120 <freertos_usart_serial_read_packet+0x144>)
  4010fa:	eb03 0888 	add.w	r8, r3, r8, lsl #2
  4010fe:	f8df b030 	ldr.w	fp, [pc, #48]	; 401130 <freertos_usart_serial_read_packet+0x154>

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
							&(rx_buffer_definitions[usart_index]),
							all_usart_definitions[usart_index].pdc_base_address->PERIPH_RPR,
  401102:	4b05      	ldr	r3, [pc, #20]	; (401118 <freertos_usart_serial_read_packet+0x13c>)
  401104:	eb03 1904 	add.w	r9, r3, r4, lsl #4
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
							block_time_ticks);

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
  401108:	f8df a03c 	ldr.w	sl, [pc, #60]	; 401148 <freertos_usart_serial_read_packet+0x16c>
  40110c:	e7bc      	b.n	401088 <freertos_usart_serial_read_packet+0xac>
			}
		}
	}

	return bytes_read;
}
  40110e:	4628      	mov	r0, r5
  401110:	b005      	add	sp, #20
  401112:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401116:	bf00      	nop
  401118:	004096b4 	.word	0x004096b4
  40111c:	004007fd 	.word	0x004007fd
  401120:	20000980 	.word	0x20000980
  401124:	00409674 	.word	0x00409674
  401128:	00403de1 	.word	0x00403de1
  40112c:	00403439 	.word	0x00403439
  401130:	00402649 	.word	0x00402649
  401134:	00403469 	.word	0x00403469
  401138:	00402415 	.word	0x00402415
  40113c:	00401f65 	.word	0x00401f65
  401140:	00400b01 	.word	0x00400b01
  401144:	00401f85 	.word	0x00401f85
  401148:	00400981 	.word	0x00400981

0040114c <FLEXCOM0_Handler>:
 * handler calls the common interrupt handler.
 */
#if SAMG55
#ifdef CONF_FREERTOS_USE_USART0
void FLEXCOM0_Handler(void)
{
  40114c:	b508      	push	{r3, lr}
	local_usart_handler(0);
  40114e:	2000      	movs	r0, #0
  401150:	4b01      	ldr	r3, [pc, #4]	; (401158 <FLEXCOM0_Handler+0xc>)
  401152:	4798      	blx	r3
  401154:	bd08      	pop	{r3, pc}
  401156:	bf00      	nop
  401158:	00400bf1 	.word	0x00400bf1

0040115c <FLEXCOM7_Handler>:
	local_usart_handler(6);
}
#endif
#ifdef CONF_FREERTOS_USE_USART7
void FLEXCOM7_Handler(void)
{
  40115c:	b508      	push	{r3, lr}
	local_usart_handler(7);
  40115e:	2007      	movs	r0, #7
  401160:	4b01      	ldr	r3, [pc, #4]	; (401168 <FLEXCOM7_Handler+0xc>)
  401162:	4798      	blx	r3
  401164:	bd08      	pop	{r3, pc}
  401166:	bf00      	nop
  401168:	00400bf1 	.word	0x00400bf1

0040116c <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
  40116c:	b9a8      	cbnz	r0, 40119a <_read+0x2e>
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
  40116e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401172:	460c      	mov	r4, r1
  401174:	4690      	mov	r8, r2

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  401176:	2a00      	cmp	r2, #0
  401178:	dd0a      	ble.n	401190 <_read+0x24>
  40117a:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
  40117c:	4e08      	ldr	r6, [pc, #32]	; (4011a0 <_read+0x34>)
  40117e:	4d09      	ldr	r5, [pc, #36]	; (4011a4 <_read+0x38>)
  401180:	6830      	ldr	r0, [r6, #0]
  401182:	4621      	mov	r1, r4
  401184:	682b      	ldr	r3, [r5, #0]
  401186:	4798      	blx	r3
		ptr++;
  401188:	3401      	adds	r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  40118a:	42bc      	cmp	r4, r7
  40118c:	d1f8      	bne.n	401180 <_read+0x14>
  40118e:	e001      	b.n	401194 <_read+0x28>
  401190:	f04f 0800 	mov.w	r8, #0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
  401194:	4640      	mov	r0, r8
  401196:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
  40119a:	f04f 30ff 	mov.w	r0, #4294967295
  40119e:	4770      	bx	lr
  4011a0:	20004f18 	.word	0x20004f18
  4011a4:	20004f10 	.word	0x20004f10

004011a8 <_write>:
int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
  4011a8:	3801      	subs	r0, #1
  4011aa:	2802      	cmp	r0, #2
  4011ac:	d818      	bhi.n	4011e0 <_write+0x38>
int __attribute__((weak))
_write (int file, const char *ptr, int len);

int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
  4011ae:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4011b2:	460e      	mov	r6, r1
  4011b4:	4614      	mov	r4, r2

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
  4011b6:	b182      	cbz	r2, 4011da <_write+0x32>
  4011b8:	460d      	mov	r5, r1
		if (ptr_put(stdio_base, *ptr++) < 0) {
  4011ba:	f8df 8038 	ldr.w	r8, [pc, #56]	; 4011f4 <_write+0x4c>
  4011be:	4f0c      	ldr	r7, [pc, #48]	; (4011f0 <_write+0x48>)
  4011c0:	f8d8 0000 	ldr.w	r0, [r8]
  4011c4:	f815 1b01 	ldrb.w	r1, [r5], #1
  4011c8:	683b      	ldr	r3, [r7, #0]
  4011ca:	4798      	blx	r3
  4011cc:	2800      	cmp	r0, #0
  4011ce:	db0a      	blt.n	4011e6 <_write+0x3e>
  4011d0:	1ba8      	subs	r0, r5, r6

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
  4011d2:	3c01      	subs	r4, #1
  4011d4:	d1f4      	bne.n	4011c0 <_write+0x18>
  4011d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4011da:	2000      	movs	r0, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
	}
	return nChars;
  4011dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
_write (int file, const char *ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
  4011e0:	f04f 30ff 	mov.w	r0, #4294967295
			return -1;
		}
		++nChars;
	}
	return nChars;
}
  4011e4:	4770      	bx	lr
		return -1;
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
  4011e6:	f04f 30ff 	mov.w	r0, #4294967295
		}
		++nChars;
	}
	return nChars;
}
  4011ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4011ee:	bf00      	nop
  4011f0:	20004f14 	.word	0x20004f14
  4011f4:	20004f18 	.word	0x20004f18

004011f8 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
  4011f8:	b538      	push	{r3, r4, r5, lr}

#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	WDT->WDT_MR = WDT_MR_WDDIS;
  4011fa:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  4011fe:	4b33      	ldr	r3, [pc, #204]	; (4012cc <system_board_init+0xd4>)
  401200:	605c      	str	r4, [r3, #4]
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  401202:	200b      	movs	r0, #11
  401204:	4d32      	ldr	r5, [pc, #200]	; (4012d0 <system_board_init+0xd8>)
  401206:	47a8      	blx	r5
  401208:	200c      	movs	r0, #12
  40120a:	47a8      	blx	r5
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40120c:	4b31      	ldr	r3, [pc, #196]	; (4012d4 <system_board_init+0xdc>)
  40120e:	2240      	movs	r2, #64	; 0x40
  401210:	611a      	str	r2, [r3, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  401212:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401216:	631a      	str	r2, [r3, #48]	; 0x30
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  401218:	2204      	movs	r2, #4
  40121a:	615a      	str	r2, [r3, #20]
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40121c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		ioport_port_mask_t mask, ioport_mode_t mode)
{
	Pio *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->PIO_PUER = mask;
  401220:	665a      	str	r2, [r3, #100]	; 0x64

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->PIO_PPDER = mask;
	} else {
		base->PIO_PPDDR = mask;
  401222:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
		base->PIO_MDER = mask;
	} else {
		base->PIO_MDDR = mask;
  401226:	655a      	str	r2, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
		base->PIO_IFER = mask;
	} else {
		base->PIO_IFDR = mask;
  401228:	625a      	str	r2, [r3, #36]	; 0x24
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  40122a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->PIO_ABCDSR[0] |= mask;
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  40122e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401230:	f022 0204 	bic.w	r2, r2, #4
  401234:	671a      	str	r2, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->PIO_ABCDSR[1] |= mask;
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  401236:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401238:	f022 0204 	bic.w	r2, r2, #4
  40123c:	675a      	str	r2, [r3, #116]	; 0x74
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40123e:	2202      	movs	r2, #2
  401240:	631a      	str	r2, [r3, #48]	; 0x30
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  401242:	611a      	str	r2, [r3, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  401244:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401248:	4a23      	ldr	r2, [pc, #140]	; (4012d8 <system_board_init+0xe0>)
  40124a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  40124e:	6311      	str	r1, [r2, #48]	; 0x30
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  401250:	6111      	str	r1, [r2, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  401252:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401256:	6314      	str	r4, [r2, #48]	; 0x30
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  401258:	6114      	str	r4, [r2, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40125a:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	Pio *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->PIO_PUER = mask;
	} else {
		base->PIO_PUDR = mask;
  40125e:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  401262:	6619      	str	r1, [r3, #96]	; 0x60

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->PIO_PPDER = mask;
	} else {
		base->PIO_PPDDR = mask;
  401264:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
		base->PIO_MDER = mask;
	} else {
		base->PIO_MDDR = mask;
  401268:	6559      	str	r1, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
		base->PIO_IFER = mask;
	} else {
		base->PIO_IFDR = mask;
  40126a:	6259      	str	r1, [r3, #36]	; 0x24
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  40126c:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
	} else {
		base->PIO_ABSR &= ~mask;
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->PIO_ABCDSR[0] |= mask;
  401270:	6f18      	ldr	r0, [r3, #112]	; 0x70
  401272:	4308      	orrs	r0, r1
  401274:	6718      	str	r0, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->PIO_ABCDSR[1] |= mask;
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  401276:	6f58      	ldr	r0, [r3, #116]	; 0x74
  401278:	f020 50c0 	bic.w	r0, r0, #402653184	; 0x18000000
  40127c:	6758      	str	r0, [r3, #116]	; 0x74
}

__always_inline static void arch_ioport_disable_port(ioport_port_t port,
		ioport_port_mask_t mask)
{
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40127e:	6059      	str	r1, [r3, #4]
	Pio *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->PIO_PUER = mask;
	} else {
		base->PIO_PUDR = mask;
  401280:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401284:	6613      	str	r3, [r2, #96]	; 0x60

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->PIO_PPDER = mask;
	} else {
		base->PIO_PPDDR = mask;
  401286:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
		base->PIO_MDER = mask;
	} else {
		base->PIO_MDDR = mask;
  40128a:	6553      	str	r3, [r2, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
		base->PIO_IFER = mask;
	} else {
		base->PIO_IFDR = mask;
  40128c:	6253      	str	r3, [r2, #36]	; 0x24
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  40128e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->PIO_ABCDSR[0] |= mask;
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  401292:	6f11      	ldr	r1, [r2, #112]	; 0x70
  401294:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
  401298:	6711      	str	r1, [r2, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->PIO_ABCDSR[1] |= mask;
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  40129a:	6f51      	ldr	r1, [r2, #116]	; 0x74
  40129c:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
  4012a0:	6751      	str	r1, [r2, #116]	; 0x74
}

__always_inline static void arch_ioport_disable_port(ioport_port_t port,
		ioport_port_mask_t mask)
{
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  4012a2:	6053      	str	r3, [r2, #4]
	Pio *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->PIO_PUER = mask;
	} else {
		base->PIO_PUDR = mask;
  4012a4:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4012a8:	6613      	str	r3, [r2, #96]	; 0x60

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->PIO_PPDER = mask;
	} else {
		base->PIO_PPDDR = mask;
  4012aa:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
		base->PIO_MDER = mask;
	} else {
		base->PIO_MDDR = mask;
  4012ae:	6553      	str	r3, [r2, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
		base->PIO_IFER = mask;
	} else {
		base->PIO_IFDR = mask;
  4012b0:	6253      	str	r3, [r2, #36]	; 0x24
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  4012b2:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->PIO_ABCDSR[0] |= mask;
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  4012b6:	6f11      	ldr	r1, [r2, #112]	; 0x70
  4012b8:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
  4012bc:	6711      	str	r1, [r2, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->PIO_ABCDSR[1] |= mask;
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  4012be:	6f51      	ldr	r1, [r2, #116]	; 0x74
  4012c0:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
  4012c4:	6751      	str	r1, [r2, #116]	; 0x74
}

__always_inline static void arch_ioport_disable_port(ioport_port_t port,
		ioport_port_mask_t mask)
{
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  4012c6:	6053      	str	r3, [r2, #4]
  4012c8:	bd38      	pop	{r3, r4, r5, pc}
  4012ca:	bf00      	nop
  4012cc:	400e1450 	.word	0x400e1450
  4012d0:	00401571 	.word	0x00401571
  4012d4:	400e0e00 	.word	0x400e0e00
  4012d8:	400e1000 	.word	0x400e1000

004012dc <flexcom_enable>:
 *
 * \param p_flexcom  Pointer to a FLEXCOM instance.
 *
 */
void flexcom_enable(Flexcom *p_flexcom)
{
  4012dc:	b508      	push	{r3, lr}
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
  4012de:	4b50      	ldr	r3, [pc, #320]	; (401420 <flexcom_enable+0x144>)
  4012e0:	781b      	ldrb	r3, [r3, #0]
  4012e2:	2bff      	cmp	r3, #255	; 0xff
  4012e4:	d100      	bne.n	4012e8 <flexcom_enable+0xc>
  4012e6:	e7fe      	b.n	4012e6 <flexcom_enable+0xa>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4012e8:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  4012ec:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4012ee:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
  4012f2:	2100      	movs	r1, #0
  4012f4:	4a4b      	ldr	r2, [pc, #300]	; (401424 <flexcom_enable+0x148>)
  4012f6:	7011      	strb	r1, [r2, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
  4012f8:	4949      	ldr	r1, [pc, #292]	; (401420 <flexcom_enable+0x144>)
  4012fa:	780a      	ldrb	r2, [r1, #0]
  4012fc:	3201      	adds	r2, #1
  4012fe:	700a      	strb	r2, [r1, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
  401300:	b92b      	cbnz	r3, 40130e <flexcom_enable+0x32>
		cpu_irq_enable();
  401302:	2201      	movs	r2, #1
  401304:	4b47      	ldr	r3, [pc, #284]	; (401424 <flexcom_enable+0x148>)
  401306:	701a      	strb	r2, [r3, #0]
  401308:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  40130c:	b662      	cpsie	i
	sleepmgr_lock_mode(SLEEPMGR_ACTIVE);
	/* Enable PMC clock for FLEXCOM */
#ifdef ID_FLEXCOM7
	 if (p_flexcom == FLEXCOM7) {
  40130e:	4a46      	ldr	r2, [pc, #280]	; (401428 <flexcom_enable+0x14c>)
  401310:	4290      	cmp	r0, r2
  401312:	d10d      	bne.n	401330 <flexcom_enable+0x54>
  401314:	2007      	movs	r0, #7
  401316:	4b45      	ldr	r3, [pc, #276]	; (40142c <flexcom_enable+0x150>)
  401318:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM7);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  40131a:	2007      	movs	r0, #7
  40131c:	4b44      	ldr	r3, [pc, #272]	; (401430 <flexcom_enable+0x154>)
  40131e:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  401320:	2007      	movs	r0, #7
  401322:	2100      	movs	r1, #0
  401324:	4b43      	ldr	r3, [pc, #268]	; (401434 <flexcom_enable+0x158>)
  401326:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  401328:	2007      	movs	r0, #7
  40132a:	4b43      	ldr	r3, [pc, #268]	; (401438 <flexcom_enable+0x15c>)
  40132c:	4798      	blx	r3
  40132e:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM6
	if (p_flexcom == FLEXCOM6) {
  401330:	4a42      	ldr	r2, [pc, #264]	; (40143c <flexcom_enable+0x160>)
  401332:	4290      	cmp	r0, r2
  401334:	d10d      	bne.n	401352 <flexcom_enable+0x76>
  401336:	2016      	movs	r0, #22
  401338:	4b3c      	ldr	r3, [pc, #240]	; (40142c <flexcom_enable+0x150>)
  40133a:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM6);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  40133c:	2007      	movs	r0, #7
  40133e:	4b3c      	ldr	r3, [pc, #240]	; (401430 <flexcom_enable+0x154>)
  401340:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  401342:	2007      	movs	r0, #7
  401344:	2100      	movs	r1, #0
  401346:	4b3b      	ldr	r3, [pc, #236]	; (401434 <flexcom_enable+0x158>)
  401348:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  40134a:	2007      	movs	r0, #7
  40134c:	4b3a      	ldr	r3, [pc, #232]	; (401438 <flexcom_enable+0x15c>)
  40134e:	4798      	blx	r3
  401350:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM5
	if (p_flexcom == FLEXCOM5) {
  401352:	4a3b      	ldr	r2, [pc, #236]	; (401440 <flexcom_enable+0x164>)
  401354:	4290      	cmp	r0, r2
  401356:	d10d      	bne.n	401374 <flexcom_enable+0x98>
  401358:	2015      	movs	r0, #21
  40135a:	4b34      	ldr	r3, [pc, #208]	; (40142c <flexcom_enable+0x150>)
  40135c:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM5);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  40135e:	2007      	movs	r0, #7
  401360:	4b33      	ldr	r3, [pc, #204]	; (401430 <flexcom_enable+0x154>)
  401362:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  401364:	2007      	movs	r0, #7
  401366:	2100      	movs	r1, #0
  401368:	4b32      	ldr	r3, [pc, #200]	; (401434 <flexcom_enable+0x158>)
  40136a:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  40136c:	2007      	movs	r0, #7
  40136e:	4b32      	ldr	r3, [pc, #200]	; (401438 <flexcom_enable+0x15c>)
  401370:	4798      	blx	r3
  401372:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM4
	if (p_flexcom == FLEXCOM4) {
  401374:	4a33      	ldr	r2, [pc, #204]	; (401444 <flexcom_enable+0x168>)
  401376:	4290      	cmp	r0, r2
  401378:	d10d      	bne.n	401396 <flexcom_enable+0xba>
  40137a:	2014      	movs	r0, #20
  40137c:	4b2b      	ldr	r3, [pc, #172]	; (40142c <flexcom_enable+0x150>)
  40137e:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM4);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  401380:	2007      	movs	r0, #7
  401382:	4b2b      	ldr	r3, [pc, #172]	; (401430 <flexcom_enable+0x154>)
  401384:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  401386:	2007      	movs	r0, #7
  401388:	2100      	movs	r1, #0
  40138a:	4b2a      	ldr	r3, [pc, #168]	; (401434 <flexcom_enable+0x158>)
  40138c:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  40138e:	2007      	movs	r0, #7
  401390:	4b29      	ldr	r3, [pc, #164]	; (401438 <flexcom_enable+0x15c>)
  401392:	4798      	blx	r3
  401394:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM3
	if (p_flexcom == FLEXCOM3) {
  401396:	4a2c      	ldr	r2, [pc, #176]	; (401448 <flexcom_enable+0x16c>)
  401398:	4290      	cmp	r0, r2
  40139a:	d10d      	bne.n	4013b8 <flexcom_enable+0xdc>
  40139c:	2013      	movs	r0, #19
  40139e:	4b23      	ldr	r3, [pc, #140]	; (40142c <flexcom_enable+0x150>)
  4013a0:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM3);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_6);
  4013a2:	2006      	movs	r0, #6
  4013a4:	4b22      	ldr	r3, [pc, #136]	; (401430 <flexcom_enable+0x154>)
  4013a6:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4013a8:	2006      	movs	r0, #6
  4013aa:	2100      	movs	r1, #0
  4013ac:	4b21      	ldr	r3, [pc, #132]	; (401434 <flexcom_enable+0x158>)
  4013ae:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  4013b0:	2006      	movs	r0, #6
  4013b2:	4b21      	ldr	r3, [pc, #132]	; (401438 <flexcom_enable+0x15c>)
  4013b4:	4798      	blx	r3
  4013b6:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM2
	if (p_flexcom == FLEXCOM2) {
  4013b8:	4a24      	ldr	r2, [pc, #144]	; (40144c <flexcom_enable+0x170>)
  4013ba:	4290      	cmp	r0, r2
  4013bc:	d10d      	bne.n	4013da <flexcom_enable+0xfe>
  4013be:	200e      	movs	r0, #14
  4013c0:	4b1a      	ldr	r3, [pc, #104]	; (40142c <flexcom_enable+0x150>)
  4013c2:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM2);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_6);
  4013c4:	2006      	movs	r0, #6
  4013c6:	4b1a      	ldr	r3, [pc, #104]	; (401430 <flexcom_enable+0x154>)
  4013c8:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4013ca:	2006      	movs	r0, #6
  4013cc:	2100      	movs	r1, #0
  4013ce:	4b19      	ldr	r3, [pc, #100]	; (401434 <flexcom_enable+0x158>)
  4013d0:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  4013d2:	2006      	movs	r0, #6
  4013d4:	4b18      	ldr	r3, [pc, #96]	; (401438 <flexcom_enable+0x15c>)
  4013d6:	4798      	blx	r3
  4013d8:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM1
	if (p_flexcom == FLEXCOM1) {
  4013da:	4a1d      	ldr	r2, [pc, #116]	; (401450 <flexcom_enable+0x174>)
  4013dc:	4290      	cmp	r0, r2
  4013de:	d10d      	bne.n	4013fc <flexcom_enable+0x120>
  4013e0:	2009      	movs	r0, #9
  4013e2:	4b12      	ldr	r3, [pc, #72]	; (40142c <flexcom_enable+0x150>)
  4013e4:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM1);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_6);
  4013e6:	2006      	movs	r0, #6
  4013e8:	4b11      	ldr	r3, [pc, #68]	; (401430 <flexcom_enable+0x154>)
  4013ea:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4013ec:	2006      	movs	r0, #6
  4013ee:	2100      	movs	r1, #0
  4013f0:	4b10      	ldr	r3, [pc, #64]	; (401434 <flexcom_enable+0x158>)
  4013f2:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  4013f4:	2006      	movs	r0, #6
  4013f6:	4b10      	ldr	r3, [pc, #64]	; (401438 <flexcom_enable+0x15c>)
  4013f8:	4798      	blx	r3
  4013fa:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM0
	if (p_flexcom == FLEXCOM0) {
  4013fc:	4a15      	ldr	r2, [pc, #84]	; (401454 <flexcom_enable+0x178>)
  4013fe:	4290      	cmp	r0, r2
  401400:	d10c      	bne.n	40141c <flexcom_enable+0x140>
  401402:	2008      	movs	r0, #8
  401404:	4b09      	ldr	r3, [pc, #36]	; (40142c <flexcom_enable+0x150>)
  401406:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM0);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_6);
  401408:	2006      	movs	r0, #6
  40140a:	4b09      	ldr	r3, [pc, #36]	; (401430 <flexcom_enable+0x154>)
  40140c:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  40140e:	2006      	movs	r0, #6
  401410:	2100      	movs	r1, #0
  401412:	4b08      	ldr	r3, [pc, #32]	; (401434 <flexcom_enable+0x158>)
  401414:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  401416:	2006      	movs	r0, #6
  401418:	4b07      	ldr	r3, [pc, #28]	; (401438 <flexcom_enable+0x15c>)
  40141a:	4798      	blx	r3
  40141c:	bd08      	pop	{r3, pc}
  40141e:	bf00      	nop
  401420:	20004f08 	.word	0x20004f08
  401424:	20000000 	.word	0x20000000
  401428:	40034000 	.word	0x40034000
  40142c:	00401571 	.word	0x00401571
  401430:	00401619 	.word	0x00401619
  401434:	004015c5 	.word	0x004015c5
  401438:	00401609 	.word	0x00401609
  40143c:	40040000 	.word	0x40040000
  401440:	40008000 	.word	0x40008000
  401444:	4001c000 	.word	0x4001c000
  401448:	40018000 	.word	0x40018000
  40144c:	40024000 	.word	0x40024000
  401450:	40020000 	.word	0x40020000
  401454:	4000c000 	.word	0x4000c000

00401458 <flexcom_set_opmode>:
 * \param opmode  Opration mode.
 *
 */
void flexcom_set_opmode(Flexcom *p_flexcom, enum flexcom_opmode opmode)
{
	p_flexcom->FLEXCOM_MR = opmode;
  401458:	6001      	str	r1, [r0, #0]
  40145a:	4770      	bx	lr

0040145c <pdc_tx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
  40145c:	460b      	mov	r3, r1
  40145e:	b119      	cbz	r1, 401468 <pdc_tx_init+0xc>
		p_pdc->PERIPH_TPR = p_packet->ul_addr;
  401460:	6809      	ldr	r1, [r1, #0]
  401462:	6081      	str	r1, [r0, #8]
		p_pdc->PERIPH_TCR = p_packet->ul_size;
  401464:	685b      	ldr	r3, [r3, #4]
  401466:	60c3      	str	r3, [r0, #12]
	}
	if (p_next_packet) {
  401468:	b11a      	cbz	r2, 401472 <pdc_tx_init+0x16>
		p_pdc->PERIPH_TNPR = p_next_packet->ul_addr;
  40146a:	6813      	ldr	r3, [r2, #0]
  40146c:	6183      	str	r3, [r0, #24]
		p_pdc->PERIPH_TNCR = p_next_packet->ul_size;
  40146e:	6853      	ldr	r3, [r2, #4]
  401470:	61c3      	str	r3, [r0, #28]
  401472:	4770      	bx	lr

00401474 <pdc_rx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
  401474:	460b      	mov	r3, r1
  401476:	b119      	cbz	r1, 401480 <pdc_rx_init+0xc>
		p_pdc->PERIPH_RPR = p_packet->ul_addr;
  401478:	6809      	ldr	r1, [r1, #0]
  40147a:	6001      	str	r1, [r0, #0]
		p_pdc->PERIPH_RCR = p_packet->ul_size;
  40147c:	685b      	ldr	r3, [r3, #4]
  40147e:	6043      	str	r3, [r0, #4]
	}
	if (p_next_packet) {
  401480:	b11a      	cbz	r2, 40148a <pdc_rx_init+0x16>
		p_pdc->PERIPH_RNPR = p_next_packet->ul_addr;
  401482:	6813      	ldr	r3, [r2, #0]
  401484:	6103      	str	r3, [r0, #16]
		p_pdc->PERIPH_RNCR = p_next_packet->ul_size;
  401486:	6853      	ldr	r3, [r2, #4]
  401488:	6143      	str	r3, [r0, #20]
  40148a:	4770      	bx	lr

0040148c <pdc_enable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTEN | PERIPH_PTCR_TXTEN);
  40148c:	f021 01fe 	bic.w	r1, r1, #254	; 0xfe
  401490:	05c9      	lsls	r1, r1, #23
  401492:	0dc9      	lsrs	r1, r1, #23
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  401494:	6201      	str	r1, [r0, #32]
  401496:	4770      	bx	lr

00401498 <pdc_disable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
  401498:	f421 71fe 	bic.w	r1, r1, #508	; 0x1fc
  40149c:	f021 0101 	bic.w	r1, r1, #1
  4014a0:	0589      	lsls	r1, r1, #22
  4014a2:	0d89      	lsrs	r1, r1, #22
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  4014a4:	6201      	str	r1, [r0, #32]
  4014a6:	4770      	bx	lr

004014a8 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  4014a8:	4a18      	ldr	r2, [pc, #96]	; (40150c <pmc_switch_mck_to_pllack+0x64>)
  4014aa:	6b13      	ldr	r3, [r2, #48]	; 0x30
  4014ac:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  4014b0:	4318      	orrs	r0, r3
  4014b2:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4014b4:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4014b6:	f013 0f08 	tst.w	r3, #8
  4014ba:	d003      	beq.n	4014c4 <pmc_switch_mck_to_pllack+0x1c>
  4014bc:	e009      	b.n	4014d2 <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4014be:	3b01      	subs	r3, #1
  4014c0:	d103      	bne.n	4014ca <pmc_switch_mck_to_pllack+0x22>
  4014c2:	e01e      	b.n	401502 <pmc_switch_mck_to_pllack+0x5a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4014c4:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4014c8:	4910      	ldr	r1, [pc, #64]	; (40150c <pmc_switch_mck_to_pllack+0x64>)
  4014ca:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  4014cc:	f012 0f08 	tst.w	r2, #8
  4014d0:	d0f5      	beq.n	4014be <pmc_switch_mck_to_pllack+0x16>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  4014d2:	4a0e      	ldr	r2, [pc, #56]	; (40150c <pmc_switch_mck_to_pllack+0x64>)
  4014d4:	6b13      	ldr	r3, [r2, #48]	; 0x30
  4014d6:	f023 0303 	bic.w	r3, r3, #3
  4014da:	f043 0302 	orr.w	r3, r3, #2
  4014de:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4014e0:	6e90      	ldr	r0, [r2, #104]	; 0x68
  4014e2:	f010 0008 	ands.w	r0, r0, #8
  4014e6:	d004      	beq.n	4014f2 <pmc_switch_mck_to_pllack+0x4a>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  4014e8:	2000      	movs	r0, #0
  4014ea:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  4014ec:	3b01      	subs	r3, #1
  4014ee:	d103      	bne.n	4014f8 <pmc_switch_mck_to_pllack+0x50>
  4014f0:	e009      	b.n	401506 <pmc_switch_mck_to_pllack+0x5e>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4014f2:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4014f6:	4905      	ldr	r1, [pc, #20]	; (40150c <pmc_switch_mck_to_pllack+0x64>)
  4014f8:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  4014fa:	f012 0f08 	tst.w	r2, #8
  4014fe:	d0f5      	beq.n	4014ec <pmc_switch_mck_to_pllack+0x44>
  401500:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  401502:	2001      	movs	r0, #1
  401504:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  401506:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  401508:	4770      	bx	lr
  40150a:	bf00      	nop
  40150c:	400e0400 	.word	0x400e0400

00401510 <pmc_switch_sclk_to_32kxtal>:
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  401510:	2801      	cmp	r0, #1
  401512:	d106      	bne.n	401522 <pmc_switch_sclk_to_32kxtal+0x12>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  401514:	4a05      	ldr	r2, [pc, #20]	; (40152c <pmc_switch_sclk_to_32kxtal+0x1c>)
  401516:	6893      	ldr	r3, [r2, #8]
  401518:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  40151c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  401520:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  401522:	4a03      	ldr	r2, [pc, #12]	; (401530 <pmc_switch_sclk_to_32kxtal+0x20>)
  401524:	4b01      	ldr	r3, [pc, #4]	; (40152c <pmc_switch_sclk_to_32kxtal+0x1c>)
  401526:	601a      	str	r2, [r3, #0]
  401528:	4770      	bx	lr
  40152a:	bf00      	nop
  40152c:	400e1410 	.word	0x400e1410
  401530:	a5000008 	.word	0xa5000008

00401534 <pmc_osc_is_ready_32kxtal>:
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  401534:	4b05      	ldr	r3, [pc, #20]	; (40154c <pmc_osc_is_ready_32kxtal+0x18>)
  401536:	695b      	ldr	r3, [r3, #20]
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  401538:	f013 0f80 	tst.w	r3, #128	; 0x80
  40153c:	bf1d      	ittte	ne
  40153e:	4b04      	ldrne	r3, [pc, #16]	; (401550 <pmc_osc_is_ready_32kxtal+0x1c>)
  401540:	6e98      	ldrne	r0, [r3, #104]	; 0x68
  401542:	f3c0 10c0 	ubfxne	r0, r0, #7, #1
  401546:	2000      	moveq	r0, #0
}
  401548:	4770      	bx	lr
  40154a:	bf00      	nop
  40154c:	400e1410 	.word	0x400e1410
  401550:	400e0400 	.word	0x400e0400

00401554 <pmc_disable_pllack>:
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
  401554:	2200      	movs	r2, #0
  401556:	4b01      	ldr	r3, [pc, #4]	; (40155c <pmc_disable_pllack+0x8>)
  401558:	629a      	str	r2, [r3, #40]	; 0x28
  40155a:	4770      	bx	lr
  40155c:	400e0400 	.word	0x400e0400

00401560 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  401560:	4b02      	ldr	r3, [pc, #8]	; (40156c <pmc_is_locked_pllack+0xc>)
  401562:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  401564:	f000 0002 	and.w	r0, r0, #2
  401568:	4770      	bx	lr
  40156a:	bf00      	nop
  40156c:	400e0400 	.word	0x400e0400

00401570 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  401570:	2832      	cmp	r0, #50	; 0x32
  401572:	d81e      	bhi.n	4015b2 <pmc_enable_periph_clk+0x42>
		return 1;
	}

	if (ul_id < 32) {
  401574:	281f      	cmp	r0, #31
  401576:	d80c      	bhi.n	401592 <pmc_enable_periph_clk+0x22>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  401578:	4b11      	ldr	r3, [pc, #68]	; (4015c0 <pmc_enable_periph_clk+0x50>)
  40157a:	699a      	ldr	r2, [r3, #24]
  40157c:	2301      	movs	r3, #1
  40157e:	4083      	lsls	r3, r0
  401580:	401a      	ands	r2, r3
  401582:	4293      	cmp	r3, r2
  401584:	d017      	beq.n	4015b6 <pmc_enable_periph_clk+0x46>
			PMC->PMC_PCER0 = 1 << ul_id;
  401586:	2301      	movs	r3, #1
  401588:	4083      	lsls	r3, r0
  40158a:	4a0d      	ldr	r2, [pc, #52]	; (4015c0 <pmc_enable_periph_clk+0x50>)
  40158c:	6113      	str	r3, [r2, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  40158e:	2000      	movs	r0, #0
  401590:	4770      	bx	lr
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  401592:	4b0b      	ldr	r3, [pc, #44]	; (4015c0 <pmc_enable_periph_clk+0x50>)
  401594:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  401598:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40159a:	2301      	movs	r3, #1
  40159c:	4083      	lsls	r3, r0
  40159e:	401a      	ands	r2, r3
  4015a0:	4293      	cmp	r3, r2
  4015a2:	d00a      	beq.n	4015ba <pmc_enable_periph_clk+0x4a>
			PMC->PMC_PCER1 = 1 << ul_id;
  4015a4:	2301      	movs	r3, #1
  4015a6:	4083      	lsls	r3, r0
  4015a8:	4a05      	ldr	r2, [pc, #20]	; (4015c0 <pmc_enable_periph_clk+0x50>)
  4015aa:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  4015ae:	2000      	movs	r0, #0
  4015b0:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  4015b2:	2001      	movs	r0, #1
  4015b4:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  4015b6:	2000      	movs	r0, #0
  4015b8:	4770      	bx	lr
  4015ba:	2000      	movs	r0, #0
}
  4015bc:	4770      	bx	lr
  4015be:	bf00      	nop
  4015c0:	400e0400 	.word	0x400e0400

004015c4 <pmc_switch_pck_to_mck>:
 */
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
  4015c4:	f041 0104 	orr.w	r1, r1, #4
  4015c8:	4b0e      	ldr	r3, [pc, #56]	; (401604 <pmc_switch_pck_to_mck+0x40>)
  4015ca:	f100 0210 	add.w	r2, r0, #16
  4015ce:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	for (ul_timeout = PMC_TIMEOUT;
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
  4015d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4015d4:	f44f 7180 	mov.w	r1, #256	; 0x100
  4015d8:	4081      	lsls	r1, r0
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
	for (ul_timeout = PMC_TIMEOUT;
  4015da:	ea11 0003 	ands.w	r0, r1, r3
  4015de:	d004      	beq.n	4015ea <pmc_switch_pck_to_mck+0x26>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  4015e0:	2000      	movs	r0, #0
}
  4015e2:	4770      	bx	lr
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
	for (ul_timeout = PMC_TIMEOUT;
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
		if (ul_timeout == 0) {
  4015e4:	3b01      	subs	r3, #1
  4015e6:	d104      	bne.n	4015f2 <pmc_switch_pck_to_mck+0x2e>
  4015e8:	e007      	b.n	4015fa <pmc_switch_pck_to_mck+0x36>
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
  4015ea:	b410      	push	{r4}
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
	for (ul_timeout = PMC_TIMEOUT;
  4015ec:	f44f 6300 	mov.w	r3, #2048	; 0x800
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
  4015f0:	4c04      	ldr	r4, [pc, #16]	; (401604 <pmc_switch_pck_to_mck+0x40>)
  4015f2:	6ea2      	ldr	r2, [r4, #104]	; 0x68
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
	for (ul_timeout = PMC_TIMEOUT;
  4015f4:	4211      	tst	r1, r2
  4015f6:	d0f5      	beq.n	4015e4 <pmc_switch_pck_to_mck+0x20>
  4015f8:	e000      	b.n	4015fc <pmc_switch_pck_to_mck+0x38>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4015fa:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  4015fc:	f85d 4b04 	ldr.w	r4, [sp], #4
  401600:	4770      	bx	lr
  401602:	bf00      	nop
  401604:	400e0400 	.word	0x400e0400

00401608 <pmc_enable_pck>:
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_enable_pck(uint32_t ul_id)
{
	PMC->PMC_SCER = PMC_SCER_PCK0 << ul_id;
  401608:	f44f 7380 	mov.w	r3, #256	; 0x100
  40160c:	4083      	lsls	r3, r0
  40160e:	4a01      	ldr	r2, [pc, #4]	; (401614 <pmc_enable_pck+0xc>)
  401610:	6013      	str	r3, [r2, #0]
  401612:	4770      	bx	lr
  401614:	400e0400 	.word	0x400e0400

00401618 <pmc_disable_pck>:
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_disable_pck(uint32_t ul_id)
{
	PMC->PMC_SCDR = PMC_SCER_PCK0 << ul_id;
  401618:	f44f 7380 	mov.w	r3, #256	; 0x100
  40161c:	4083      	lsls	r3, r0
  40161e:	4a01      	ldr	r2, [pc, #4]	; (401624 <pmc_disable_pck+0xc>)
  401620:	6053      	str	r3, [r2, #4]
  401622:	4770      	bx	lr
  401624:	400e0400 	.word	0x400e0400

00401628 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
  401628:	b410      	push	{r4}
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  40162a:	010b      	lsls	r3, r1, #4
  40162c:	4293      	cmp	r3, r2
  40162e:	d90f      	bls.n	401650 <usart_set_async_baudrate+0x28>
  401630:	e01c      	b.n	40166c <usart_set_async_baudrate+0x44>
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
  401632:	f002 0207 	and.w	r2, r2, #7
		return 1;
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
		p_usart->US_MR |= US_MR_OVER;
  401636:	6841      	ldr	r1, [r0, #4]
  401638:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
  40163c:	6041      	str	r1, [r0, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  40163e:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  401642:	6202      	str	r2, [r0, #32]

	return 0;
  401644:	2000      	movs	r0, #0
  401646:	e01e      	b.n	401686 <usart_set_async_baudrate+0x5e>
	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
		return 1;
  401648:	2001      	movs	r0, #1
  40164a:	e01c      	b.n	401686 <usart_set_async_baudrate+0x5e>
  40164c:	2001      	movs	r0, #1
  40164e:	e01a      	b.n	401686 <usart_set_async_baudrate+0x5e>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  401650:	00d2      	lsls	r2, r2, #3
  401652:	eb02 0253 	add.w	r2, r2, r3, lsr #1
  401656:	fbb2 f2f3 	udiv	r2, r2, r3
	cd = cd_fp >> 3;
  40165a:	08d3      	lsrs	r3, r2, #3
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  40165c:	1e5c      	subs	r4, r3, #1
  40165e:	f64f 71fe 	movw	r1, #65534	; 0xfffe
  401662:	428c      	cmp	r4, r1
  401664:	d8f0      	bhi.n	401648 <usart_set_async_baudrate+0x20>
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
  401666:	f002 0207 	and.w	r2, r2, #7
  40166a:	e7e8      	b.n	40163e <usart_set_async_baudrate+0x16>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  40166c:	00c9      	lsls	r1, r1, #3
  40166e:	00d2      	lsls	r2, r2, #3
  401670:	eb02 0251 	add.w	r2, r2, r1, lsr #1
  401674:	fbb2 f2f1 	udiv	r2, r2, r1
	cd = cd_fp >> 3;
  401678:	08d3      	lsrs	r3, r2, #3
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  40167a:	1e5c      	subs	r4, r3, #1
  40167c:	f64f 71fe 	movw	r1, #65534	; 0xfffe
  401680:	428c      	cmp	r4, r1
  401682:	d9d6      	bls.n	401632 <usart_set_async_baudrate+0xa>
  401684:	e7e2      	b.n	40164c <usart_set_async_baudrate+0x24>

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);

	return 0;
}
  401686:	f85d 4b04 	ldr.w	r4, [sp], #4
  40168a:	4770      	bx	lr

0040168c <usart_reset>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  40168c:	4b08      	ldr	r3, [pc, #32]	; (4016b0 <usart_reset+0x24>)
  40168e:	f8c0 30e4 	str.w	r3, [r0, #228]	; 0xe4
{
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  401692:	2300      	movs	r3, #0
  401694:	6043      	str	r3, [r0, #4]
	p_usart->US_RTOR = 0;
  401696:	6243      	str	r3, [r0, #36]	; 0x24
	p_usart->US_TTGR = 0;
  401698:	6283      	str	r3, [r0, #40]	; 0x28
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  40169a:	2388      	movs	r3, #136	; 0x88
  40169c:	6003      	str	r3, [r0, #0]
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  40169e:	2324      	movs	r3, #36	; 0x24
  4016a0:	6003      	str	r3, [r0, #0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RSTSTA;
  4016a2:	f44f 7380 	mov.w	r3, #256	; 0x100
  4016a6:	6003      	str	r3, [r0, #0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RTSDIS;
  4016a8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  4016ac:	6003      	str	r3, [r0, #0]
  4016ae:	4770      	bx	lr
  4016b0:	55534100 	.word	0x55534100

004016b4 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  4016b4:	b570      	push	{r4, r5, r6, lr}
  4016b6:	4605      	mov	r5, r0
  4016b8:	460c      	mov	r4, r1
  4016ba:	4616      	mov	r6, r2
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
  4016bc:	4b0f      	ldr	r3, [pc, #60]	; (4016fc <usart_init_rs232+0x48>)
  4016be:	4798      	blx	r3

	ul_reg_val = 0;
  4016c0:	2200      	movs	r2, #0
  4016c2:	4b0f      	ldr	r3, [pc, #60]	; (401700 <usart_init_rs232+0x4c>)
  4016c4:	601a      	str	r2, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  4016c6:	b19c      	cbz	r4, 4016f0 <usart_init_rs232+0x3c>
  4016c8:	4628      	mov	r0, r5
  4016ca:	6821      	ldr	r1, [r4, #0]
  4016cc:	4632      	mov	r2, r6
  4016ce:	4b0d      	ldr	r3, [pc, #52]	; (401704 <usart_init_rs232+0x50>)
  4016d0:	4798      	blx	r3
  4016d2:	4602      	mov	r2, r0
  4016d4:	b970      	cbnz	r0, 4016f4 <usart_init_rs232+0x40>
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4016d6:	68a1      	ldr	r1, [r4, #8]
  4016d8:	6863      	ldr	r3, [r4, #4]
  4016da:	4319      	orrs	r1, r3
  4016dc:	6923      	ldr	r3, [r4, #16]
  4016de:	4319      	orrs	r1, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  4016e0:	68e3      	ldr	r3, [r4, #12]
  4016e2:	430b      	orrs	r3, r1
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4016e4:	4906      	ldr	r1, [pc, #24]	; (401700 <usart_init_rs232+0x4c>)
  4016e6:	600b      	str	r3, [r1, #0]
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;
  4016e8:	6869      	ldr	r1, [r5, #4]
  4016ea:	430b      	orrs	r3, r1
  4016ec:	606b      	str	r3, [r5, #4]

	return 0;
  4016ee:	e002      	b.n	4016f6 <usart_init_rs232+0x42>

	ul_reg_val = 0;
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
  4016f0:	2201      	movs	r2, #1
  4016f2:	e000      	b.n	4016f6 <usart_init_rs232+0x42>
  4016f4:	2201      	movs	r2, #1
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;

	return 0;
}
  4016f6:	4610      	mov	r0, r2
  4016f8:	bd70      	pop	{r4, r5, r6, pc}
  4016fa:	bf00      	nop
  4016fc:	0040168d 	.word	0x0040168d
  401700:	20000aa0 	.word	0x20000aa0
  401704:	00401629 	.word	0x00401629

00401708 <usart_enable_tx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_TXEN;
  401708:	2340      	movs	r3, #64	; 0x40
  40170a:	6003      	str	r3, [r0, #0]
  40170c:	4770      	bx	lr
  40170e:	bf00      	nop

00401710 <usart_disable_tx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_tx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_TXDIS;
  401710:	2380      	movs	r3, #128	; 0x80
  401712:	6003      	str	r3, [r0, #0]
  401714:	4770      	bx	lr
  401716:	bf00      	nop

00401718 <usart_enable_rx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RXEN;
  401718:	2310      	movs	r3, #16
  40171a:	6003      	str	r3, [r0, #0]
  40171c:	4770      	bx	lr
  40171e:	bf00      	nop

00401720 <usart_disable_rx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_rx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RXDIS;
  401720:	2320      	movs	r3, #32
  401722:	6003      	str	r3, [r0, #0]
  401724:	4770      	bx	lr
  401726:	bf00      	nop

00401728 <usart_set_rx_timeout>:
 * \param p_usart Pointer to a USART instance.
 * \param timeout The value of receive timeout.
 */
void usart_set_rx_timeout(Usart *p_usart, uint32_t timeout)
{
	p_usart->US_RTOR = timeout;
  401728:	6241      	str	r1, [r0, #36]	; 0x24
  40172a:	4770      	bx	lr

0040172c <usart_enable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IER = ul_sources;
  40172c:	6081      	str	r1, [r0, #8]
  40172e:	4770      	bx	lr

00401730 <usart_disable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IDR = ul_sources;
  401730:	60c1      	str	r1, [r0, #12]
  401732:	4770      	bx	lr

00401734 <usart_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t usart_get_interrupt_mask(Usart *p_usart)
{
	return p_usart->US_IMR;
  401734:	6900      	ldr	r0, [r0, #16]
}
  401736:	4770      	bx	lr

00401738 <usart_get_status>:
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
	return p_usart->US_CSR;
  401738:	6940      	ldr	r0, [r0, #20]
}
  40173a:	4770      	bx	lr

0040173c <usart_reset_status>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RSTSTA;
  40173c:	f44f 7380 	mov.w	r3, #256	; 0x100
  401740:	6003      	str	r3, [r0, #0]
  401742:	4770      	bx	lr

00401744 <usart_start_rx_timeout>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_start_rx_timeout(Usart *p_usart)
{
	p_usart->US_CR = US_CR_STTTO;
  401744:	f44f 6300 	mov.w	r3, #2048	; 0x800
  401748:	6003      	str	r3, [r0, #0]
  40174a:	4770      	bx	lr

0040174c <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
        while (1) {
        }
  40174c:	e7fe      	b.n	40174c <Dummy_Handler>
  40174e:	bf00      	nop

00401750 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  401750:	b508      	push	{r3, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
  401752:	4b2a      	ldr	r3, [pc, #168]	; (4017fc <Reset_Handler+0xac>)
  401754:	4a2a      	ldr	r2, [pc, #168]	; (401800 <Reset_Handler+0xb0>)
  401756:	429a      	cmp	r2, r3
  401758:	d003      	beq.n	401762 <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
  40175a:	4b2a      	ldr	r3, [pc, #168]	; (401804 <Reset_Handler+0xb4>)
  40175c:	4a27      	ldr	r2, [pc, #156]	; (4017fc <Reset_Handler+0xac>)
  40175e:	429a      	cmp	r2, r3
  401760:	d304      	bcc.n	40176c <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  401762:	4b29      	ldr	r3, [pc, #164]	; (401808 <Reset_Handler+0xb8>)
  401764:	4a29      	ldr	r2, [pc, #164]	; (40180c <Reset_Handler+0xbc>)
  401766:	429a      	cmp	r2, r3
  401768:	d310      	bcc.n	40178c <Reset_Handler+0x3c>
  40176a:	e01b      	b.n	4017a4 <Reset_Handler+0x54>
  40176c:	4923      	ldr	r1, [pc, #140]	; (4017fc <Reset_Handler+0xac>)
  40176e:	1d0a      	adds	r2, r1, #4
  401770:	4b27      	ldr	r3, [pc, #156]	; (401810 <Reset_Handler+0xc0>)
  401772:	1a9b      	subs	r3, r3, r2
  401774:	f023 0303 	bic.w	r3, r3, #3
  401778:	3304      	adds	r3, #4
  40177a:	4a21      	ldr	r2, [pc, #132]	; (401800 <Reset_Handler+0xb0>)
  40177c:	4413      	add	r3, r2
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
                        *pDest++ = *pSrc++;
  40177e:	f852 0b04 	ldr.w	r0, [r2], #4
  401782:	f841 0b04 	str.w	r0, [r1], #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
  401786:	429a      	cmp	r2, r3
  401788:	d1f9      	bne.n	40177e <Reset_Handler+0x2e>
  40178a:	e7ea      	b.n	401762 <Reset_Handler+0x12>
  40178c:	4b21      	ldr	r3, [pc, #132]	; (401814 <Reset_Handler+0xc4>)
  40178e:	4a22      	ldr	r2, [pc, #136]	; (401818 <Reset_Handler+0xc8>)
  401790:	1ad2      	subs	r2, r2, r3
  401792:	f022 0203 	bic.w	r2, r2, #3
  401796:	441a      	add	r2, r3
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  401798:	3b04      	subs	r3, #4
                *pDest++ = 0;
  40179a:	2100      	movs	r1, #0
  40179c:	f843 1b04 	str.w	r1, [r3], #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  4017a0:	4293      	cmp	r3, r2
  4017a2:	d1fb      	bne.n	40179c <Reset_Handler+0x4c>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  4017a4:	4b1d      	ldr	r3, [pc, #116]	; (40181c <Reset_Handler+0xcc>)
  4017a6:	f023 017f 	bic.w	r1, r3, #127	; 0x7f
  4017aa:	4a1d      	ldr	r2, [pc, #116]	; (401820 <Reset_Handler+0xd0>)
  4017ac:	6091      	str	r1, [r2, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4017ae:	f3ef 8210 	mrs	r2, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  4017b2:	b672      	cpsid	i
  4017b4:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
  4017b8:	2000      	movs	r0, #0
  4017ba:	491a      	ldr	r1, [pc, #104]	; (401824 <Reset_Handler+0xd4>)
  4017bc:	7008      	strb	r0, [r1, #0]
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
	REG_CPACR |=  (0xFu << 20);
  4017be:	481a      	ldr	r0, [pc, #104]	; (401828 <Reset_Handler+0xd8>)
  4017c0:	6801      	ldr	r1, [r0, #0]
  4017c2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  4017c6:	6001      	str	r1, [r0, #0]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  4017c8:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb");
  4017cc:	f3bf 8f6f 	isb	sy
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
  4017d0:	b92a      	cbnz	r2, 4017de <Reset_Handler+0x8e>
		cpu_irq_enable();
  4017d2:	2101      	movs	r1, #1
  4017d4:	4a13      	ldr	r2, [pc, #76]	; (401824 <Reset_Handler+0xd4>)
  4017d6:	7011      	strb	r1, [r2, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4017d8:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  4017dc:	b662      	cpsie	i

#if __FPU_USED
	fpu_enable();
#endif

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  4017de:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
  4017e2:	f5b3 3f20 	cmp.w	r3, #163840	; 0x28000
  4017e6:	d204      	bcs.n	4017f2 <Reset_Handler+0xa2>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  4017e8:	4a0d      	ldr	r2, [pc, #52]	; (401820 <Reset_Handler+0xd0>)
  4017ea:	6893      	ldr	r3, [r2, #8]
  4017ec:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  4017f0:	6093      	str	r3, [r2, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4017f2:	4b0e      	ldr	r3, [pc, #56]	; (40182c <Reset_Handler+0xdc>)
  4017f4:	4798      	blx	r3

        /* Branch to main function */
        main();
  4017f6:	4b0e      	ldr	r3, [pc, #56]	; (401830 <Reset_Handler+0xe0>)
  4017f8:	4798      	blx	r3

        /* Infinite loop */
        while (1);
  4017fa:	e7fe      	b.n	4017fa <Reset_Handler+0xaa>
  4017fc:	20000000 	.word	0x20000000
  401800:	0040a264 	.word	0x0040a264
  401804:	20000898 	.word	0x20000898
  401808:	20004f20 	.word	0x20004f20
  40180c:	20000898 	.word	0x20000898
  401810:	2000089b 	.word	0x2000089b
  401814:	2000089c 	.word	0x2000089c
  401818:	20004f23 	.word	0x20004f23
  40181c:	00400000 	.word	0x00400000
  401820:	e000ed00 	.word	0xe000ed00
  401824:	20000000 	.word	0x20000000
  401828:	e000ed88 	.word	0xe000ed88
  40182c:	00403fed 	.word	0x00403fed
  401830:	00403e09 	.word	0x00403e09

00401834 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate(void)
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  401834:	4b31      	ldr	r3, [pc, #196]	; (4018fc <SystemCoreClockUpdate+0xc8>)
  401836:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401838:	f003 0303 	and.w	r3, r3, #3
  40183c:	2b01      	cmp	r3, #1
  40183e:	d00f      	beq.n	401860 <SystemCoreClockUpdate+0x2c>
  401840:	b113      	cbz	r3, 401848 <SystemCoreClockUpdate+0x14>
  401842:	2b02      	cmp	r3, #2
  401844:	d029      	beq.n	40189a <SystemCoreClockUpdate+0x66>
  401846:	e042      	b.n	4018ce <SystemCoreClockUpdate+0x9a>
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  401848:	4b2d      	ldr	r3, [pc, #180]	; (401900 <SystemCoreClockUpdate+0xcc>)
  40184a:	695b      	ldr	r3, [r3, #20]
  40184c:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  401850:	bf14      	ite	ne
  401852:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  401856:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  40185a:	4b2a      	ldr	r3, [pc, #168]	; (401904 <SystemCoreClockUpdate+0xd0>)
  40185c:	601a      	str	r2, [r3, #0]
  40185e:	e036      	b.n	4018ce <SystemCoreClockUpdate+0x9a>
		}
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  401860:	4b26      	ldr	r3, [pc, #152]	; (4018fc <SystemCoreClockUpdate+0xc8>)
  401862:	6a1b      	ldr	r3, [r3, #32]
  401864:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  401868:	d003      	beq.n	401872 <SystemCoreClockUpdate+0x3e>
			SystemCoreClock = CHIP_FREQ_XTAL;
  40186a:	4a27      	ldr	r2, [pc, #156]	; (401908 <SystemCoreClockUpdate+0xd4>)
  40186c:	4b25      	ldr	r3, [pc, #148]	; (401904 <SystemCoreClockUpdate+0xd0>)
  40186e:	601a      	str	r2, [r3, #0]
  401870:	e02d      	b.n	4018ce <SystemCoreClockUpdate+0x9a>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  401872:	4a26      	ldr	r2, [pc, #152]	; (40190c <SystemCoreClockUpdate+0xd8>)
  401874:	4b23      	ldr	r3, [pc, #140]	; (401904 <SystemCoreClockUpdate+0xd0>)
  401876:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  401878:	4b20      	ldr	r3, [pc, #128]	; (4018fc <SystemCoreClockUpdate+0xc8>)
  40187a:	6a1b      	ldr	r3, [r3, #32]
  40187c:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401880:	2b10      	cmp	r3, #16
  401882:	d002      	beq.n	40188a <SystemCoreClockUpdate+0x56>
  401884:	2b20      	cmp	r3, #32
  401886:	d004      	beq.n	401892 <SystemCoreClockUpdate+0x5e>
  401888:	e021      	b.n	4018ce <SystemCoreClockUpdate+0x9a>
			case CKGR_MOR_MOSCRCF_8_MHz:
				break;
			case CKGR_MOR_MOSCRCF_16_MHz:
				SystemCoreClock *= 2U;
  40188a:	4a21      	ldr	r2, [pc, #132]	; (401910 <SystemCoreClockUpdate+0xdc>)
  40188c:	4b1d      	ldr	r3, [pc, #116]	; (401904 <SystemCoreClockUpdate+0xd0>)
  40188e:	601a      	str	r2, [r3, #0]
				break;
  401890:	e01d      	b.n	4018ce <SystemCoreClockUpdate+0x9a>
			case CKGR_MOR_MOSCRCF_24_MHz:
				SystemCoreClock *= 3U;
  401892:	4a20      	ldr	r2, [pc, #128]	; (401914 <SystemCoreClockUpdate+0xe0>)
  401894:	4b1b      	ldr	r3, [pc, #108]	; (401904 <SystemCoreClockUpdate+0xd0>)
  401896:	601a      	str	r2, [r3, #0]
				break;
  401898:	e019      	b.n	4018ce <SystemCoreClockUpdate+0x9a>
				break;
			}
		}
		break;
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  40189a:	4b19      	ldr	r3, [pc, #100]	; (401900 <SystemCoreClockUpdate+0xcc>)
  40189c:	695b      	ldr	r3, [r3, #20]
  40189e:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  4018a2:	bf14      	ite	ne
  4018a4:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  4018a8:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  4018ac:	4b15      	ldr	r3, [pc, #84]	; (401904 <SystemCoreClockUpdate+0xd0>)
  4018ae:	601a      	str	r2, [r3, #0]
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  4018b0:	4b12      	ldr	r3, [pc, #72]	; (4018fc <SystemCoreClockUpdate+0xc8>)
  4018b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4018b4:	f003 0303 	and.w	r3, r3, #3
  4018b8:	2b02      	cmp	r3, #2
  4018ba:	d108      	bne.n	4018ce <SystemCoreClockUpdate+0x9a>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  4018bc:	4b0f      	ldr	r3, [pc, #60]	; (4018fc <SystemCoreClockUpdate+0xc8>)
  4018be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  4018c0:	4910      	ldr	r1, [pc, #64]	; (401904 <SystemCoreClockUpdate+0xd0>)
  4018c2:	f3c3 420c 	ubfx	r2, r3, #16, #13
  4018c6:	680b      	ldr	r3, [r1, #0]
  4018c8:	fb02 3303 	mla	r3, r2, r3, r3
  4018cc:	600b      	str	r3, [r1, #0]
		break;
	default:
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  4018ce:	4b0b      	ldr	r3, [pc, #44]	; (4018fc <SystemCoreClockUpdate+0xc8>)
  4018d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4018d2:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4018d6:	2b70      	cmp	r3, #112	; 0x70
  4018d8:	d107      	bne.n	4018ea <SystemCoreClockUpdate+0xb6>
		SystemCoreClock /= 3U;
  4018da:	4a0a      	ldr	r2, [pc, #40]	; (401904 <SystemCoreClockUpdate+0xd0>)
  4018dc:	6813      	ldr	r3, [r2, #0]
  4018de:	490e      	ldr	r1, [pc, #56]	; (401918 <SystemCoreClockUpdate+0xe4>)
  4018e0:	fba1 1303 	umull	r1, r3, r1, r3
  4018e4:	085b      	lsrs	r3, r3, #1
  4018e6:	6013      	str	r3, [r2, #0]
  4018e8:	4770      	bx	lr
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4018ea:	4b04      	ldr	r3, [pc, #16]	; (4018fc <SystemCoreClockUpdate+0xc8>)
  4018ec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  4018ee:	4905      	ldr	r1, [pc, #20]	; (401904 <SystemCoreClockUpdate+0xd0>)
  4018f0:	f3c2 1202 	ubfx	r2, r2, #4, #3
  4018f4:	680b      	ldr	r3, [r1, #0]
  4018f6:	40d3      	lsrs	r3, r2
  4018f8:	600b      	str	r3, [r1, #0]
  4018fa:	4770      	bx	lr
  4018fc:	400e0400 	.word	0x400e0400
  401900:	400e1410 	.word	0x400e1410
  401904:	20000004 	.word	0x20000004
  401908:	00b71b00 	.word	0x00b71b00
  40190c:	007a1200 	.word	0x007a1200
  401910:	00f42400 	.word	0x00f42400
  401914:	016e3600 	.word	0x016e3600
  401918:	aaaaaaab 	.word	0xaaaaaaab

0040191c <system_init_flash>:
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  40191c:	4b12      	ldr	r3, [pc, #72]	; (401968 <system_init_flash+0x4c>)
  40191e:	4298      	cmp	r0, r3
  401920:	d804      	bhi.n	40192c <system_init_flash+0x10>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  401922:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  401926:	4b11      	ldr	r3, [pc, #68]	; (40196c <system_init_flash+0x50>)
  401928:	601a      	str	r2, [r3, #0]
  40192a:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  40192c:	4b10      	ldr	r3, [pc, #64]	; (401970 <system_init_flash+0x54>)
  40192e:	4298      	cmp	r0, r3
  401930:	d803      	bhi.n	40193a <system_init_flash+0x1e>
		EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  401932:	4a10      	ldr	r2, [pc, #64]	; (401974 <system_init_flash+0x58>)
  401934:	4b0d      	ldr	r3, [pc, #52]	; (40196c <system_init_flash+0x50>)
  401936:	601a      	str	r2, [r3, #0]
  401938:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  40193a:	4b0f      	ldr	r3, [pc, #60]	; (401978 <system_init_flash+0x5c>)
  40193c:	4298      	cmp	r0, r3
  40193e:	d803      	bhi.n	401948 <system_init_flash+0x2c>
		EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  401940:	4a0e      	ldr	r2, [pc, #56]	; (40197c <system_init_flash+0x60>)
  401942:	4b0a      	ldr	r3, [pc, #40]	; (40196c <system_init_flash+0x50>)
  401944:	601a      	str	r2, [r3, #0]
  401946:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  401948:	4b0d      	ldr	r3, [pc, #52]	; (401980 <system_init_flash+0x64>)
  40194a:	4298      	cmp	r0, r3
  40194c:	d803      	bhi.n	401956 <system_init_flash+0x3a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  40194e:	4a0d      	ldr	r2, [pc, #52]	; (401984 <system_init_flash+0x68>)
  401950:	4b06      	ldr	r3, [pc, #24]	; (40196c <system_init_flash+0x50>)
  401952:	601a      	str	r2, [r3, #0]
  401954:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
  401956:	4b0c      	ldr	r3, [pc, #48]	; (401988 <system_init_flash+0x6c>)
  401958:	4298      	cmp	r0, r3
		EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  40195a:	bf94      	ite	ls
  40195c:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
	} else {
		EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  401960:	4a0a      	ldrhi	r2, [pc, #40]	; (40198c <system_init_flash+0x70>)
  401962:	4b02      	ldr	r3, [pc, #8]	; (40196c <system_init_flash+0x50>)
  401964:	601a      	str	r2, [r3, #0]
  401966:	4770      	bx	lr
  401968:	01312cff 	.word	0x01312cff
  40196c:	400e0a00 	.word	0x400e0a00
  401970:	026259ff 	.word	0x026259ff
  401974:	04000100 	.word	0x04000100
  401978:	039386ff 	.word	0x039386ff
  40197c:	04000200 	.word	0x04000200
  401980:	04c4b3ff 	.word	0x04c4b3ff
  401984:	04000300 	.word	0x04000300
  401988:	05f5e0ff 	.word	0x05f5e0ff
  40198c:	04000500 	.word	0x04000500

00401990 <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  401990:	4b09      	ldr	r3, [pc, #36]	; (4019b8 <_sbrk+0x28>)
  401992:	681b      	ldr	r3, [r3, #0]
  401994:	b913      	cbnz	r3, 40199c <_sbrk+0xc>
		heap = (unsigned char *)&_end;
  401996:	4a09      	ldr	r2, [pc, #36]	; (4019bc <_sbrk+0x2c>)
  401998:	4b07      	ldr	r3, [pc, #28]	; (4019b8 <_sbrk+0x28>)
  40199a:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  40199c:	4b06      	ldr	r3, [pc, #24]	; (4019b8 <_sbrk+0x28>)
  40199e:	681b      	ldr	r3, [r3, #0]

	if (((int)prev_heap + incr) > ramend) {
  4019a0:	181a      	adds	r2, r3, r0
  4019a2:	4907      	ldr	r1, [pc, #28]	; (4019c0 <_sbrk+0x30>)
  4019a4:	4291      	cmp	r1, r2
  4019a6:	db04      	blt.n	4019b2 <_sbrk+0x22>
		return (caddr_t) -1;	
	}

	heap += incr;
  4019a8:	4610      	mov	r0, r2
  4019aa:	4a03      	ldr	r2, [pc, #12]	; (4019b8 <_sbrk+0x28>)
  4019ac:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap;
  4019ae:	4618      	mov	r0, r3
  4019b0:	4770      	bx	lr
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  4019b2:	f04f 30ff 	mov.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  4019b6:	4770      	bx	lr
  4019b8:	20000aa4 	.word	0x20000aa4
  4019bc:	20007f20 	.word	0x20007f20
  4019c0:	20027ffc 	.word	0x20027ffc

004019c4 <_close>:
}

extern int _close(int file)
{
	return -1;
}
  4019c4:	f04f 30ff 	mov.w	r0, #4294967295
  4019c8:	4770      	bx	lr
  4019ca:	bf00      	nop

004019cc <_lseek>:
}

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
  4019cc:	2000      	movs	r0, #0
  4019ce:	4770      	bx	lr

004019d0 <usart_command_console_task>:
}

/*-----------------------------------------------------------*/

static void usart_command_console_task(void *pvParameters)
{
  4019d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4019d4:	b087      	sub	sp, #28
	static int8_t input_string[MAX_INPUT_SIZE],
			last_input_string[MAX_INPUT_SIZE];
	portBASE_TYPE returned_value;
	portTickType max_block_time_ticks = 200UL / portTICK_RATE_MS;

	cli_usart = (freertos_usart_if) pvParameters;
  4019d6:	4b5f      	ldr	r3, [pc, #380]	; (401b54 <usart_command_console_task+0x184>)
  4019d8:	6018      	str	r0, [r3, #0]
	configASSERT(cli_usart);
  4019da:	b918      	cbnz	r0, 4019e4 <usart_command_console_task+0x14>
  4019dc:	485e      	ldr	r0, [pc, #376]	; (401b58 <usart_command_console_task+0x188>)
  4019de:	2194      	movs	r1, #148	; 0x94
  4019e0:	4b5e      	ldr	r3, [pc, #376]	; (401b5c <usart_command_console_task+0x18c>)
  4019e2:	4798      	blx	r3

	/* Obtain the address of the output buffer.  Note there is no mutual
	exclusion on this buffer as it is assumed only one command console
	interface will be used at any one time. */
	output_string = (uint8_t *) FreeRTOS_CLIGetOutputBuffer();
  4019e4:	4b5e      	ldr	r3, [pc, #376]	; (401b60 <usart_command_console_task+0x190>)
  4019e6:	4798      	blx	r3
  4019e8:	4604      	mov	r4, r0
  4019ea:	9002      	str	r0, [sp, #8]

	/* Send the welcome message.  The message is copied into RAM first as the
	DMA cannot send from Flash addresses. */
	strcpy((char *) output_string, (char *) welcome_message);
  4019ec:	495d      	ldr	r1, [pc, #372]	; (401b64 <usart_command_console_task+0x194>)
  4019ee:	2250      	movs	r2, #80	; 0x50
  4019f0:	4b5d      	ldr	r3, [pc, #372]	; (401b68 <usart_command_console_task+0x198>)
  4019f2:	4798      	blx	r3
	freertos_usart_write_packet(cli_usart, output_string,
  4019f4:	4b57      	ldr	r3, [pc, #348]	; (401b54 <usart_command_console_task+0x184>)
  4019f6:	6818      	ldr	r0, [r3, #0]
  4019f8:	2600      	movs	r6, #0
  4019fa:	9600      	str	r6, [sp, #0]
  4019fc:	4621      	mov	r1, r4
  4019fe:	224f      	movs	r2, #79	; 0x4f
  401a00:	23c8      	movs	r3, #200	; 0xc8
  401a02:	4d5a      	ldr	r5, [pc, #360]	; (401b6c <usart_command_console_task+0x19c>)
  401a04:	47a8      	blx	r5
			strlen((char *) welcome_message),
			max_block_time_ticks);

	for (;;) {
		/* Only interested in reading one character at a time. */
		if (freertos_usart_serial_read_packet(cli_usart,
  401a06:	4d53      	ldr	r5, [pc, #332]	; (401b54 <usart_command_console_task+0x184>)
  401a08:	4f59      	ldr	r7, [pc, #356]	; (401b70 <usart_command_console_task+0x1a0>)
				} else {
					/* A character was entered.  Add it to the string
					entered so far.  When a \n is entered the complete
					string will be passed to the command interpreter. */
					if (input_index < MAX_INPUT_SIZE) {
						input_string[input_index] = received_char;
  401a0a:	f8df 8178 	ldr.w	r8, [pc, #376]	; 401b84 <usart_command_console_task+0x1b4>
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy((char *) last_input_string,
						(char *) input_string);
				input_index = 0;
				memset(input_string, 0x00, MAX_INPUT_SIZE);
  401a0e:	f108 0304 	add.w	r3, r8, #4
  401a12:	9303      	str	r3, [sp, #12]
  401a14:	f108 0b08 	add.w	fp, r8, #8
			strlen((char *) welcome_message),
			max_block_time_ticks);

	for (;;) {
		/* Only interested in reading one character at a time. */
		if (freertos_usart_serial_read_packet(cli_usart,
  401a18:	6828      	ldr	r0, [r5, #0]
  401a1a:	f10d 0117 	add.w	r1, sp, #23
  401a1e:	2201      	movs	r2, #1
  401a20:	f04f 33ff 	mov.w	r3, #4294967295
  401a24:	47b8      	blx	r7
  401a26:	2801      	cmp	r0, #1
  401a28:	d1f6      	bne.n	401a18 <usart_command_console_task+0x48>
				&received_char, sizeof(received_char),
				portMAX_DELAY) == sizeof(received_char)) {
			/* Echo the character. */
			freertos_usart_write_packet(cli_usart, &received_char,
  401a2a:	2300      	movs	r3, #0
  401a2c:	9300      	str	r3, [sp, #0]
  401a2e:	6828      	ldr	r0, [r5, #0]
  401a30:	f10d 0117 	add.w	r1, sp, #23
  401a34:	2201      	movs	r2, #1
  401a36:	23c8      	movs	r3, #200	; 0xc8
  401a38:	f8df c130 	ldr.w	ip, [pc, #304]	; 401b6c <usart_command_console_task+0x19c>
  401a3c:	47e0      	blx	ip
					sizeof(received_char),
					max_block_time_ticks);

			if (received_char == '\r') {
  401a3e:	f89d 3017 	ldrb.w	r3, [sp, #23]
  401a42:	2b0d      	cmp	r3, #13
  401a44:	d170      	bne.n	401b28 <usart_command_console_task+0x158>
				/* Start to transmit a line separator, just to make the output
				easier to read. */
				strcpy((char *) output_string,
  401a46:	4b4b      	ldr	r3, [pc, #300]	; (401b74 <usart_command_console_task+0x1a4>)
  401a48:	881a      	ldrh	r2, [r3, #0]
  401a4a:	789b      	ldrb	r3, [r3, #2]
  401a4c:	9802      	ldr	r0, [sp, #8]
  401a4e:	4601      	mov	r1, r0
  401a50:	8002      	strh	r2, [r0, #0]
  401a52:	7083      	strb	r3, [r0, #2]
						(char *) new_line);
				freertos_usart_write_packet(cli_usart,
  401a54:	2300      	movs	r3, #0
  401a56:	9300      	str	r3, [sp, #0]
  401a58:	6828      	ldr	r0, [r5, #0]
  401a5a:	2202      	movs	r2, #2
  401a5c:	23c8      	movs	r3, #200	; 0xc8
  401a5e:	f8df c10c 	ldr.w	ip, [pc, #268]	; 401b6c <usart_command_console_task+0x19c>
  401a62:	47e0      	blx	ip
						(char *) new_line),
						max_block_time_ticks);

				/* See if the command is empty, indicating that the last command
				is to be executed again. */
				if (input_index == 0) {
  401a64:	b91e      	cbnz	r6, 401a6e <usart_command_console_task+0x9e>
					strcpy((char *) input_string,
  401a66:	4640      	mov	r0, r8
  401a68:	4943      	ldr	r1, [pc, #268]	; (401b78 <usart_command_console_task+0x1a8>)
  401a6a:	4b44      	ldr	r3, [pc, #272]	; (401b7c <usart_command_console_task+0x1ac>)
  401a6c:	4798      	blx	r3
				command interpreter is called repeatedly until it returns pdFALSE as
				it might generate more than one string. */
				do {
					/* Get the string to write to the UART from the command
					interpreter. */
					returned_value = FreeRTOS_CLIProcessCommand(
  401a6e:	f8df a118 	ldr.w	sl, [pc, #280]	; 401b88 <usart_command_console_task+0x1b8>
							input_string,
							(int8_t *) output_string,
							configCOMMAND_INT_MAX_OUTPUT_SIZE);

					/* Start the USART transmitting the generated string. */
					freertos_usart_write_packet(cli_usart,
  401a72:	f8df 9118 	ldr.w	r9, [pc, #280]	; 401b8c <usart_command_console_task+0x1bc>
				command interpreter is called repeatedly until it returns pdFALSE as
				it might generate more than one string. */
				do {
					/* Get the string to write to the UART from the command
					interpreter. */
					returned_value = FreeRTOS_CLIProcessCommand(
  401a76:	4640      	mov	r0, r8
  401a78:	9c02      	ldr	r4, [sp, #8]
  401a7a:	4621      	mov	r1, r4
  401a7c:	f44f 72c8 	mov.w	r2, #400	; 0x190
  401a80:	47d0      	blx	sl
  401a82:	4606      	mov	r6, r0
							input_string,
							(int8_t *) output_string,
							configCOMMAND_INT_MAX_OUTPUT_SIZE);

					/* Start the USART transmitting the generated string. */
					freertos_usart_write_packet(cli_usart,
  401a84:	4620      	mov	r0, r4
  401a86:	47c8      	blx	r9
  401a88:	4602      	mov	r2, r0
  401a8a:	2300      	movs	r3, #0
  401a8c:	9300      	str	r3, [sp, #0]
  401a8e:	6828      	ldr	r0, [r5, #0]
  401a90:	4621      	mov	r1, r4
  401a92:	23c8      	movs	r3, #200	; 0xc8
  401a94:	4c35      	ldr	r4, [pc, #212]	; (401b6c <usart_command_console_task+0x19c>)
  401a96:	47a0      	blx	r4
							output_string,
							strlen((char *)
							output_string),
							max_block_time_ticks);
				} while (returned_value != pdFALSE);
  401a98:	2e00      	cmp	r6, #0
  401a9a:	d1ec      	bne.n	401a76 <usart_command_console_task+0xa6>

				/* All the strings generated by the input command have been sent.
				Clear the input	string ready to receive the next command.
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy((char *) last_input_string,
  401a9c:	4836      	ldr	r0, [pc, #216]	; (401b78 <usart_command_console_task+0x1a8>)
  401a9e:	4641      	mov	r1, r8
  401aa0:	4b36      	ldr	r3, [pc, #216]	; (401b7c <usart_command_console_task+0x1ac>)
  401aa2:	4798      	blx	r3
						(char *) input_string);
				input_index = 0;
				memset(input_string, 0x00, MAX_INPUT_SIZE);
  401aa4:	2200      	movs	r2, #0
  401aa6:	f8c8 2000 	str.w	r2, [r8]
  401aaa:	9b03      	ldr	r3, [sp, #12]
  401aac:	601a      	str	r2, [r3, #0]
  401aae:	465b      	mov	r3, fp
  401ab0:	f843 2b04 	str.w	r2, [r3], #4
  401ab4:	f8cb 2004 	str.w	r2, [fp, #4]
  401ab8:	3304      	adds	r3, #4
  401aba:	f843 2b04 	str.w	r2, [r3], #4
  401abe:	f843 2b04 	str.w	r2, [r3], #4
  401ac2:	f843 2b04 	str.w	r2, [r3], #4
  401ac6:	f843 2b04 	str.w	r2, [r3], #4
  401aca:	f843 2b04 	str.w	r2, [r3], #4
  401ace:	f843 2b04 	str.w	r2, [r3], #4
  401ad2:	f843 2b04 	str.w	r2, [r3], #4
  401ad6:	f843 2b04 	str.w	r2, [r3], #4
  401ada:	801a      	strh	r2, [r3, #0]

				/* Start to transmit a line separator, just to make the output
				easier to read. */
				strcpy((char *) output_string,
  401adc:	4e28      	ldr	r6, [pc, #160]	; (401b80 <usart_command_console_task+0x1b0>)
  401ade:	f8dd e008 	ldr.w	lr, [sp, #8]
  401ae2:	f106 0930 	add.w	r9, r6, #48	; 0x30
  401ae6:	4634      	mov	r4, r6
  401ae8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  401aea:	f8ce 0000 	str.w	r0, [lr]
  401aee:	f8ce 1004 	str.w	r1, [lr, #4]
  401af2:	f8ce 2008 	str.w	r2, [lr, #8]
  401af6:	f8ce 300c 	str.w	r3, [lr, #12]
  401afa:	4626      	mov	r6, r4
  401afc:	f10e 0e10 	add.w	lr, lr, #16
  401b00:	454c      	cmp	r4, r9
  401b02:	d1f0      	bne.n	401ae6 <usart_command_console_task+0x116>
  401b04:	ce03      	ldmia	r6!, {r0, r1}
  401b06:	f8ce 0000 	str.w	r0, [lr]
  401b0a:	f8ce 1004 	str.w	r1, [lr, #4]
  401b0e:	7833      	ldrb	r3, [r6, #0]
  401b10:	f88e 3008 	strb.w	r3, [lr, #8]
						(char *) line_separator);
				freertos_usart_write_packet(cli_usart,
  401b14:	2600      	movs	r6, #0
  401b16:	9600      	str	r6, [sp, #0]
  401b18:	6828      	ldr	r0, [r5, #0]
  401b1a:	9902      	ldr	r1, [sp, #8]
  401b1c:	2238      	movs	r2, #56	; 0x38
  401b1e:	23c8      	movs	r3, #200	; 0xc8
  401b20:	f8df c048 	ldr.w	ip, [pc, #72]	; 401b6c <usart_command_console_task+0x19c>
  401b24:	47e0      	blx	ip
  401b26:	e777      	b.n	401a18 <usart_command_console_task+0x48>
						output_string, strlen(
						(char *) line_separator),
						max_block_time_ticks);
			} else {
				if (received_char == '\n') {
  401b28:	2b0a      	cmp	r3, #10
  401b2a:	f43f af75 	beq.w	401a18 <usart_command_console_task+0x48>
					/* Ignore the character. */
				} else if (received_char == '\b') {
  401b2e:	2b08      	cmp	r3, #8
  401b30:	d108      	bne.n	401b44 <usart_command_console_task+0x174>
					/* Backspace was pressed.  Erase the last character in the
					string - if any. */
					if (input_index > 0) {
  401b32:	2e00      	cmp	r6, #0
  401b34:	f43f af70 	beq.w	401a18 <usart_command_console_task+0x48>
						input_index--;
  401b38:	3e01      	subs	r6, #1
  401b3a:	b2f6      	uxtb	r6, r6
						input_string[input_index] = '\0';
  401b3c:	2300      	movs	r3, #0
  401b3e:	f808 3006 	strb.w	r3, [r8, r6]
  401b42:	e769      	b.n	401a18 <usart_command_console_task+0x48>
					}
				} else {
					/* A character was entered.  Add it to the string
					entered so far.  When a \n is entered the complete
					string will be passed to the command interpreter. */
					if (input_index < MAX_INPUT_SIZE) {
  401b44:	2e31      	cmp	r6, #49	; 0x31
  401b46:	f63f af67 	bhi.w	401a18 <usart_command_console_task+0x48>
						input_string[input_index] = received_char;
  401b4a:	f808 3006 	strb.w	r3, [r8, r6]
						input_index++;
  401b4e:	3601      	adds	r6, #1
  401b50:	b2f6      	uxtb	r6, r6
  401b52:	e761      	b.n	401a18 <usart_command_console_task+0x48>
  401b54:	20000b44 	.word	0x20000b44
  401b58:	0040975c 	.word	0x0040975c
  401b5c:	00403de1 	.word	0x00403de1
  401b60:	00401dc5 	.word	0x00401dc5
  401b64:	004097b0 	.word	0x004097b0
  401b68:	004040a1 	.word	0x004040a1
  401b6c:	00400f55 	.word	0x00400f55
  401b70:	00400fdd 	.word	0x00400fdd
  401b74:	00409d34 	.word	0x00409d34
  401b78:	20000aa8 	.word	0x20000aa8
  401b7c:	00404405 	.word	0x00404405
  401b80:	00409800 	.word	0x00409800
  401b84:	20000adc 	.word	0x20000adc
  401b88:	00401ccd 	.word	0x00401ccd
  401b8c:	004044c1 	.word	0x004044c1

00401b90 <create_usart_cli_task>:

/*-----------------------------------------------------------*/

void create_usart_cli_task(Usart *usart_base, uint16_t stack_depth_words,
		unsigned portBASE_TYPE task_priority)
{
  401b90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401b94:	b08e      	sub	sp, #56	; 0x38
  401b96:	4686      	mov	lr, r0
  401b98:	460f      	mov	r7, r1
  401b9a:	4690      	mov	r8, r2
	freertos_usart_if freertos_usart;
	freertos_peripheral_options_t driver_options = {
  401b9c:	4c14      	ldr	r4, [pc, #80]	; (401bf0 <create_usart_cli_task+0x60>)
  401b9e:	ae0a      	add	r6, sp, #40	; 0x28
  401ba0:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  401ba4:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
		configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY,	/* The priority used by the USART interrupts. */
		USART_RS232,									/* Configure the USART for RS232 operation. */
		(WAIT_TX_COMPLETE | USE_TX_ACCESS_MUTEX)		/* Use access mutex on Tx (as more than one task transmits) but not Rx. Wait for a Tx to complete before returning from send functions. */
	};

	const sam_usart_opt_t usart_settings = {
  401ba8:	ad04      	add	r5, sp, #16
  401baa:	3410      	adds	r4, #16
  401bac:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  401bae:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  401bb0:	e894 0003 	ldmia.w	r4, {r0, r1}
  401bb4:	e885 0003 	stmia.w	r5, {r0, r1}
		US_MR_CHMODE_NORMAL,
		0 /* Only used in IrDA mode. */
	};

	/* Initialise the USART interface. */
	freertos_usart = freertos_usart_serial_init(usart_base,
  401bb8:	4670      	mov	r0, lr
  401bba:	a904      	add	r1, sp, #16
  401bbc:	4632      	mov	r2, r6
  401bbe:	4b0d      	ldr	r3, [pc, #52]	; (401bf4 <create_usart_cli_task+0x64>)
  401bc0:	4798      	blx	r3
			&usart_settings,
			&driver_options);
	configASSERT(freertos_usart);
  401bc2:	4604      	mov	r4, r0
  401bc4:	b918      	cbnz	r0, 401bce <create_usart_cli_task+0x3e>
  401bc6:	480c      	ldr	r0, [pc, #48]	; (401bf8 <create_usart_cli_task+0x68>)
  401bc8:	217b      	movs	r1, #123	; 0x7b
  401bca:	4b0c      	ldr	r3, [pc, #48]	; (401bfc <create_usart_cli_task+0x6c>)
  401bcc:	4798      	blx	r3

	/* Register the default CLI commands. */
	vRegisterCLICommands();
  401bce:	4b0c      	ldr	r3, [pc, #48]	; (401c00 <create_usart_cli_task+0x70>)
  401bd0:	4798      	blx	r3

	/* Create the USART CLI task. */
	xTaskCreate(	usart_command_console_task,			/* The task that implements the command console. */
  401bd2:	f8cd 8000 	str.w	r8, [sp]
  401bd6:	2300      	movs	r3, #0
  401bd8:	9301      	str	r3, [sp, #4]
  401bda:	9302      	str	r3, [sp, #8]
  401bdc:	9303      	str	r3, [sp, #12]
  401bde:	4809      	ldr	r0, [pc, #36]	; (401c04 <create_usart_cli_task+0x74>)
  401be0:	4909      	ldr	r1, [pc, #36]	; (401c08 <create_usart_cli_task+0x78>)
  401be2:	463a      	mov	r2, r7
  401be4:	4623      	mov	r3, r4
  401be6:	4c09      	ldr	r4, [pc, #36]	; (401c0c <create_usart_cli_task+0x7c>)
  401be8:	47a0      	blx	r4
					(const int8_t *const) "U_CLI",	/* Text name assigned to the task.  This is just to assist debugging.  The kernel does not use this name itself. */
					stack_depth_words,					/* The size of the stack allocated to the task. */
					(void *) freertos_usart,			/* The parameter is used to pass the already configured USART port into the task. */
					task_priority,						/* The priority allocated to the task. */
					NULL);								/* Used to store the handle to the created task - in this case the handle is not required. */
}
  401bea:	b00e      	add	sp, #56	; 0x38
  401bec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401bf0:	00409734 	.word	0x00409734
  401bf4:	00400d49 	.word	0x00400d49
  401bf8:	0040975c 	.word	0x0040975c
  401bfc:	00403de1 	.word	0x00403de1
  401c00:	00403d69 	.word	0x00403d69
  401c04:	004019d1 	.word	0x004019d1
  401c08:	0040983c 	.word	0x0040983c
  401c0c:	0040298d 	.word	0x0040298d

00401c10 <usart_cli_output>:
}

/*-----------------------------------------------------------*/

void usart_cli_output(const uint8_t *message_string)
{
  401c10:	b530      	push	{r4, r5, lr}
  401c12:	b083      	sub	sp, #12
	const portTickType max_block_time_ticks = 200UL / portTICK_RATE_MS;

	/* The USART is configured to use a mutex on Tx, so can be safely written
	to directly. */
	if (cli_usart != NULL) {
  401c14:	4b07      	ldr	r3, [pc, #28]	; (401c34 <usart_cli_output+0x24>)
  401c16:	681d      	ldr	r5, [r3, #0]
  401c18:	b155      	cbz	r5, 401c30 <usart_cli_output+0x20>
  401c1a:	4604      	mov	r4, r0
		freertos_usart_write_packet(cli_usart, message_string,
  401c1c:	4b06      	ldr	r3, [pc, #24]	; (401c38 <usart_cli_output+0x28>)
  401c1e:	4798      	blx	r3
  401c20:	4602      	mov	r2, r0
  401c22:	2300      	movs	r3, #0
  401c24:	9300      	str	r3, [sp, #0]
  401c26:	4628      	mov	r0, r5
  401c28:	4621      	mov	r1, r4
  401c2a:	23c8      	movs	r3, #200	; 0xc8
  401c2c:	4c03      	ldr	r4, [pc, #12]	; (401c3c <usart_cli_output+0x2c>)
  401c2e:	47a0      	blx	r4
				strlen((const char *) message_string), max_block_time_ticks);
	}
}
  401c30:	b003      	add	sp, #12
  401c32:	bd30      	pop	{r4, r5, pc}
  401c34:	20000b44 	.word	0x20000b44
  401c38:	004044c1 	.word	0x004044c1
  401c3c:	00400f55 	.word	0x00400f55

00401c40 <prvHelpCommand>:
	return pcReturn;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvHelpCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
  401c40:	b538      	push	{r3, r4, r5, lr}
  401c42:	460a      	mov	r2, r1
static const CLI_Definition_List_Item_t * pxCommand = NULL;
signed portBASE_TYPE xReturn;

	( void ) pcCommandString;

	if( pxCommand == NULL )
  401c44:	4b08      	ldr	r3, [pc, #32]	; (401c68 <prvHelpCommand+0x28>)
  401c46:	681b      	ldr	r3, [r3, #0]
  401c48:	b913      	cbnz	r3, 401c50 <prvHelpCommand+0x10>
	{
		/* Reset the pxCommand pointer back to the start of the list. */
		pxCommand = &xRegisteredCommands;
  401c4a:	4908      	ldr	r1, [pc, #32]	; (401c6c <prvHelpCommand+0x2c>)
  401c4c:	4b06      	ldr	r3, [pc, #24]	; (401c68 <prvHelpCommand+0x28>)
  401c4e:	6019      	str	r1, [r3, #0]
	}

	/* Return the next command help string, before moving the pointer on to
	the next command in the list. */
	strncpy( ( char * ) pcWriteBuffer, ( const char * ) pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
  401c50:	4c05      	ldr	r4, [pc, #20]	; (401c68 <prvHelpCommand+0x28>)
  401c52:	6825      	ldr	r5, [r4, #0]
  401c54:	682b      	ldr	r3, [r5, #0]
  401c56:	6859      	ldr	r1, [r3, #4]
  401c58:	4b05      	ldr	r3, [pc, #20]	; (401c70 <prvHelpCommand+0x30>)
  401c5a:	4798      	blx	r3
	pxCommand = pxCommand->pxNext;
  401c5c:	6868      	ldr	r0, [r5, #4]
  401c5e:	6020      	str	r0, [r4, #0]
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
  401c60:	3000      	adds	r0, #0
  401c62:	bf18      	it	ne
  401c64:	2001      	movne	r0, #1
  401c66:	bd38      	pop	{r3, r4, r5, pc}
  401c68:	20000cdc 	.word	0x20000cdc
  401c6c:	20000008 	.word	0x20000008
  401c70:	00404611 	.word	0x00404611

00401c74 <FreeRTOS_CLIRegisterCommand>:
static int8_t cOutputBuffer[ configCOMMAND_INT_MAX_OUTPUT_SIZE ];

/*-----------------------------------------------------------*/

portBASE_TYPE FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister )
{
  401c74:	b538      	push	{r3, r4, r5, lr}
static CLI_Definition_List_Item_t *pxLastCommandInList = &xRegisteredCommands;
CLI_Definition_List_Item_t *pxNewListItem;
portBASE_TYPE xReturn = pdFAIL;

	/* Check the parameter is not NULL. */
	configASSERT( pxCommandToRegister );
  401c76:	4605      	mov	r5, r0
  401c78:	b918      	cbnz	r0, 401c82 <FreeRTOS_CLIRegisterCommand+0xe>
  401c7a:	480e      	ldr	r0, [pc, #56]	; (401cb4 <FreeRTOS_CLIRegisterCommand+0x40>)
  401c7c:	2167      	movs	r1, #103	; 0x67
  401c7e:	4b0e      	ldr	r3, [pc, #56]	; (401cb8 <FreeRTOS_CLIRegisterCommand+0x44>)
  401c80:	4798      	blx	r3

	/* Create a new list item that will reference the command being registered. */
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
  401c82:	2008      	movs	r0, #8
  401c84:	4b0d      	ldr	r3, [pc, #52]	; (401cbc <FreeRTOS_CLIRegisterCommand+0x48>)
  401c86:	4798      	blx	r3
	configASSERT( pxNewListItem );
  401c88:	4604      	mov	r4, r0
  401c8a:	b928      	cbnz	r0, 401c98 <FreeRTOS_CLIRegisterCommand+0x24>
  401c8c:	4809      	ldr	r0, [pc, #36]	; (401cb4 <FreeRTOS_CLIRegisterCommand+0x40>)
  401c8e:	216b      	movs	r1, #107	; 0x6b
  401c90:	4b09      	ldr	r3, [pc, #36]	; (401cb8 <FreeRTOS_CLIRegisterCommand+0x44>)
  401c92:	4798      	blx	r3

portBASE_TYPE FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister )
{
static CLI_Definition_List_Item_t *pxLastCommandInList = &xRegisteredCommands;
CLI_Definition_List_Item_t *pxNewListItem;
portBASE_TYPE xReturn = pdFAIL;
  401c94:	2000      	movs	r0, #0
  401c96:	bd38      	pop	{r3, r4, r5, pc}
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
	configASSERT( pxNewListItem );

	if( pxNewListItem != NULL )
	{
		taskENTER_CRITICAL();
  401c98:	4b09      	ldr	r3, [pc, #36]	; (401cc0 <FreeRTOS_CLIRegisterCommand+0x4c>)
  401c9a:	4798      	blx	r3
		{
			/* Reference the command being registered from the newly created
			list item. */
			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;
  401c9c:	6025      	str	r5, [r4, #0]

			/* The new list item will get added to the end of the list, so
			pxNext has nowhere to point. */
			pxNewListItem->pxNext = NULL;
  401c9e:	2300      	movs	r3, #0
  401ca0:	6063      	str	r3, [r4, #4]

			/* Add the newly created list item to the end of the already existing
			list. */
			pxLastCommandInList->pxNext = pxNewListItem;
  401ca2:	4b08      	ldr	r3, [pc, #32]	; (401cc4 <FreeRTOS_CLIRegisterCommand+0x50>)
  401ca4:	681a      	ldr	r2, [r3, #0]
  401ca6:	6054      	str	r4, [r2, #4]

			/* Set the end of list marker to the new list item. */
			pxLastCommandInList = pxNewListItem;
  401ca8:	601c      	str	r4, [r3, #0]
		}
		taskEXIT_CRITICAL();
  401caa:	4b07      	ldr	r3, [pc, #28]	; (401cc8 <FreeRTOS_CLIRegisterCommand+0x54>)
  401cac:	4798      	blx	r3

		xReturn = pdPASS;
  401cae:	2001      	movs	r0, #1
	}

	return xReturn;
}
  401cb0:	bd38      	pop	{r3, r4, r5, pc}
  401cb2:	bf00      	nop
  401cb4:	00409854 	.word	0x00409854
  401cb8:	00403de1 	.word	0x00403de1
  401cbc:	004020d9 	.word	0x004020d9
  401cc0:	00401f65 	.word	0x00401f65
  401cc4:	20000010 	.word	0x20000010
  401cc8:	00401f85 	.word	0x00401f85

00401ccc <FreeRTOS_CLIProcessCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE FreeRTOS_CLIProcessCommand( const int8_t * const pcCommandInput, int8_t * pcWriteBuffer, size_t xWriteBufferLen  )
{
  401ccc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401cd0:	b083      	sub	sp, #12
  401cd2:	4606      	mov	r6, r0
  401cd4:	9101      	str	r1, [sp, #4]
  401cd6:	4692      	mov	sl, r2
size_t xCommandStringLength;

	/* Note:  This function is not re-entrant.  It must not be called from more
	thank one task. */

	if( pxCommand == NULL )
  401cd8:	4b33      	ldr	r3, [pc, #204]	; (401da8 <FreeRTOS_CLIProcessCommand+0xdc>)
  401cda:	681a      	ldr	r2, [r3, #0]
  401cdc:	2a00      	cmp	r2, #0
  401cde:	d147      	bne.n	401d70 <FreeRTOS_CLIProcessCommand+0xa4>
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
  401ce0:	4c32      	ldr	r4, [pc, #200]	; (401dac <FreeRTOS_CLIProcessCommand+0xe0>)
  401ce2:	601c      	str	r4, [r3, #0]
		{
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
  401ce4:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 401dbc <FreeRTOS_CLIProcessCommand+0xf0>
			a sub-string of a longer command, check the byte after the expected
			end of the string is either the end of the string or a space before
			a parameter. */
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
			{
				if( strncmp( ( const char * ) pcCommandInput, ( const char * ) pcRegisteredCommandString, xCommandStringLength ) == 0 )
  401ce8:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 401dc0 <FreeRTOS_CLIProcessCommand+0xf4>
	thank one task. */

	if( pxCommand == NULL )
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
  401cec:	4699      	mov	r9, r3
		{
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
  401cee:	6827      	ldr	r7, [r4, #0]
  401cf0:	683d      	ldr	r5, [r7, #0]
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
  401cf2:	4628      	mov	r0, r5
  401cf4:	47c0      	blx	r8
  401cf6:	4602      	mov	r2, r0

			/* To ensure the string lengths match exactly, so as not to pick up
			a sub-string of a longer command, check the byte after the expected
			end of the string is either the end of the string or a space before
			a parameter. */
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
  401cf8:	5633      	ldrsb	r3, [r6, r0]
  401cfa:	f033 0320 	bics.w	r3, r3, #32
  401cfe:	d124      	bne.n	401d4a <FreeRTOS_CLIProcessCommand+0x7e>
			{
				if( strncmp( ( const char * ) pcCommandInput, ( const char * ) pcRegisteredCommandString, xCommandStringLength ) == 0 )
  401d00:	4630      	mov	r0, r6
  401d02:	4629      	mov	r1, r5
  401d04:	47d8      	blx	fp
  401d06:	bb00      	cbnz	r0, 401d4a <FreeRTOS_CLIProcessCommand+0x7e>
				{
					/* The command has been found.  Check it has the expected
					number of parameters.  If cExpectedNumberOfParameters is -1,
					then there could be a variable number of parameters and no
					check is made. */
					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
  401d08:	7b39      	ldrb	r1, [r7, #12]
  401d0a:	f011 0f80 	tst.w	r1, #128	; 0x80
  401d0e:	d142      	bne.n	401d96 <FreeRTOS_CLIProcessCommand+0xca>
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
  401d10:	7832      	ldrb	r2, [r6, #0]
  401d12:	b1aa      	cbz	r2, 401d40 <FreeRTOS_CLIProcessCommand+0x74>
  401d14:	4630      	mov	r0, r6
  401d16:	2300      	movs	r3, #0
  401d18:	461c      	mov	r4, r3
				xLastCharacterWasSpace = pdTRUE;
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
  401d1a:	461d      	mov	r5, r3
		if( ( *pcCommandString ) == ' ' )
		{
			if( xLastCharacterWasSpace != pdTRUE )
			{
				cParameters++;
				xLastCharacterWasSpace = pdTRUE;
  401d1c:	2701      	movs	r7, #1
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
	{
		if( ( *pcCommandString ) == ' ' )
  401d1e:	b252      	sxtb	r2, r2
  401d20:	2a20      	cmp	r2, #32
  401d22:	d104      	bne.n	401d2e <FreeRTOS_CLIProcessCommand+0x62>
		{
			if( xLastCharacterWasSpace != pdTRUE )
  401d24:	b924      	cbnz	r4, 401d30 <FreeRTOS_CLIProcessCommand+0x64>
			{
				cParameters++;
  401d26:	3301      	adds	r3, #1
  401d28:	b2db      	uxtb	r3, r3
				xLastCharacterWasSpace = pdTRUE;
  401d2a:	463c      	mov	r4, r7
  401d2c:	e000      	b.n	401d30 <FreeRTOS_CLIProcessCommand+0x64>
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
  401d2e:	462c      	mov	r4, r5
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
  401d30:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  401d34:	2a00      	cmp	r2, #0
  401d36:	d1f2      	bne.n	401d1e <FreeRTOS_CLIProcessCommand+0x52>
		pcCommandString++;
	}

	/* If the command string ended with spaces, then there will have been too
	many parameters counted. */
	if( xLastCharacterWasSpace == pdTRUE )
  401d38:	b11c      	cbz	r4, 401d42 <FreeRTOS_CLIProcessCommand+0x76>
	{
		cParameters--;
  401d3a:	3b01      	subs	r3, #1
  401d3c:	b2db      	uxtb	r3, r3
  401d3e:	e000      	b.n	401d42 <FreeRTOS_CLIProcessCommand+0x76>
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
  401d40:	2300      	movs	r3, #0
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
  401d42:	4a19      	ldr	r2, [pc, #100]	; (401da8 <FreeRTOS_CLIProcessCommand+0xdc>)
  401d44:	6812      	ldr	r2, [r2, #0]
  401d46:	b932      	cbnz	r2, 401d56 <FreeRTOS_CLIProcessCommand+0x8a>
  401d48:	e01e      	b.n	401d88 <FreeRTOS_CLIProcessCommand+0xbc>
	thank one task. */

	if( pxCommand == NULL )
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
  401d4a:	6864      	ldr	r4, [r4, #4]
  401d4c:	f8c9 4000 	str.w	r4, [r9]
  401d50:	2c00      	cmp	r4, #0
  401d52:	d1cc      	bne.n	401cee <FreeRTOS_CLIProcessCommand+0x22>
  401d54:	e018      	b.n	401d88 <FreeRTOS_CLIProcessCommand+0xbc>
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
  401d56:	b249      	sxtb	r1, r1
  401d58:	b25b      	sxtb	r3, r3
  401d5a:	4299      	cmp	r1, r3
  401d5c:	d008      	beq.n	401d70 <FreeRTOS_CLIProcessCommand+0xa4>
	{
		/* The command was found, but the number of parameters with the command
		was incorrect. */
		strncpy( ( char * ) pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
  401d5e:	9801      	ldr	r0, [sp, #4]
  401d60:	4913      	ldr	r1, [pc, #76]	; (401db0 <FreeRTOS_CLIProcessCommand+0xe4>)
  401d62:	4652      	mov	r2, sl
  401d64:	4b13      	ldr	r3, [pc, #76]	; (401db4 <FreeRTOS_CLIProcessCommand+0xe8>)
  401d66:	4798      	blx	r3
		pxCommand = NULL;
  401d68:	2300      	movs	r3, #0
  401d6a:	4a0f      	ldr	r2, [pc, #60]	; (401da8 <FreeRTOS_CLIProcessCommand+0xdc>)
  401d6c:	6013      	str	r3, [r2, #0]
  401d6e:	e017      	b.n	401da0 <FreeRTOS_CLIProcessCommand+0xd4>
	}
	else if( pxCommand != NULL )
	{
		/* Call the callback function that is registered to this command. */
		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
  401d70:	6813      	ldr	r3, [r2, #0]
  401d72:	689b      	ldr	r3, [r3, #8]
  401d74:	9801      	ldr	r0, [sp, #4]
  401d76:	4651      	mov	r1, sl
  401d78:	4632      	mov	r2, r6
  401d7a:	4798      	blx	r3

		/* If xReturn is pdFALSE, then no further strings will be returned
		after this one, and	pxCommand can be reset to NULL ready to search
		for the next entered command. */
		if( xReturn == pdFALSE )
  401d7c:	4603      	mov	r3, r0
  401d7e:	b978      	cbnz	r0, 401da0 <FreeRTOS_CLIProcessCommand+0xd4>
		{
			pxCommand = NULL;
  401d80:	2100      	movs	r1, #0
  401d82:	4a09      	ldr	r2, [pc, #36]	; (401da8 <FreeRTOS_CLIProcessCommand+0xdc>)
  401d84:	6011      	str	r1, [r2, #0]
  401d86:	e00b      	b.n	401da0 <FreeRTOS_CLIProcessCommand+0xd4>
		}
	}
	else
	{
		/* pxCommand was NULL, the command was not found. */
		strncpy( ( char * ) pcWriteBuffer, ( const char * const ) "Command not recognised.  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
  401d88:	9801      	ldr	r0, [sp, #4]
  401d8a:	490b      	ldr	r1, [pc, #44]	; (401db8 <FreeRTOS_CLIProcessCommand+0xec>)
  401d8c:	4652      	mov	r2, sl
  401d8e:	4b09      	ldr	r3, [pc, #36]	; (401db4 <FreeRTOS_CLIProcessCommand+0xe8>)
  401d90:	4798      	blx	r3
		xReturn = pdFALSE;
  401d92:	2300      	movs	r3, #0
  401d94:	e004      	b.n	401da0 <FreeRTOS_CLIProcessCommand+0xd4>
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
  401d96:	4b04      	ldr	r3, [pc, #16]	; (401da8 <FreeRTOS_CLIProcessCommand+0xdc>)
  401d98:	681a      	ldr	r2, [r3, #0]
  401d9a:	2a00      	cmp	r2, #0
  401d9c:	d1e8      	bne.n	401d70 <FreeRTOS_CLIProcessCommand+0xa4>
  401d9e:	e7f3      	b.n	401d88 <FreeRTOS_CLIProcessCommand+0xbc>
		strncpy( ( char * ) pcWriteBuffer, ( const char * const ) "Command not recognised.  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
		xReturn = pdFALSE;
	}

	return xReturn;
}
  401da0:	4618      	mov	r0, r3
  401da2:	b003      	add	sp, #12
  401da4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401da8:	20000cd8 	.word	0x20000cd8
  401dac:	20000008 	.word	0x20000008
  401db0:	00409898 	.word	0x00409898
  401db4:	00404611 	.word	0x00404611
  401db8:	004098f0 	.word	0x004098f0
  401dbc:	004044c1 	.word	0x004044c1
  401dc0:	00404579 	.word	0x00404579

00401dc4 <FreeRTOS_CLIGetOutputBuffer>:
/*-----------------------------------------------------------*/

int8_t *FreeRTOS_CLIGetOutputBuffer( void )
{
	return cOutputBuffer;
}
  401dc4:	4800      	ldr	r0, [pc, #0]	; (401dc8 <FreeRTOS_CLIGetOutputBuffer+0x4>)
  401dc6:	4770      	bx	lr
  401dc8:	20000b48 	.word	0x20000b48

00401dcc <FreeRTOS_CLIGetParameter>:
const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;

	*pxParameterStringLength = 0;
  401dcc:	2300      	movs	r3, #0
  401dce:	6013      	str	r3, [r2, #0]

	while( uxParametersFound < uxWantedParameter )
  401dd0:	bb11      	cbnz	r1, 401e18 <FreeRTOS_CLIGetParameter+0x4c>
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;
  401dd2:	4618      	mov	r0, r3
			break;
		}
	}

	return pcReturn;
}
  401dd4:	4770      	bx	lr

	while( uxParametersFound < uxWantedParameter )
	{
		/* Index the character pointer past the current word.  If this is the start
		of the command string then the first word is the command itself. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
  401dd6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  401dda:	b353      	cbz	r3, 401e32 <FreeRTOS_CLIGetParameter+0x66>
  401ddc:	b25b      	sxtb	r3, r3
  401dde:	2b20      	cmp	r3, #32
  401de0:	d1f9      	bne.n	401dd6 <FreeRTOS_CLIGetParameter+0xa>
		{
			pcCommandString++;
		}

		/* Find the start of the next string. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
  401de2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  401de6:	b259      	sxtb	r1, r3
  401de8:	2920      	cmp	r1, #32
  401dea:	d0fa      	beq.n	401de2 <FreeRTOS_CLIGetParameter+0x16>
		{
			pcCommandString++;
		}

		/* Was a string found? */
		if( *pcCommandString != 0x00 )
  401dec:	b1eb      	cbz	r3, 401e2a <FreeRTOS_CLIGetParameter+0x5e>
		{
			/* Is this the start of the required parameter? */
			uxParametersFound++;
  401dee:	3401      	adds	r4, #1

			if( uxParametersFound == uxWantedParameter )
  401df0:	42ac      	cmp	r4, r5
  401df2:	d114      	bne.n	401e1e <FreeRTOS_CLIGetParameter+0x52>
			{
				/* How long is the parameter? */
				pcReturn = pcCommandString;
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
  401df4:	f990 3000 	ldrsb.w	r3, [r0]
  401df8:	f033 0320 	bics.w	r3, r3, #32
  401dfc:	d017      	beq.n	401e2e <FreeRTOS_CLIGetParameter+0x62>
  401dfe:	4601      	mov	r1, r0
				{
					( *pxParameterStringLength )++;
  401e00:	6813      	ldr	r3, [r2, #0]
  401e02:	3301      	adds	r3, #1
  401e04:	6013      	str	r3, [r2, #0]

			if( uxParametersFound == uxWantedParameter )
			{
				/* How long is the parameter? */
				pcReturn = pcCommandString;
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
  401e06:	f911 4f01 	ldrsb.w	r4, [r1, #1]!
  401e0a:	f034 0420 	bics.w	r4, r4, #32
  401e0e:	d1f7      	bne.n	401e00 <FreeRTOS_CLIGetParameter+0x34>
					pcCommandString++;
				}

				if( *pxParameterStringLength == 0 )
				{
					pcReturn = NULL;
  401e10:	2b00      	cmp	r3, #0
  401e12:	bf08      	it	eq
  401e14:	2000      	moveq	r0, #0
  401e16:	e00e      	b.n	401e36 <FreeRTOS_CLIGetParameter+0x6a>
	return cOutputBuffer;
}
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
  401e18:	b430      	push	{r4, r5}
  401e1a:	460d      	mov	r5, r1
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;

	*pxParameterStringLength = 0;

	while( uxParametersFound < uxWantedParameter )
  401e1c:	2400      	movs	r4, #0
	{
		/* Index the character pointer past the current word.  If this is the start
		of the command string then the first word is the command itself. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
  401e1e:	7803      	ldrb	r3, [r0, #0]
  401e20:	b13b      	cbz	r3, 401e32 <FreeRTOS_CLIGetParameter+0x66>
  401e22:	b25b      	sxtb	r3, r3
  401e24:	2b20      	cmp	r3, #32
  401e26:	d1d6      	bne.n	401dd6 <FreeRTOS_CLIGetParameter+0xa>
  401e28:	e7db      	b.n	401de2 <FreeRTOS_CLIGetParameter+0x16>
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;
  401e2a:	2000      	movs	r0, #0
  401e2c:	e003      	b.n	401e36 <FreeRTOS_CLIGetParameter+0x6a>
					pcCommandString++;
				}

				if( *pxParameterStringLength == 0 )
				{
					pcReturn = NULL;
  401e2e:	2000      	movs	r0, #0
  401e30:	e001      	b.n	401e36 <FreeRTOS_CLIGetParameter+0x6a>
		{
			pcCommandString++;
		}

		/* Find the start of the next string. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
  401e32:	7803      	ldrb	r3, [r0, #0]
  401e34:	e7da      	b.n	401dec <FreeRTOS_CLIGetParameter+0x20>
			break;
		}
	}

	return pcReturn;
}
  401e36:	bc30      	pop	{r4, r5}
  401e38:	4770      	bx	lr
  401e3a:	bf00      	nop

00401e3c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
  401e3c:	f100 0308 	add.w	r3, r0, #8
  401e40:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  401e42:	f04f 32ff 	mov.w	r2, #4294967295
  401e46:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  401e48:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  401e4a:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  401e4c:	2300      	movs	r3, #0
  401e4e:	6003      	str	r3, [r0, #0]
  401e50:	4770      	bx	lr
  401e52:	bf00      	nop

00401e54 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  401e54:	2300      	movs	r3, #0
  401e56:	6103      	str	r3, [r0, #16]
  401e58:	4770      	bx	lr
  401e5a:	bf00      	nop

00401e5c <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  401e5c:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  401e5e:	685a      	ldr	r2, [r3, #4]
  401e60:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  401e62:	6842      	ldr	r2, [r0, #4]
  401e64:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  401e66:	685a      	ldr	r2, [r3, #4]
  401e68:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  401e6a:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  401e6c:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  401e6e:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  401e70:	6803      	ldr	r3, [r0, #0]
  401e72:	3301      	adds	r3, #1
  401e74:	6003      	str	r3, [r0, #0]
  401e76:	4770      	bx	lr

00401e78 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
  401e78:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  401e7a:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  401e7c:	f1b4 3fff 	cmp.w	r4, #4294967295
  401e80:	d101      	bne.n	401e86 <vListInsert+0xe>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  401e82:	6903      	ldr	r3, [r0, #16]
  401e84:	e00a      	b.n	401e9c <vListInsert+0x24>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
  401e86:	f100 0308 	add.w	r3, r0, #8
  401e8a:	68c2      	ldr	r2, [r0, #12]
  401e8c:	6812      	ldr	r2, [r2, #0]
  401e8e:	4294      	cmp	r4, r2
  401e90:	d304      	bcc.n	401e9c <vListInsert+0x24>
  401e92:	685b      	ldr	r3, [r3, #4]
  401e94:	685a      	ldr	r2, [r3, #4]
  401e96:	6812      	ldr	r2, [r2, #0]
  401e98:	4294      	cmp	r4, r2
  401e9a:	d2fa      	bcs.n	401e92 <vListInsert+0x1a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  401e9c:	685a      	ldr	r2, [r3, #4]
  401e9e:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  401ea0:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
  401ea2:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
  401ea4:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  401ea6:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  401ea8:	6803      	ldr	r3, [r0, #0]
  401eaa:	3301      	adds	r3, #1
  401eac:	6003      	str	r3, [r0, #0]
}
  401eae:	f85d 4b04 	ldr.w	r4, [sp], #4
  401eb2:	4770      	bx	lr

00401eb4 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  401eb4:	6843      	ldr	r3, [r0, #4]
  401eb6:	6882      	ldr	r2, [r0, #8]
  401eb8:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  401eba:	6883      	ldr	r3, [r0, #8]
  401ebc:	6842      	ldr	r2, [r0, #4]
  401ebe:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  401ec0:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  401ec2:	685a      	ldr	r2, [r3, #4]
  401ec4:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  401ec6:	bf04      	itt	eq
  401ec8:	6882      	ldreq	r2, [r0, #8]
  401eca:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  401ecc:	2200      	movs	r2, #0
  401ece:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  401ed0:	681a      	ldr	r2, [r3, #0]
  401ed2:	3a01      	subs	r2, #1
  401ed4:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  401ed6:	6818      	ldr	r0, [r3, #0]
}
  401ed8:	4770      	bx	lr
  401eda:	bf00      	nop

00401edc <prvPortStartFirstTask>:

/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile (
  401edc:	4803      	ldr	r0, [pc, #12]	; (401eec <prvPortStartFirstTask+0x10>)
  401ede:	6800      	ldr	r0, [r0, #0]
  401ee0:	6800      	ldr	r0, [r0, #0]
  401ee2:	f380 8808 	msr	MSP, r0
  401ee6:	b662      	cpsie	i
  401ee8:	df00      	svc	0
  401eea:	bf00      	nop
  401eec:	e000ed08 	.word	0xe000ed08

00401ef0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
  401ef0:	f8df 000c 	ldr.w	r0, [pc, #12]	; 401f00 <vPortEnableVFP+0x10>
  401ef4:	6801      	ldr	r1, [r0, #0]
  401ef6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  401efa:	6001      	str	r1, [r0, #0]
  401efc:	4770      	bx	lr
  401efe:	0000      	.short	0x0000
  401f00:	e000ed88 	.word	0xe000ed88

00401f04 <pxPortInitialiseStack>:
	/* Offset added to account for the way the MCU uses the stack on
	* entry/exit
	* of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;    /* xPSR */
  401f04:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  401f08:	f840 3c04 	str.w	r3, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = (portSTACK_TYPE)pxCode;       /* PC */
  401f0c:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = 0;    /* LR */
  401f10:	2300      	movs	r3, #0
  401f12:	f840 3c0c 	str.w	r3, [r0, #-12]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;    /* R12, R3, R2 and R1. */
	*pxTopOfStack = (portSTACK_TYPE)pvParameters;       /* R0 */
  401f16:	f840 2c20 	str.w	r2, [r0, #-32]

	/* A save method is being used that requires each task to maintain its
	* own exec return value. */
	pxTopOfStack--;
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
  401f1a:	f06f 0302 	mvn.w	r3, #2
  401f1e:	f840 3c24 	str.w	r3, [r0, #-36]

	pxTopOfStack -= 8;    /* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
  401f22:	3844      	subs	r0, #68	; 0x44
  401f24:	4770      	bx	lr
  401f26:	bf00      	nop

00401f28 <SVC_Handler>:
/*-----------------------------------------------------------*/

/*void vPortSVCHandler( void )*/ /* ATMEL */
__attribute__ ((naked)) void SVC_Handler( void )
{
	__asm volatile (
  401f28:	4b05      	ldr	r3, [pc, #20]	; (401f40 <pxCurrentTCBConst2>)
  401f2a:	6819      	ldr	r1, [r3, #0]
  401f2c:	6808      	ldr	r0, [r1, #0]
  401f2e:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401f32:	f380 8809 	msr	PSP, r0
  401f36:	f04f 0000 	mov.w	r0, #0
  401f3a:	f380 8811 	msr	BASEPRI, r0
  401f3e:	4770      	bx	lr

00401f40 <pxCurrentTCBConst2>:
  401f40:	20004d9c 	.word	0x20004d9c

00401f44 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  401f44:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401f48:	4b01      	ldr	r3, [pc, #4]	; (401f50 <vPortYieldFromISR+0xc>)
  401f4a:	601a      	str	r2, [r3, #0]
  401f4c:	4770      	bx	lr
  401f4e:	bf00      	nop
  401f50:	e000ed04 	.word	0xe000ed04

00401f54 <ulPortSetInterruptMask>:

/*-----------------------------------------------------------*/

__attribute__((naked)) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile \
  401f54:	f3ef 8011 	mrs	r0, BASEPRI
  401f58:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  401f5c:	f381 8811 	msr	BASEPRI, r1
  401f60:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	 * warnings. */
	return 0;
}
  401f62:	2000      	movs	r0, #0

00401f64 <vPortEnterCritical>:
}

/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  401f64:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
  401f66:	4b03      	ldr	r3, [pc, #12]	; (401f74 <vPortEnterCritical+0x10>)
  401f68:	4798      	blx	r3
	uxCriticalNesting++;
  401f6a:	4a03      	ldr	r2, [pc, #12]	; (401f78 <vPortEnterCritical+0x14>)
  401f6c:	6813      	ldr	r3, [r2, #0]
  401f6e:	3301      	adds	r3, #1
  401f70:	6013      	str	r3, [r2, #0]
  401f72:	bd08      	pop	{r3, pc}
  401f74:	00401f55 	.word	0x00401f55
  401f78:	20000014 	.word	0x20000014

00401f7c <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__((naked)) void vPortClearInterruptMask(
		unsigned long ulNewMaskValue )
{
	__asm volatile \
  401f7c:	f380 8811 	msr	BASEPRI, r0
  401f80:	4770      	bx	lr
  401f82:	bf00      	nop

00401f84 <vPortExitCritical>:
}

/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  401f84:	b508      	push	{r3, lr}
	uxCriticalNesting--;
  401f86:	4a04      	ldr	r2, [pc, #16]	; (401f98 <vPortExitCritical+0x14>)
  401f88:	6813      	ldr	r3, [r2, #0]
  401f8a:	3b01      	subs	r3, #1
  401f8c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  401f8e:	b913      	cbnz	r3, 401f96 <vPortExitCritical+0x12>
		portENABLE_INTERRUPTS();
  401f90:	2000      	movs	r0, #0
  401f92:	4b02      	ldr	r3, [pc, #8]	; (401f9c <vPortExitCritical+0x18>)
  401f94:	4798      	blx	r3
  401f96:	bd08      	pop	{r3, pc}
  401f98:	20000014 	.word	0x20000014
  401f9c:	00401f7d 	.word	0x00401f7d

00401fa0 <PendSV_Handler>:
/*void xPortPendSVHandler( void )*/
__attribute__((naked)) void PendSV_Handler( void )   /* ATMEL */
{
	/* This is a naked function. */

	__asm volatile
  401fa0:	f3ef 8009 	mrs	r0, PSP
  401fa4:	4b11      	ldr	r3, [pc, #68]	; (401fec <pxCurrentTCBConst>)
  401fa6:	681a      	ldr	r2, [r3, #0]
  401fa8:	f01e 0f10 	tst.w	lr, #16
  401fac:	bf08      	it	eq
  401fae:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  401fb2:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401fb6:	6010      	str	r0, [r2, #0]
  401fb8:	e92d 4008 	stmdb	sp!, {r3, lr}
  401fbc:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  401fc0:	f380 8811 	msr	BASEPRI, r0
  401fc4:	f001 f90a 	bl	4031dc <vTaskSwitchContext>
  401fc8:	f04f 0000 	mov.w	r0, #0
  401fcc:	f380 8811 	msr	BASEPRI, r0
  401fd0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  401fd4:	6819      	ldr	r1, [r3, #0]
  401fd6:	6808      	ldr	r0, [r1, #0]
  401fd8:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401fdc:	f01e 0f10 	tst.w	lr, #16
  401fe0:	bf08      	it	eq
  401fe2:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  401fe6:	f380 8809 	msr	PSP, r0
  401fea:	4770      	bx	lr

00401fec <pxCurrentTCBConst>:
  401fec:	20004d9c 	.word	0x20004d9c

00401ff0 <SysTick_Handler>:
	);
}

/*-----------------------------------------------------------*/
void SysTick_Handler( void ) /* ATMEL */
{
  401ff0:	b508      	push	{r3, lr}
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  401ff2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401ff6:	4b05      	ldr	r3, [pc, #20]	; (40200c <SysTick_Handler+0x1c>)
  401ff8:	601a      	str	r2, [r3, #0]
	#endif

	(void)portSET_INTERRUPT_MASK_FROM_ISR();
  401ffa:	4b05      	ldr	r3, [pc, #20]	; (402010 <SysTick_Handler+0x20>)
  401ffc:	4798      	blx	r3
	{
		vTaskIncrementTick();
  401ffe:	4b05      	ldr	r3, [pc, #20]	; (402014 <SysTick_Handler+0x24>)
  402000:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  402002:	2000      	movs	r0, #0
  402004:	4b04      	ldr	r3, [pc, #16]	; (402018 <SysTick_Handler+0x28>)
  402006:	4798      	blx	r3
  402008:	bd08      	pop	{r3, pc}
  40200a:	bf00      	nop
  40200c:	e000ed04 	.word	0xe000ed04
  402010:	00401f55 	.word	0x00401f55
  402014:	00402d05 	.word	0x00402d05
  402018:	00401f7d 	.word	0x00401f7d

0040201c <vPortSetupTimerInterrupt>:
 */
__attribute__((weak)) void vPortSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG
		= (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
  40201c:	4a03      	ldr	r2, [pc, #12]	; (40202c <vPortSetupTimerInterrupt+0x10>)
  40201e:	4b04      	ldr	r3, [pc, #16]	; (402030 <vPortSetupTimerInterrupt+0x14>)
  402020:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT |
  402022:	2207      	movs	r2, #7
  402024:	3b04      	subs	r3, #4
  402026:	601a      	str	r2, [r3, #0]
  402028:	4770      	bx	lr
  40202a:	bf00      	nop
  40202c:	0001d4bb 	.word	0x0001d4bb
  402030:	e000e014 	.word	0xe000e014

00402034 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
  402034:	b510      	push	{r4, lr}
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	* See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  402036:	4b0c      	ldr	r3, [pc, #48]	; (402068 <xPortStartScheduler+0x34>)
  402038:	681a      	ldr	r2, [r3, #0]
  40203a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  40203e:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  402040:	681a      	ldr	r2, [r3, #0]
  402042:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  402046:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	* here already. */
	vPortSetupTimerInterrupt();
  402048:	4b08      	ldr	r3, [pc, #32]	; (40206c <xPortStartScheduler+0x38>)
  40204a:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  40204c:	2400      	movs	r4, #0
  40204e:	4b08      	ldr	r3, [pc, #32]	; (402070 <xPortStartScheduler+0x3c>)
  402050:	601c      	str	r4, [r3, #0]

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
  402052:	4b08      	ldr	r3, [pc, #32]	; (402074 <xPortStartScheduler+0x40>)
  402054:	4798      	blx	r3
#endif

	/* Lazy save always. */
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
  402056:	4a08      	ldr	r2, [pc, #32]	; (402078 <xPortStartScheduler+0x44>)
  402058:	6813      	ldr	r3, [r2, #0]
  40205a:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  40205e:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  402060:	4b06      	ldr	r3, [pc, #24]	; (40207c <xPortStartScheduler+0x48>)
  402062:	4798      	blx	r3

	/* Should not get here! */
	return 0;
}
  402064:	4620      	mov	r0, r4
  402066:	bd10      	pop	{r4, pc}
  402068:	e000ed20 	.word	0xe000ed20
  40206c:	0040201d 	.word	0x0040201d
  402070:	20000014 	.word	0x20000014
  402074:	00401ef1 	.word	0x00401ef1
  402078:	e000ef34 	.word	0xe000ef34
  40207c:	00401edd 	.word	0x00401edd

00402080 <prvInsertBlockIntoFreeList>:
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  402080:	4a13      	ldr	r2, [pc, #76]	; (4020d0 <prvInsertBlockIntoFreeList+0x50>)
  402082:	e000      	b.n	402086 <prvInsertBlockIntoFreeList+0x6>
  402084:	461a      	mov	r2, r3
  402086:	6813      	ldr	r3, [r2, #0]
  402088:	4283      	cmp	r3, r0
  40208a:	d3fb      	bcc.n	402084 <prvInsertBlockIntoFreeList+0x4>
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  40208c:	b430      	push	{r4, r5}
  40208e:	4611      	mov	r1, r2
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  402090:	6854      	ldr	r4, [r2, #4]
  402092:	1915      	adds	r5, r2, r4
  402094:	4285      	cmp	r5, r0
  402096:	d103      	bne.n	4020a0 <prvInsertBlockIntoFreeList+0x20>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  402098:	6868      	ldr	r0, [r5, #4]
  40209a:	4404      	add	r4, r0
  40209c:	6054      	str	r4, [r2, #4]
  40209e:	4610      	mov	r0, r2
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  4020a0:	6842      	ldr	r2, [r0, #4]
  4020a2:	1884      	adds	r4, r0, r2
  4020a4:	429c      	cmp	r4, r3
  4020a6:	d10c      	bne.n	4020c2 <prvInsertBlockIntoFreeList+0x42>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  4020a8:	4b0a      	ldr	r3, [pc, #40]	; (4020d4 <prvInsertBlockIntoFreeList+0x54>)
  4020aa:	681b      	ldr	r3, [r3, #0]
  4020ac:	429c      	cmp	r4, r3
  4020ae:	d006      	beq.n	4020be <prvInsertBlockIntoFreeList+0x3e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  4020b0:	6863      	ldr	r3, [r4, #4]
  4020b2:	441a      	add	r2, r3
  4020b4:	6042      	str	r2, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  4020b6:	680b      	ldr	r3, [r1, #0]
  4020b8:	681b      	ldr	r3, [r3, #0]
  4020ba:	6003      	str	r3, [r0, #0]
  4020bc:	e002      	b.n	4020c4 <prvInsertBlockIntoFreeList+0x44>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  4020be:	6004      	str	r4, [r0, #0]
  4020c0:	e000      	b.n	4020c4 <prvInsertBlockIntoFreeList+0x44>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  4020c2:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  4020c4:	4281      	cmp	r1, r0
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  4020c6:	bf18      	it	ne
  4020c8:	6008      	strne	r0, [r1, #0]
	}
}
  4020ca:	bc30      	pop	{r4, r5}
  4020cc:	4770      	bx	lr
  4020ce:	bf00      	nop
  4020d0:	20004ce4 	.word	0x20004ce4
  4020d4:	20004ce0 	.word	0x20004ce0

004020d8 <pvPortMalloc>:
/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  4020d8:	b538      	push	{r3, r4, r5, lr}
  4020da:	4604      	mov	r4, r0
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
  4020dc:	4b2b      	ldr	r3, [pc, #172]	; (40218c <pvPortMalloc+0xb4>)
  4020de:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  4020e0:	4b2b      	ldr	r3, [pc, #172]	; (402190 <pvPortMalloc+0xb8>)
  4020e2:	681b      	ldr	r3, [r3, #0]
  4020e4:	b99b      	cbnz	r3, 40210e <pvPortMalloc+0x36>
	/* Ensure the start of the heap is aligned. */
	configASSERT( ( ( ( unsigned long ) xHeap.ucHeap ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
  4020e6:	4a2b      	ldr	r2, [pc, #172]	; (402194 <pvPortMalloc+0xbc>)
  4020e8:	4b2b      	ldr	r3, [pc, #172]	; (402198 <pvPortMalloc+0xc0>)
  4020ea:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
  4020ec:	2100      	movs	r1, #0
  4020ee:	6051      	str	r1, [r2, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = xHeap.ucHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
	pxEnd = ( void * ) pucHeapEnd;
  4020f0:	f643 72f0 	movw	r2, #16368	; 0x3ff0
  4020f4:	1898      	adds	r0, r3, r2
  4020f6:	4d26      	ldr	r5, [pc, #152]	; (402190 <pvPortMalloc+0xb8>)
  4020f8:	6028      	str	r0, [r5, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
	pxEnd->xBlockSize = 0;
  4020fa:	f643 75f4 	movw	r5, #16372	; 0x3ff4
  4020fe:	5159      	str	r1, [r3, r5]
	pxEnd->pxNextFreeBlock = NULL;
  402100:	5099      	str	r1, [r3, r2]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  402102:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  402104:	6018      	str	r0, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  402106:	4a25      	ldr	r2, [pc, #148]	; (40219c <pvPortMalloc+0xc4>)
  402108:	6813      	ldr	r3, [r2, #0]
  40210a:	3b10      	subs	r3, #16
  40210c:	6013      	str	r3, [r2, #0]
			prvHeapInit();
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
  40210e:	2c00      	cmp	r4, #0
  402110:	d037      	beq.n	402182 <pvPortMalloc+0xaa>
		{
			xWantedSize += heapSTRUCT_SIZE;
  402112:	f104 0210 	add.w	r2, r4, #16

			/* Ensure that blocks are always aligned to the required number of 
			bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  402116:	f012 0f07 	tst.w	r2, #7
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  40211a:	bf1c      	itt	ne
  40211c:	f022 0207 	bicne.w	r2, r2, #7
  402120:	3208      	addne	r2, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
  402122:	1e51      	subs	r1, r2, #1
  402124:	f643 73fe 	movw	r3, #16382	; 0x3ffe
  402128:	4299      	cmp	r1, r3
  40212a:	d827      	bhi.n	40217c <pvPortMalloc+0xa4>
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
  40212c:	4919      	ldr	r1, [pc, #100]	; (402194 <pvPortMalloc+0xbc>)
  40212e:	680c      	ldr	r4, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  402130:	e001      	b.n	402136 <pvPortMalloc+0x5e>
  402132:	4621      	mov	r1, r4
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
  402134:	461c      	mov	r4, r3
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  402136:	6863      	ldr	r3, [r4, #4]
  402138:	429a      	cmp	r2, r3
  40213a:	d902      	bls.n	402142 <pvPortMalloc+0x6a>
  40213c:	6823      	ldr	r3, [r4, #0]
  40213e:	2b00      	cmp	r3, #0
  402140:	d1f7      	bne.n	402132 <pvPortMalloc+0x5a>
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If the end marker was reached then a block of adequate size was
			not found. */
			if( pxBlock != pxEnd )
  402142:	4b13      	ldr	r3, [pc, #76]	; (402190 <pvPortMalloc+0xb8>)
  402144:	681b      	ldr	r3, [r3, #0]
  402146:	429c      	cmp	r4, r3
  402148:	d018      	beq.n	40217c <pvPortMalloc+0xa4>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  40214a:	680d      	ldr	r5, [r1, #0]
  40214c:	3510      	adds	r5, #16

				/* This block is being returned for use so must be taken out of
				the	list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  40214e:	6823      	ldr	r3, [r4, #0]
  402150:	600b      	str	r3, [r1, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  402152:	6863      	ldr	r3, [r4, #4]
  402154:	1a9b      	subs	r3, r3, r2
  402156:	2b20      	cmp	r3, #32
  402158:	d904      	bls.n	402164 <pvPortMalloc+0x8c>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  40215a:	18a0      	adds	r0, r4, r2

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  40215c:	6043      	str	r3, [r0, #4]
					pxBlock->xBlockSize = xWantedSize;
  40215e:	6062      	str	r2, [r4, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  402160:	4b0f      	ldr	r3, [pc, #60]	; (4021a0 <pvPortMalloc+0xc8>)
  402162:	4798      	blx	r3
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
  402164:	4a0d      	ldr	r2, [pc, #52]	; (40219c <pvPortMalloc+0xc4>)
  402166:	6813      	ldr	r3, [r2, #0]
  402168:	6861      	ldr	r1, [r4, #4]
  40216a:	1a5b      	subs	r3, r3, r1
  40216c:	6013      	str	r3, [r2, #0]
			}
		}
	}
	xTaskResumeAll();
  40216e:	4b0d      	ldr	r3, [pc, #52]	; (4021a4 <pvPortMalloc+0xcc>)
  402170:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
  402172:	b94d      	cbnz	r5, 402188 <pvPortMalloc+0xb0>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
  402174:	4b0c      	ldr	r3, [pc, #48]	; (4021a8 <pvPortMalloc+0xd0>)
  402176:	4798      	blx	r3
  402178:	2500      	movs	r5, #0
  40217a:	e005      	b.n	402188 <pvPortMalloc+0xb0>

				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
  40217c:	4b09      	ldr	r3, [pc, #36]	; (4021a4 <pvPortMalloc+0xcc>)
  40217e:	4798      	blx	r3
  402180:	e7f8      	b.n	402174 <pvPortMalloc+0x9c>
  402182:	4b08      	ldr	r3, [pc, #32]	; (4021a4 <pvPortMalloc+0xcc>)
  402184:	4798      	blx	r3
  402186:	e7f5      	b.n	402174 <pvPortMalloc+0x9c>
		}
	}
	#endif

	return pvReturn;
}
  402188:	4628      	mov	r0, r5
  40218a:	bd38      	pop	{r3, r4, r5, pc}
  40218c:	00402cb5 	.word	0x00402cb5
  402190:	20004ce0 	.word	0x20004ce0
  402194:	20004ce4 	.word	0x20004ce4
  402198:	20000ce0 	.word	0x20000ce0
  40219c:	20000018 	.word	0x20000018
  4021a0:	00402081 	.word	0x00402081
  4021a4:	00402e31 	.word	0x00402e31
  4021a8:	00403dc9 	.word	0x00403dc9

004021ac <vPortFree>:
void vPortFree( void *pv )
{
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv != NULL )
  4021ac:	b180      	cbz	r0, 4021d0 <vPortFree+0x24>
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  4021ae:	b510      	push	{r4, lr}
  4021b0:	4604      	mov	r4, r0
		puc -= heapSTRUCT_SIZE;

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
  4021b2:	4b08      	ldr	r3, [pc, #32]	; (4021d4 <vPortFree+0x28>)
  4021b4:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			xFreeBytesRemaining += pxLink->xBlockSize;
  4021b6:	4a08      	ldr	r2, [pc, #32]	; (4021d8 <vPortFree+0x2c>)
  4021b8:	6811      	ldr	r1, [r2, #0]
  4021ba:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  4021be:	440b      	add	r3, r1
  4021c0:	6013      	str	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
  4021c2:	f1a4 0010 	sub.w	r0, r4, #16
  4021c6:	4b05      	ldr	r3, [pc, #20]	; (4021dc <vPortFree+0x30>)
  4021c8:	4798      	blx	r3
		}
		xTaskResumeAll();
  4021ca:	4b05      	ldr	r3, [pc, #20]	; (4021e0 <vPortFree+0x34>)
  4021cc:	4798      	blx	r3
  4021ce:	bd10      	pop	{r4, pc}
  4021d0:	4770      	bx	lr
  4021d2:	bf00      	nop
  4021d4:	00402cb5 	.word	0x00402cb5
  4021d8:	20000018 	.word	0x20000018
  4021dc:	00402081 	.word	0x00402081
  4021e0:	00402e31 	.word	0x00402e31

004021e4 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  4021e4:	b510      	push	{r4, lr}
  4021e6:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  4021e8:	6c03      	ldr	r3, [r0, #64]	; 0x40
  4021ea:	b93b      	cbnz	r3, 4021fc <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4021ec:	6803      	ldr	r3, [r0, #0]
  4021ee:	bb1b      	cbnz	r3, 402238 <prvCopyDataToQueue+0x54>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  4021f0:	6840      	ldr	r0, [r0, #4]
  4021f2:	4b13      	ldr	r3, [pc, #76]	; (402240 <prvCopyDataToQueue+0x5c>)
  4021f4:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  4021f6:	2300      	movs	r3, #0
  4021f8:	6063      	str	r3, [r4, #4]
  4021fa:	e01d      	b.n	402238 <prvCopyDataToQueue+0x54>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
  4021fc:	b96a      	cbnz	r2, 40221a <prvCopyDataToQueue+0x36>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  4021fe:	6880      	ldr	r0, [r0, #8]
  402200:	461a      	mov	r2, r3
  402202:	4b10      	ldr	r3, [pc, #64]	; (402244 <prvCopyDataToQueue+0x60>)
  402204:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  402206:	68a2      	ldr	r2, [r4, #8]
  402208:	6c23      	ldr	r3, [r4, #64]	; 0x40
  40220a:	4413      	add	r3, r2
  40220c:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  40220e:	6862      	ldr	r2, [r4, #4]
  402210:	4293      	cmp	r3, r2
  402212:	d311      	bcc.n	402238 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  402214:	6823      	ldr	r3, [r4, #0]
  402216:	60a3      	str	r3, [r4, #8]
  402218:	e00e      	b.n	402238 <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  40221a:	68c0      	ldr	r0, [r0, #12]
  40221c:	461a      	mov	r2, r3
  40221e:	4b09      	ldr	r3, [pc, #36]	; (402244 <prvCopyDataToQueue+0x60>)
  402220:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  402222:	6c23      	ldr	r3, [r4, #64]	; 0x40
  402224:	425b      	negs	r3, r3
  402226:	68e2      	ldr	r2, [r4, #12]
  402228:	441a      	add	r2, r3
  40222a:	60e2      	str	r2, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  40222c:	6821      	ldr	r1, [r4, #0]
  40222e:	428a      	cmp	r2, r1
  402230:	d202      	bcs.n	402238 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  402232:	6862      	ldr	r2, [r4, #4]
  402234:	4413      	add	r3, r2
  402236:	60e3      	str	r3, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
  402238:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  40223a:	3301      	adds	r3, #1
  40223c:	63a3      	str	r3, [r4, #56]	; 0x38
  40223e:	bd10      	pop	{r4, pc}
  402240:	004035c9 	.word	0x004035c9
  402244:	004040a1 	.word	0x004040a1

00402248 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
  402248:	b538      	push	{r3, r4, r5, lr}
  40224a:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  40224c:	6800      	ldr	r0, [r0, #0]
  40224e:	b158      	cbz	r0, 402268 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  402250:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  402252:	68dc      	ldr	r4, [r3, #12]
  402254:	4414      	add	r4, r2
  402256:	60dc      	str	r4, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  402258:	685d      	ldr	r5, [r3, #4]
  40225a:	42ac      	cmp	r4, r5
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
  40225c:	bf28      	it	cs
  40225e:	60d8      	strcs	r0, [r3, #12]
  402260:	4608      	mov	r0, r1
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
  402262:	68d9      	ldr	r1, [r3, #12]
  402264:	4b01      	ldr	r3, [pc, #4]	; (40226c <prvCopyDataFromQueue+0x24>)
  402266:	4798      	blx	r3
  402268:	bd38      	pop	{r3, r4, r5, pc}
  40226a:	bf00      	nop
  40226c:	004040a1 	.word	0x004040a1

00402270 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
  402270:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402272:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  402274:	4b1e      	ldr	r3, [pc, #120]	; (4022f0 <prvUnlockQueue+0x80>)
  402276:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  402278:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40227a:	2b00      	cmp	r3, #0
  40227c:	dd13      	ble.n	4022a6 <prvUnlockQueue+0x36>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40227e:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402280:	b91b      	cbnz	r3, 40228a <prvUnlockQueue+0x1a>
  402282:	e010      	b.n	4022a6 <prvUnlockQueue+0x36>
  402284:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402286:	b923      	cbnz	r3, 402292 <prvUnlockQueue+0x22>
  402288:	e00d      	b.n	4022a6 <prvUnlockQueue+0x36>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40228a:	f104 0624 	add.w	r6, r4, #36	; 0x24
  40228e:	4d19      	ldr	r5, [pc, #100]	; (4022f4 <prvUnlockQueue+0x84>)
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  402290:	4f19      	ldr	r7, [pc, #100]	; (4022f8 <prvUnlockQueue+0x88>)
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  402292:	4630      	mov	r0, r6
  402294:	47a8      	blx	r5
  402296:	b100      	cbz	r0, 40229a <prvUnlockQueue+0x2a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  402298:	47b8      	blx	r7
				}

				--( pxQueue->xTxLock );
  40229a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40229c:	3b01      	subs	r3, #1
  40229e:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  4022a0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4022a2:	2b00      	cmp	r3, #0
  4022a4:	dcee      	bgt.n	402284 <prvUnlockQueue+0x14>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
  4022a6:	f04f 33ff 	mov.w	r3, #4294967295
  4022aa:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  4022ac:	4b13      	ldr	r3, [pc, #76]	; (4022fc <prvUnlockQueue+0x8c>)
  4022ae:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  4022b0:	4b0f      	ldr	r3, [pc, #60]	; (4022f0 <prvUnlockQueue+0x80>)
  4022b2:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4022b4:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4022b6:	2b00      	cmp	r3, #0
  4022b8:	dd13      	ble.n	4022e2 <prvUnlockQueue+0x72>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4022ba:	6923      	ldr	r3, [r4, #16]
  4022bc:	b91b      	cbnz	r3, 4022c6 <prvUnlockQueue+0x56>
  4022be:	e010      	b.n	4022e2 <prvUnlockQueue+0x72>
  4022c0:	6923      	ldr	r3, [r4, #16]
  4022c2:	b923      	cbnz	r3, 4022ce <prvUnlockQueue+0x5e>
  4022c4:	e00d      	b.n	4022e2 <prvUnlockQueue+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4022c6:	f104 0610 	add.w	r6, r4, #16
  4022ca:	4d0a      	ldr	r5, [pc, #40]	; (4022f4 <prvUnlockQueue+0x84>)
				{
					vTaskMissedYield();
  4022cc:	4f0a      	ldr	r7, [pc, #40]	; (4022f8 <prvUnlockQueue+0x88>)
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4022ce:	4630      	mov	r0, r6
  4022d0:	47a8      	blx	r5
  4022d2:	b100      	cbz	r0, 4022d6 <prvUnlockQueue+0x66>
				{
					vTaskMissedYield();
  4022d4:	47b8      	blx	r7
				}

				--( pxQueue->xRxLock );
  4022d6:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4022d8:	3b01      	subs	r3, #1
  4022da:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4022dc:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4022de:	2b00      	cmp	r3, #0
  4022e0:	dcee      	bgt.n	4022c0 <prvUnlockQueue+0x50>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  4022e2:	f04f 33ff 	mov.w	r3, #4294967295
  4022e6:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  4022e8:	4b04      	ldr	r3, [pc, #16]	; (4022fc <prvUnlockQueue+0x8c>)
  4022ea:	4798      	blx	r3
  4022ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4022ee:	bf00      	nop
  4022f0:	00401f65 	.word	0x00401f65
  4022f4:	004033b1 	.word	0x004033b1
  4022f8:	004034f5 	.word	0x004034f5
  4022fc:	00401f85 	.word	0x00401f85

00402300 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
  402300:	b538      	push	{r3, r4, r5, lr}
  402302:	460d      	mov	r5, r1
	configASSERT( pxQueue );
  402304:	4604      	mov	r4, r0
  402306:	b920      	cbnz	r0, 402312 <xQueueGenericReset+0x12>
  402308:	4817      	ldr	r0, [pc, #92]	; (402368 <xQueueGenericReset+0x68>)
  40230a:	f240 111b 	movw	r1, #283	; 0x11b
  40230e:	4b17      	ldr	r3, [pc, #92]	; (40236c <xQueueGenericReset+0x6c>)
  402310:	4798      	blx	r3

	taskENTER_CRITICAL();
  402312:	4b17      	ldr	r3, [pc, #92]	; (402370 <xQueueGenericReset+0x70>)
  402314:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  402316:	6822      	ldr	r2, [r4, #0]
  402318:	6c21      	ldr	r1, [r4, #64]	; 0x40
  40231a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40231c:	fb03 f301 	mul.w	r3, r3, r1
  402320:	18d0      	adds	r0, r2, r3
  402322:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  402324:	2000      	movs	r0, #0
  402326:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  402328:	60a2      	str	r2, [r4, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  40232a:	1a5b      	subs	r3, r3, r1
  40232c:	4413      	add	r3, r2
  40232e:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  402330:	f04f 33ff 	mov.w	r3, #4294967295
  402334:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  402336:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  402338:	b955      	cbnz	r5, 402350 <xQueueGenericReset+0x50>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  40233a:	6923      	ldr	r3, [r4, #16]
  40233c:	b17b      	cbz	r3, 40235e <xQueueGenericReset+0x5e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  40233e:	f104 0010 	add.w	r0, r4, #16
  402342:	4b0c      	ldr	r3, [pc, #48]	; (402374 <xQueueGenericReset+0x74>)
  402344:	4798      	blx	r3
  402346:	2801      	cmp	r0, #1
  402348:	d109      	bne.n	40235e <xQueueGenericReset+0x5e>
				{
					portYIELD_WITHIN_API();
  40234a:	4b0b      	ldr	r3, [pc, #44]	; (402378 <xQueueGenericReset+0x78>)
  40234c:	4798      	blx	r3
  40234e:	e006      	b.n	40235e <xQueueGenericReset+0x5e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  402350:	f104 0010 	add.w	r0, r4, #16
  402354:	4d09      	ldr	r5, [pc, #36]	; (40237c <xQueueGenericReset+0x7c>)
  402356:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  402358:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40235c:	47a8      	blx	r5
		}
	}
	taskEXIT_CRITICAL();
  40235e:	4b08      	ldr	r3, [pc, #32]	; (402380 <xQueueGenericReset+0x80>)
  402360:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
  402362:	2001      	movs	r0, #1
  402364:	bd38      	pop	{r3, r4, r5, pc}
  402366:	bf00      	nop
  402368:	00409978 	.word	0x00409978
  40236c:	00403de1 	.word	0x00403de1
  402370:	00401f65 	.word	0x00401f65
  402374:	004033b1 	.word	0x004033b1
  402378:	00401f45 	.word	0x00401f45
  40237c:	00401e3d 	.word	0x00401e3d
  402380:	00401f85 	.word	0x00401f85

00402384 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
  402384:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  402386:	b1d0      	cbz	r0, 4023be <xQueueGenericCreate+0x3a>
  402388:	460d      	mov	r5, r1
  40238a:	4617      	mov	r7, r2
  40238c:	4606      	mov	r6, r0
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  40238e:	2050      	movs	r0, #80	; 0x50
  402390:	4b0f      	ldr	r3, [pc, #60]	; (4023d0 <xQueueGenericCreate+0x4c>)
  402392:	4798      	blx	r3
		if( pxNewQueue != NULL )
  402394:	4604      	mov	r4, r0
  402396:	b190      	cbz	r0, 4023be <xQueueGenericCreate+0x3a>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  402398:	fb05 f006 	mul.w	r0, r5, r6

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  40239c:	3001      	adds	r0, #1
  40239e:	4b0c      	ldr	r3, [pc, #48]	; (4023d0 <xQueueGenericCreate+0x4c>)
  4023a0:	4798      	blx	r3
  4023a2:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
  4023a4:	b140      	cbz	r0, 4023b8 <xQueueGenericCreate+0x34>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
  4023a6:	63e6      	str	r6, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  4023a8:	6425      	str	r5, [r4, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
  4023aa:	4620      	mov	r0, r4
  4023ac:	2101      	movs	r1, #1
  4023ae:	4b09      	ldr	r3, [pc, #36]	; (4023d4 <xQueueGenericCreate+0x50>)
  4023b0:	4798      	blx	r3
				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
  4023b2:	f884 704d 	strb.w	r7, [r4, #77]	; 0x4d
  4023b6:	e008      	b.n	4023ca <xQueueGenericCreate+0x46>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
  4023b8:	4620      	mov	r0, r4
  4023ba:	4b07      	ldr	r3, [pc, #28]	; (4023d8 <xQueueGenericCreate+0x54>)
  4023bc:	4798      	blx	r3
			}
		}
	}

	configASSERT( xReturn );
  4023be:	4807      	ldr	r0, [pc, #28]	; (4023dc <xQueueGenericCreate+0x58>)
  4023c0:	f240 1171 	movw	r1, #369	; 0x171
  4023c4:	4b06      	ldr	r3, [pc, #24]	; (4023e0 <xQueueGenericCreate+0x5c>)
  4023c6:	4798      	blx	r3
  4023c8:	2400      	movs	r4, #0

	return xReturn;
}
  4023ca:	4620      	mov	r0, r4
  4023cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4023ce:	bf00      	nop
  4023d0:	004020d9 	.word	0x004020d9
  4023d4:	00402301 	.word	0x00402301
  4023d8:	004021ad 	.word	0x004021ad
  4023dc:	00409978 	.word	0x00409978
  4023e0:	00403de1 	.word	0x00403de1

004023e4 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
  4023e4:	b538      	push	{r3, r4, r5, lr}
  4023e6:	460d      	mov	r5, r1
	xQueueHandle pxHandle;

		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
  4023e8:	2100      	movs	r1, #0
  4023ea:	2202      	movs	r2, #2
  4023ec:	4b06      	ldr	r3, [pc, #24]	; (402408 <xQueueCreateCountingSemaphore+0x24>)
  4023ee:	4798      	blx	r3

		if( pxHandle != NULL )
  4023f0:	4604      	mov	r4, r0
  4023f2:	b108      	cbz	r0, 4023f8 <xQueueCreateCountingSemaphore+0x14>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
  4023f4:	6385      	str	r5, [r0, #56]	; 0x38
  4023f6:	e004      	b.n	402402 <xQueueCreateCountingSemaphore+0x1e>
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
  4023f8:	4804      	ldr	r0, [pc, #16]	; (40240c <xQueueCreateCountingSemaphore+0x28>)
  4023fa:	f44f 710f 	mov.w	r1, #572	; 0x23c
  4023fe:	4b04      	ldr	r3, [pc, #16]	; (402410 <xQueueCreateCountingSemaphore+0x2c>)
  402400:	4798      	blx	r3
		return pxHandle;
	}
  402402:	4620      	mov	r0, r4
  402404:	bd38      	pop	{r3, r4, r5, pc}
  402406:	bf00      	nop
  402408:	00402385 	.word	0x00402385
  40240c:	00409978 	.word	0x00409978
  402410:	00403de1 	.word	0x00403de1

00402414 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  402414:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402418:	b085      	sub	sp, #20
  40241a:	468b      	mov	fp, r1
  40241c:	9201      	str	r2, [sp, #4]
  40241e:	9300      	str	r3, [sp, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;

	configASSERT( pxQueue );
  402420:	4604      	mov	r4, r0
  402422:	b920      	cbnz	r0, 40242e <xQueueGenericSend+0x1a>
  402424:	483a      	ldr	r0, [pc, #232]	; (402510 <xQueueGenericSend+0xfc>)
  402426:	f44f 7112 	mov.w	r1, #584	; 0x248
  40242a:	4b3a      	ldr	r3, [pc, #232]	; (402514 <xQueueGenericSend+0x100>)
  40242c:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  40242e:	f1bb 0f00 	cmp.w	fp, #0
  402432:	d106      	bne.n	402442 <xQueueGenericSend+0x2e>
  402434:	6c23      	ldr	r3, [r4, #64]	; 0x40
  402436:	b123      	cbz	r3, 402442 <xQueueGenericSend+0x2e>
  402438:	4835      	ldr	r0, [pc, #212]	; (402510 <xQueueGenericSend+0xfc>)
  40243a:	f240 2149 	movw	r1, #585	; 0x249
  40243e:	4b35      	ldr	r3, [pc, #212]	; (402514 <xQueueGenericSend+0x100>)
  402440:	4798      	blx	r3

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  402442:	f04f 0900 	mov.w	r9, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  402446:	4d34      	ldr	r5, [pc, #208]	; (402518 <xQueueGenericSend+0x104>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  402448:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 402540 <xQueueGenericSend+0x12c>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  40244c:	4e33      	ldr	r6, [pc, #204]	; (40251c <xQueueGenericSend+0x108>)
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  40244e:	47a8      	blx	r5
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  402450:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  402452:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  402454:	429a      	cmp	r2, r3
  402456:	d212      	bcs.n	40247e <xQueueGenericSend+0x6a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  402458:	4620      	mov	r0, r4
  40245a:	4659      	mov	r1, fp
  40245c:	9a00      	ldr	r2, [sp, #0]
  40245e:	4b30      	ldr	r3, [pc, #192]	; (402520 <xQueueGenericSend+0x10c>)
  402460:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  402462:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402464:	b13b      	cbz	r3, 402476 <xQueueGenericSend+0x62>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  402466:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40246a:	4b2e      	ldr	r3, [pc, #184]	; (402524 <xQueueGenericSend+0x110>)
  40246c:	4798      	blx	r3
  40246e:	2801      	cmp	r0, #1
  402470:	d101      	bne.n	402476 <xQueueGenericSend+0x62>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
  402472:	4b2d      	ldr	r3, [pc, #180]	; (402528 <xQueueGenericSend+0x114>)
  402474:	4798      	blx	r3
					}
				}

				taskEXIT_CRITICAL();
  402476:	4b29      	ldr	r3, [pc, #164]	; (40251c <xQueueGenericSend+0x108>)
  402478:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  40247a:	2001      	movs	r0, #1
  40247c:	e044      	b.n	402508 <xQueueGenericSend+0xf4>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  40247e:	9b01      	ldr	r3, [sp, #4]
  402480:	b91b      	cbnz	r3, 40248a <xQueueGenericSend+0x76>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  402482:	4b26      	ldr	r3, [pc, #152]	; (40251c <xQueueGenericSend+0x108>)
  402484:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  402486:	2000      	movs	r0, #0
  402488:	e03e      	b.n	402508 <xQueueGenericSend+0xf4>
				}
				else if( xEntryTimeSet == pdFALSE )
  40248a:	f1b9 0f00 	cmp.w	r9, #0
  40248e:	d103      	bne.n	402498 <xQueueGenericSend+0x84>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  402490:	a802      	add	r0, sp, #8
  402492:	47d0      	blx	sl
					xEntryTimeSet = pdTRUE;
  402494:	f04f 0901 	mov.w	r9, #1
				}
			}
		}
		taskEXIT_CRITICAL();
  402498:	47b0      	blx	r6

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  40249a:	4b24      	ldr	r3, [pc, #144]	; (40252c <xQueueGenericSend+0x118>)
  40249c:	4798      	blx	r3
		prvLockQueue( pxQueue );
  40249e:	47a8      	blx	r5
  4024a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4024a2:	f1b3 3fff 	cmp.w	r3, #4294967295
  4024a6:	bf04      	itt	eq
  4024a8:	2300      	moveq	r3, #0
  4024aa:	6463      	streq	r3, [r4, #68]	; 0x44
  4024ac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4024ae:	f1b3 3fff 	cmp.w	r3, #4294967295
  4024b2:	bf04      	itt	eq
  4024b4:	2300      	moveq	r3, #0
  4024b6:	64a3      	streq	r3, [r4, #72]	; 0x48
  4024b8:	47b0      	blx	r6

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  4024ba:	a802      	add	r0, sp, #8
  4024bc:	a901      	add	r1, sp, #4
  4024be:	4b1c      	ldr	r3, [pc, #112]	; (402530 <xQueueGenericSend+0x11c>)
  4024c0:	4798      	blx	r3
  4024c2:	b9d8      	cbnz	r0, 4024fc <xQueueGenericSend+0xe8>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  4024c4:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  4024c6:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
  4024ca:	6be7      	ldr	r7, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  4024cc:	47b0      	blx	r6
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  4024ce:	45b8      	cmp	r8, r7
  4024d0:	d10e      	bne.n	4024f0 <xQueueGenericSend+0xdc>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  4024d2:	f104 0010 	add.w	r0, r4, #16
  4024d6:	9901      	ldr	r1, [sp, #4]
  4024d8:	4b16      	ldr	r3, [pc, #88]	; (402534 <xQueueGenericSend+0x120>)
  4024da:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  4024dc:	4620      	mov	r0, r4
  4024de:	4b16      	ldr	r3, [pc, #88]	; (402538 <xQueueGenericSend+0x124>)
  4024e0:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  4024e2:	4b16      	ldr	r3, [pc, #88]	; (40253c <xQueueGenericSend+0x128>)
  4024e4:	4798      	blx	r3
  4024e6:	2800      	cmp	r0, #0
  4024e8:	d1b1      	bne.n	40244e <xQueueGenericSend+0x3a>
				{
					portYIELD_WITHIN_API();
  4024ea:	4b0f      	ldr	r3, [pc, #60]	; (402528 <xQueueGenericSend+0x114>)
  4024ec:	4798      	blx	r3
  4024ee:	e7ae      	b.n	40244e <xQueueGenericSend+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4024f0:	4620      	mov	r0, r4
  4024f2:	4b11      	ldr	r3, [pc, #68]	; (402538 <xQueueGenericSend+0x124>)
  4024f4:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4024f6:	4b11      	ldr	r3, [pc, #68]	; (40253c <xQueueGenericSend+0x128>)
  4024f8:	4798      	blx	r3
  4024fa:	e7a8      	b.n	40244e <xQueueGenericSend+0x3a>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  4024fc:	4620      	mov	r0, r4
  4024fe:	4b0e      	ldr	r3, [pc, #56]	; (402538 <xQueueGenericSend+0x124>)
  402500:	4798      	blx	r3
			( void ) xTaskResumeAll();
  402502:	4b0e      	ldr	r3, [pc, #56]	; (40253c <xQueueGenericSend+0x128>)
  402504:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  402506:	2000      	movs	r0, #0
		}
	}
}
  402508:	b005      	add	sp, #20
  40250a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40250e:	bf00      	nop
  402510:	00409978 	.word	0x00409978
  402514:	00403de1 	.word	0x00403de1
  402518:	00401f65 	.word	0x00401f65
  40251c:	00401f85 	.word	0x00401f85
  402520:	004021e5 	.word	0x004021e5
  402524:	004033b1 	.word	0x004033b1
  402528:	00401f45 	.word	0x00401f45
  40252c:	00402cb5 	.word	0x00402cb5
  402530:	00403469 	.word	0x00403469
  402534:	004032c5 	.word	0x004032c5
  402538:	00402271 	.word	0x00402271
  40253c:	00402e31 	.word	0x00402e31
  402540:	00403439 	.word	0x00403439

00402544 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
  402544:	b570      	push	{r4, r5, r6, lr}
  402546:	4606      	mov	r6, r0
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  402548:	2050      	movs	r0, #80	; 0x50
  40254a:	4b13      	ldr	r3, [pc, #76]	; (402598 <xQueueCreateMutex+0x54>)
  40254c:	4798      	blx	r3
		if( pxNewQueue != NULL )
  40254e:	4604      	mov	r4, r0
  402550:	b1d8      	cbz	r0, 40258a <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
  402552:	2500      	movs	r5, #0
  402554:	6045      	str	r5, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  402556:	6005      	str	r5, [r0, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
  402558:	6085      	str	r5, [r0, #8]
			pxNewQueue->pcReadFrom = NULL;
  40255a:	60c5      	str	r5, [r0, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  40255c:	6385      	str	r5, [r0, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
  40255e:	2301      	movs	r3, #1
  402560:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
  402562:	6405      	str	r5, [r0, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
  402564:	f04f 33ff 	mov.w	r3, #4294967295
  402568:	6443      	str	r3, [r0, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
  40256a:	6483      	str	r3, [r0, #72]	; 0x48

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
  40256c:	f880 604d 	strb.w	r6, [r0, #77]	; 0x4d
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
  402570:	3010      	adds	r0, #16
  402572:	4e0a      	ldr	r6, [pc, #40]	; (40259c <xQueueCreateMutex+0x58>)
  402574:	47b0      	blx	r6
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
  402576:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40257a:	47b0      	blx	r6

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
  40257c:	4620      	mov	r0, r4
  40257e:	4629      	mov	r1, r5
  402580:	462a      	mov	r2, r5
  402582:	462b      	mov	r3, r5
  402584:	4d06      	ldr	r5, [pc, #24]	; (4025a0 <xQueueCreateMutex+0x5c>)
  402586:	47a8      	blx	r5
  402588:	e004      	b.n	402594 <xQueueCreateMutex+0x50>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
  40258a:	4806      	ldr	r0, [pc, #24]	; (4025a4 <xQueueCreateMutex+0x60>)
  40258c:	f240 11ab 	movw	r1, #427	; 0x1ab
  402590:	4b05      	ldr	r3, [pc, #20]	; (4025a8 <xQueueCreateMutex+0x64>)
  402592:	4798      	blx	r3
		return pxNewQueue;
	}
  402594:	4620      	mov	r0, r4
  402596:	bd70      	pop	{r4, r5, r6, pc}
  402598:	004020d9 	.word	0x004020d9
  40259c:	00401e3d 	.word	0x00401e3d
  4025a0:	00402415 	.word	0x00402415
  4025a4:	00409978 	.word	0x00409978
  4025a8:	00403de1 	.word	0x00403de1

004025ac <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  4025ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4025b0:	460d      	mov	r5, r1
  4025b2:	4617      	mov	r7, r2
  4025b4:	4698      	mov	r8, r3
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
  4025b6:	4604      	mov	r4, r0
  4025b8:	b920      	cbnz	r0, 4025c4 <xQueueGenericSendFromISR+0x18>
  4025ba:	481d      	ldr	r0, [pc, #116]	; (402630 <xQueueGenericSendFromISR+0x84>)
  4025bc:	f240 318f 	movw	r1, #911	; 0x38f
  4025c0:	4b1c      	ldr	r3, [pc, #112]	; (402634 <xQueueGenericSendFromISR+0x88>)
  4025c2:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  4025c4:	b935      	cbnz	r5, 4025d4 <xQueueGenericSendFromISR+0x28>
  4025c6:	6c23      	ldr	r3, [r4, #64]	; 0x40
  4025c8:	b123      	cbz	r3, 4025d4 <xQueueGenericSendFromISR+0x28>
  4025ca:	4819      	ldr	r0, [pc, #100]	; (402630 <xQueueGenericSendFromISR+0x84>)
  4025cc:	f44f 7164 	mov.w	r1, #912	; 0x390
  4025d0:	4b18      	ldr	r3, [pc, #96]	; (402634 <xQueueGenericSendFromISR+0x88>)
  4025d2:	4798      	blx	r3
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  4025d4:	4b18      	ldr	r3, [pc, #96]	; (402638 <xQueueGenericSendFromISR+0x8c>)
  4025d6:	4798      	blx	r3
  4025d8:	4606      	mov	r6, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  4025da:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4025dc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  4025de:	429a      	cmp	r2, r3
  4025e0:	d218      	bcs.n	402614 <xQueueGenericSendFromISR+0x68>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4025e2:	4620      	mov	r0, r4
  4025e4:	4629      	mov	r1, r5
  4025e6:	4642      	mov	r2, r8
  4025e8:	4b14      	ldr	r3, [pc, #80]	; (40263c <xQueueGenericSendFromISR+0x90>)
  4025ea:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  4025ec:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4025ee:	f1b3 3fff 	cmp.w	r3, #4294967295
  4025f2:	d10a      	bne.n	40260a <xQueueGenericSendFromISR+0x5e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4025f4:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4025f6:	b17b      	cbz	r3, 402618 <xQueueGenericSendFromISR+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4025f8:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4025fc:	4b10      	ldr	r3, [pc, #64]	; (402640 <xQueueGenericSendFromISR+0x94>)
  4025fe:	4798      	blx	r3
  402600:	b160      	cbz	r0, 40261c <xQueueGenericSendFromISR+0x70>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
  402602:	b16f      	cbz	r7, 402620 <xQueueGenericSendFromISR+0x74>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  402604:	2401      	movs	r4, #1
  402606:	603c      	str	r4, [r7, #0]
  402608:	e00b      	b.n	402622 <xQueueGenericSendFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  40260a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40260c:	3301      	adds	r3, #1
  40260e:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
  402610:	2401      	movs	r4, #1
  402612:	e006      	b.n	402622 <xQueueGenericSendFromISR+0x76>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  402614:	2400      	movs	r4, #0
  402616:	e004      	b.n	402622 <xQueueGenericSendFromISR+0x76>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
  402618:	2401      	movs	r4, #1
  40261a:	e002      	b.n	402622 <xQueueGenericSendFromISR+0x76>
  40261c:	2401      	movs	r4, #1
  40261e:	e000      	b.n	402622 <xQueueGenericSendFromISR+0x76>
  402620:	2401      	movs	r4, #1
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  402622:	4630      	mov	r0, r6
  402624:	4b07      	ldr	r3, [pc, #28]	; (402644 <xQueueGenericSendFromISR+0x98>)
  402626:	4798      	blx	r3

	return xReturn;
}
  402628:	4620      	mov	r0, r4
  40262a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40262e:	bf00      	nop
  402630:	00409978 	.word	0x00409978
  402634:	00403de1 	.word	0x00403de1
  402638:	00401f55 	.word	0x00401f55
  40263c:	004021e5 	.word	0x004021e5
  402640:	004033b1 	.word	0x004033b1
  402644:	00401f7d 	.word	0x00401f7d

00402648 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  402648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40264c:	b085      	sub	sp, #20
  40264e:	4689      	mov	r9, r1
  402650:	9201      	str	r2, [sp, #4]
  402652:	469a      	mov	sl, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;

	configASSERT( pxQueue );
  402654:	4604      	mov	r4, r0
  402656:	b920      	cbnz	r0, 402662 <xQueueGenericReceive+0x1a>
  402658:	4845      	ldr	r0, [pc, #276]	; (402770 <xQueueGenericReceive+0x128>)
  40265a:	f240 31cb 	movw	r1, #971	; 0x3cb
  40265e:	4b45      	ldr	r3, [pc, #276]	; (402774 <xQueueGenericReceive+0x12c>)
  402660:	4798      	blx	r3
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  402662:	f1b9 0f00 	cmp.w	r9, #0
  402666:	d106      	bne.n	402676 <xQueueGenericReceive+0x2e>
  402668:	6c23      	ldr	r3, [r4, #64]	; 0x40
  40266a:	b123      	cbz	r3, 402676 <xQueueGenericReceive+0x2e>
  40266c:	4840      	ldr	r0, [pc, #256]	; (402770 <xQueueGenericReceive+0x128>)
  40266e:	f44f 7173 	mov.w	r1, #972	; 0x3cc
  402672:	4b40      	ldr	r3, [pc, #256]	; (402774 <xQueueGenericReceive+0x12c>)
  402674:	4798      	blx	r3
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  402676:	2700      	movs	r7, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  402678:	4d3f      	ldr	r5, [pc, #252]	; (402778 <xQueueGenericReceive+0x130>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  40267a:	f8df 812c 	ldr.w	r8, [pc, #300]	; 4027a8 <xQueueGenericReceive+0x160>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  40267e:	4e3f      	ldr	r6, [pc, #252]	; (40277c <xQueueGenericReceive+0x134>)
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  402680:	47a8      	blx	r5
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  402682:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  402684:	b343      	cbz	r3, 4026d8 <xQueueGenericReceive+0x90>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
  402686:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  402688:	4620      	mov	r0, r4
  40268a:	4649      	mov	r1, r9
  40268c:	4b3c      	ldr	r3, [pc, #240]	; (402780 <xQueueGenericReceive+0x138>)
  40268e:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  402690:	f1ba 0f00 	cmp.w	sl, #0
  402694:	d112      	bne.n	4026bc <xQueueGenericReceive+0x74>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  402696:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  402698:	3b01      	subs	r3, #1
  40269a:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40269c:	6823      	ldr	r3, [r4, #0]
  40269e:	b913      	cbnz	r3, 4026a6 <xQueueGenericReceive+0x5e>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
  4026a0:	4b38      	ldr	r3, [pc, #224]	; (402784 <xQueueGenericReceive+0x13c>)
  4026a2:	4798      	blx	r3
  4026a4:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4026a6:	6923      	ldr	r3, [r4, #16]
  4026a8:	b193      	cbz	r3, 4026d0 <xQueueGenericReceive+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  4026aa:	f104 0010 	add.w	r0, r4, #16
  4026ae:	4b36      	ldr	r3, [pc, #216]	; (402788 <xQueueGenericReceive+0x140>)
  4026b0:	4798      	blx	r3
  4026b2:	2801      	cmp	r0, #1
  4026b4:	d10c      	bne.n	4026d0 <xQueueGenericReceive+0x88>
						{
							portYIELD_WITHIN_API();
  4026b6:	4b35      	ldr	r3, [pc, #212]	; (40278c <xQueueGenericReceive+0x144>)
  4026b8:	4798      	blx	r3
  4026ba:	e009      	b.n	4026d0 <xQueueGenericReceive+0x88>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
  4026bc:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4026be:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4026c0:	b133      	cbz	r3, 4026d0 <xQueueGenericReceive+0x88>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4026c2:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4026c6:	4b30      	ldr	r3, [pc, #192]	; (402788 <xQueueGenericReceive+0x140>)
  4026c8:	4798      	blx	r3
  4026ca:	b108      	cbz	r0, 4026d0 <xQueueGenericReceive+0x88>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
  4026cc:	4b2f      	ldr	r3, [pc, #188]	; (40278c <xQueueGenericReceive+0x144>)
  4026ce:	4798      	blx	r3
						}
					}
				}

				taskEXIT_CRITICAL();
  4026d0:	4b2a      	ldr	r3, [pc, #168]	; (40277c <xQueueGenericReceive+0x134>)
  4026d2:	4798      	blx	r3
				return pdPASS;
  4026d4:	2001      	movs	r0, #1
  4026d6:	e048      	b.n	40276a <xQueueGenericReceive+0x122>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  4026d8:	9b01      	ldr	r3, [sp, #4]
  4026da:	b91b      	cbnz	r3, 4026e4 <xQueueGenericReceive+0x9c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  4026dc:	4b27      	ldr	r3, [pc, #156]	; (40277c <xQueueGenericReceive+0x134>)
  4026de:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  4026e0:	2000      	movs	r0, #0
  4026e2:	e042      	b.n	40276a <xQueueGenericReceive+0x122>
				}
				else if( xEntryTimeSet == pdFALSE )
  4026e4:	b917      	cbnz	r7, 4026ec <xQueueGenericReceive+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  4026e6:	a802      	add	r0, sp, #8
  4026e8:	47c0      	blx	r8
					xEntryTimeSet = pdTRUE;
  4026ea:	2701      	movs	r7, #1
				}
			}
		}
		taskEXIT_CRITICAL();
  4026ec:	47b0      	blx	r6

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4026ee:	4b28      	ldr	r3, [pc, #160]	; (402790 <xQueueGenericReceive+0x148>)
  4026f0:	4798      	blx	r3
		prvLockQueue( pxQueue );
  4026f2:	47a8      	blx	r5
  4026f4:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4026f6:	f1b3 3fff 	cmp.w	r3, #4294967295
  4026fa:	bf04      	itt	eq
  4026fc:	2300      	moveq	r3, #0
  4026fe:	6463      	streq	r3, [r4, #68]	; 0x44
  402700:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  402702:	f1b3 3fff 	cmp.w	r3, #4294967295
  402706:	bf04      	itt	eq
  402708:	2300      	moveq	r3, #0
  40270a:	64a3      	streq	r3, [r4, #72]	; 0x48
  40270c:	47b0      	blx	r6

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40270e:	a802      	add	r0, sp, #8
  402710:	a901      	add	r1, sp, #4
  402712:	4b20      	ldr	r3, [pc, #128]	; (402794 <xQueueGenericReceive+0x14c>)
  402714:	4798      	blx	r3
  402716:	bb10      	cbnz	r0, 40275e <xQueueGenericReceive+0x116>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  402718:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
  40271a:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  40271e:	47b0      	blx	r6
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  402720:	f1bb 0f00 	cmp.w	fp, #0
  402724:	d115      	bne.n	402752 <xQueueGenericReceive+0x10a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  402726:	6823      	ldr	r3, [r4, #0]
  402728:	b923      	cbnz	r3, 402734 <xQueueGenericReceive+0xec>
					{
						portENTER_CRITICAL();
  40272a:	47a8      	blx	r5
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  40272c:	6860      	ldr	r0, [r4, #4]
  40272e:	4b1a      	ldr	r3, [pc, #104]	; (402798 <xQueueGenericReceive+0x150>)
  402730:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  402732:	47b0      	blx	r6
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  402734:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402738:	9901      	ldr	r1, [sp, #4]
  40273a:	4b18      	ldr	r3, [pc, #96]	; (40279c <xQueueGenericReceive+0x154>)
  40273c:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  40273e:	4620      	mov	r0, r4
  402740:	4b17      	ldr	r3, [pc, #92]	; (4027a0 <xQueueGenericReceive+0x158>)
  402742:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  402744:	4b17      	ldr	r3, [pc, #92]	; (4027a4 <xQueueGenericReceive+0x15c>)
  402746:	4798      	blx	r3
  402748:	2800      	cmp	r0, #0
  40274a:	d199      	bne.n	402680 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
  40274c:	4b0f      	ldr	r3, [pc, #60]	; (40278c <xQueueGenericReceive+0x144>)
  40274e:	4798      	blx	r3
  402750:	e796      	b.n	402680 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  402752:	4620      	mov	r0, r4
  402754:	4b12      	ldr	r3, [pc, #72]	; (4027a0 <xQueueGenericReceive+0x158>)
  402756:	4798      	blx	r3
				( void ) xTaskResumeAll();
  402758:	4b12      	ldr	r3, [pc, #72]	; (4027a4 <xQueueGenericReceive+0x15c>)
  40275a:	4798      	blx	r3
  40275c:	e790      	b.n	402680 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  40275e:	4620      	mov	r0, r4
  402760:	4b0f      	ldr	r3, [pc, #60]	; (4027a0 <xQueueGenericReceive+0x158>)
  402762:	4798      	blx	r3
			( void ) xTaskResumeAll();
  402764:	4b0f      	ldr	r3, [pc, #60]	; (4027a4 <xQueueGenericReceive+0x15c>)
  402766:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  402768:	2000      	movs	r0, #0
		}
	}
}
  40276a:	b005      	add	sp, #20
  40276c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402770:	00409978 	.word	0x00409978
  402774:	00403de1 	.word	0x00403de1
  402778:	00401f65 	.word	0x00401f65
  40277c:	00401f85 	.word	0x00401f85
  402780:	00402249 	.word	0x00402249
  402784:	00403501 	.word	0x00403501
  402788:	004033b1 	.word	0x004033b1
  40278c:	00401f45 	.word	0x00401f45
  402790:	00402cb5 	.word	0x00402cb5
  402794:	00403469 	.word	0x00403469
  402798:	0040352d 	.word	0x0040352d
  40279c:	004032c5 	.word	0x004032c5
  4027a0:	00402271 	.word	0x00402271
  4027a4:	00402e31 	.word	0x00402e31
  4027a8:	00403439 	.word	0x00403439

004027ac <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
  4027ac:	b538      	push	{r3, r4, r5, lr}
  4027ae:	4604      	mov	r4, r0
  4027b0:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  4027b2:	4b0d      	ldr	r3, [pc, #52]	; (4027e8 <vQueueWaitForMessageRestricted+0x3c>)
  4027b4:	4798      	blx	r3
  4027b6:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4027b8:	f1b3 3fff 	cmp.w	r3, #4294967295
  4027bc:	bf04      	itt	eq
  4027be:	2300      	moveq	r3, #0
  4027c0:	6463      	streq	r3, [r4, #68]	; 0x44
  4027c2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4027c4:	f1b3 3fff 	cmp.w	r3, #4294967295
  4027c8:	bf04      	itt	eq
  4027ca:	2300      	moveq	r3, #0
  4027cc:	64a3      	streq	r3, [r4, #72]	; 0x48
  4027ce:	4b07      	ldr	r3, [pc, #28]	; (4027ec <vQueueWaitForMessageRestricted+0x40>)
  4027d0:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
  4027d2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4027d4:	b923      	cbnz	r3, 4027e0 <vQueueWaitForMessageRestricted+0x34>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  4027d6:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4027da:	4629      	mov	r1, r5
  4027dc:	4b04      	ldr	r3, [pc, #16]	; (4027f0 <vQueueWaitForMessageRestricted+0x44>)
  4027de:	4798      	blx	r3
		}
		prvUnlockQueue( pxQueue );
  4027e0:	4620      	mov	r0, r4
  4027e2:	4b04      	ldr	r3, [pc, #16]	; (4027f4 <vQueueWaitForMessageRestricted+0x48>)
  4027e4:	4798      	blx	r3
  4027e6:	bd38      	pop	{r3, r4, r5, pc}
  4027e8:	00401f65 	.word	0x00401f65
  4027ec:	00401f85 	.word	0x00401f85
  4027f0:	00403349 	.word	0x00403349
  4027f4:	00402271 	.word	0x00402271

004027f8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  4027f8:	b510      	push	{r4, lr}
  4027fa:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  4027fc:	4b0e      	ldr	r3, [pc, #56]	; (402838 <prvAddCurrentTaskToDelayedList+0x40>)
  4027fe:	681b      	ldr	r3, [r3, #0]
  402800:	6058      	str	r0, [r3, #4]

	if( xTimeToWake < xTickCount )
  402802:	4b0e      	ldr	r3, [pc, #56]	; (40283c <prvAddCurrentTaskToDelayedList+0x44>)
  402804:	681b      	ldr	r3, [r3, #0]
  402806:	4298      	cmp	r0, r3
  402808:	d207      	bcs.n	40281a <prvAddCurrentTaskToDelayedList+0x22>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40280a:	4b0d      	ldr	r3, [pc, #52]	; (402840 <prvAddCurrentTaskToDelayedList+0x48>)
  40280c:	6818      	ldr	r0, [r3, #0]
  40280e:	4b0a      	ldr	r3, [pc, #40]	; (402838 <prvAddCurrentTaskToDelayedList+0x40>)
  402810:	6819      	ldr	r1, [r3, #0]
  402812:	3104      	adds	r1, #4
  402814:	4b0b      	ldr	r3, [pc, #44]	; (402844 <prvAddCurrentTaskToDelayedList+0x4c>)
  402816:	4798      	blx	r3
  402818:	bd10      	pop	{r4, pc}
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40281a:	4b0b      	ldr	r3, [pc, #44]	; (402848 <prvAddCurrentTaskToDelayedList+0x50>)
  40281c:	6818      	ldr	r0, [r3, #0]
  40281e:	4b06      	ldr	r3, [pc, #24]	; (402838 <prvAddCurrentTaskToDelayedList+0x40>)
  402820:	6819      	ldr	r1, [r3, #0]
  402822:	3104      	adds	r1, #4
  402824:	4b07      	ldr	r3, [pc, #28]	; (402844 <prvAddCurrentTaskToDelayedList+0x4c>)
  402826:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  402828:	4b08      	ldr	r3, [pc, #32]	; (40284c <prvAddCurrentTaskToDelayedList+0x54>)
  40282a:	681b      	ldr	r3, [r3, #0]
  40282c:	429c      	cmp	r4, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
  40282e:	bf3c      	itt	cc
  402830:	4b06      	ldrcc	r3, [pc, #24]	; (40284c <prvAddCurrentTaskToDelayedList+0x54>)
  402832:	601c      	strcc	r4, [r3, #0]
  402834:	bd10      	pop	{r4, pc}
  402836:	bf00      	nop
  402838:	20004d9c 	.word	0x20004d9c
  40283c:	20004cf4 	.word	0x20004cf4
  402840:	20004d5c 	.word	0x20004d5c
  402844:	00401e79 	.word	0x00401e79
  402848:	20004d74 	.word	0x20004d74
  40284c:	2000001c 	.word	0x2000001c

00402850 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
  402850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402854:	b087      	sub	sp, #28
  402856:	9005      	str	r0, [sp, #20]
  402858:	460d      	mov	r5, r1
  40285a:	4693      	mov	fp, r2
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;
	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  40285c:	684b      	ldr	r3, [r1, #4]
  40285e:	685b      	ldr	r3, [r3, #4]
  402860:	604b      	str	r3, [r1, #4]
  402862:	f101 0708 	add.w	r7, r1, #8
  402866:	42bb      	cmp	r3, r7
  402868:	bf04      	itt	eq
  40286a:	685b      	ldreq	r3, [r3, #4]
  40286c:	604b      	streq	r3, [r1, #4]
  40286e:	684b      	ldr	r3, [r1, #4]
  402870:	f8d3 900c 	ldr.w	r9, [r3, #12]
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif

			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, ( unsigned int ) usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
  402874:	4e17      	ldr	r6, [pc, #92]	; (4028d4 <prvListTaskWithinSingleList+0x84>)
  402876:	f8df a064 	ldr.w	sl, [pc, #100]	; 4028dc <prvListTaskWithinSingleList+0x8c>
  40287a:	f8df 8064 	ldr.w	r8, [pc, #100]	; 4028e0 <prvListTaskWithinSingleList+0x90>

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
  40287e:	686b      	ldr	r3, [r5, #4]
  402880:	685b      	ldr	r3, [r3, #4]
  402882:	606b      	str	r3, [r5, #4]
  402884:	429f      	cmp	r7, r3
  402886:	bf04      	itt	eq
  402888:	68eb      	ldreq	r3, [r5, #12]
  40288a:	606b      	streq	r3, [r5, #4]
  40288c:	686b      	ldr	r3, [r5, #4]
  40288e:	68dc      	ldr	r4, [r3, #12]
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
  402890:	6b22      	ldr	r2, [r4, #48]	; 0x30

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  402892:	7813      	ldrb	r3, [r2, #0]
  402894:	2ba5      	cmp	r3, #165	; 0xa5
  402896:	d107      	bne.n	4028a8 <prvListTaskWithinSingleList+0x58>
  402898:	2300      	movs	r3, #0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
  40289a:	3301      	adds	r3, #1
  40289c:	b29b      	uxth	r3, r3

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  40289e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  4028a2:	29a5      	cmp	r1, #165	; 0xa5
  4028a4:	d0f9      	beq.n	40289a <prvListTaskWithinSingleList+0x4a>
  4028a6:	e000      	b.n	4028aa <prvListTaskWithinSingleList+0x5a>

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
  4028a8:	2300      	movs	r3, #0
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif

			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, ( unsigned int ) usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
  4028aa:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  4028ac:	6c22      	ldr	r2, [r4, #64]	; 0x40
  4028ae:	9100      	str	r1, [sp, #0]
  4028b0:	089b      	lsrs	r3, r3, #2
  4028b2:	9301      	str	r3, [sp, #4]
  4028b4:	9202      	str	r2, [sp, #8]
  4028b6:	4630      	mov	r0, r6
  4028b8:	4651      	mov	r1, sl
  4028ba:	f104 0234 	add.w	r2, r4, #52	; 0x34
  4028be:	465b      	mov	r3, fp
  4028c0:	47c0      	blx	r8
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
  4028c2:	9805      	ldr	r0, [sp, #20]
  4028c4:	4631      	mov	r1, r6
  4028c6:	4b04      	ldr	r3, [pc, #16]	; (4028d8 <prvListTaskWithinSingleList+0x88>)
  4028c8:	4798      	blx	r3

		} while( pxNextTCB != pxFirstTCB );
  4028ca:	454c      	cmp	r4, r9
  4028cc:	d1d7      	bne.n	40287e <prvListTaskWithinSingleList+0x2e>
	}
  4028ce:	b007      	add	sp, #28
  4028d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4028d4:	20004e14 	.word	0x20004e14
  4028d8:	004043c5 	.word	0x004043c5
  4028dc:	004099cc 	.word	0x004099cc
  4028e0:	00404379 	.word	0x00404379

004028e4 <prvGenerateRunTimeStatsForTasksInList>:
/*-----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime )
	{
  4028e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4028e8:	b083      	sub	sp, #12
  4028ea:	4683      	mov	fp, r0
  4028ec:	460c      	mov	r4, r1
  4028ee:	4616      	mov	r6, r2
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned long ulStatsAsPercentage;

		/* Write the run time stats of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  4028f0:	684b      	ldr	r3, [r1, #4]
  4028f2:	685b      	ldr	r3, [r3, #4]
  4028f4:	604b      	str	r3, [r1, #4]
  4028f6:	f101 0708 	add.w	r7, r1, #8
  4028fa:	42bb      	cmp	r3, r7
  4028fc:	bf04      	itt	eq
  4028fe:	685b      	ldreq	r3, [r3, #4]
  402900:	604b      	streq	r3, [r1, #4]
  402902:	684b      	ldr	r3, [r1, #4]
  402904:	f8d3 800c 	ldr.w	r8, [r3, #12]
						}
						#endif
					}
				}

				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
  402908:	f8df 9078 	ldr.w	r9, [pc, #120]	; 402984 <prvGenerateRunTimeStatsForTasksInList+0xa0>
  40290c:	f8df a078 	ldr.w	sl, [pc, #120]	; 402988 <prvGenerateRunTimeStatsForTasksInList+0xa4>
		/* Write the run time stats of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			/* Get next TCB in from the list. */
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
  402910:	6863      	ldr	r3, [r4, #4]
  402912:	685b      	ldr	r3, [r3, #4]
  402914:	6063      	str	r3, [r4, #4]
  402916:	429f      	cmp	r7, r3
  402918:	bf04      	itt	eq
  40291a:	68e3      	ldreq	r3, [r4, #12]
  40291c:	6063      	streq	r3, [r4, #4]
  40291e:	6863      	ldr	r3, [r4, #4]
  402920:	68dd      	ldr	r5, [r3, #12]

			/* Divide by zero check. */
			if( ulTotalRunTime > 0UL )
  402922:	b30e      	cbz	r6, 402968 <prvGenerateRunTimeStatsForTasksInList+0x84>
			{
				/* Has the task run at all? */
				if( pxNextTCB->ulRunTimeCounter == 0UL )
  402924:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  402926:	b933      	cbnz	r3, 402936 <prvGenerateRunTimeStatsForTasksInList+0x52>
				{
					/* The task has used no CPU time at all. */
					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
  402928:	4648      	mov	r0, r9
  40292a:	4912      	ldr	r1, [pc, #72]	; (402974 <prvGenerateRunTimeStatsForTasksInList+0x90>)
  40292c:	f105 0234 	add.w	r2, r5, #52	; 0x34
  402930:	4b11      	ldr	r3, [pc, #68]	; (402978 <prvGenerateRunTimeStatsForTasksInList+0x94>)
  402932:	4798      	blx	r3
  402934:	e015      	b.n	402962 <prvGenerateRunTimeStatsForTasksInList+0x7e>
				else
				{
					/* What percentage of the total run time has the task used?
					This will always be rounded down to the nearest integer.
					ulTotalRunTime has already been divided by 100. */
					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
  402936:	6cea      	ldr	r2, [r5, #76]	; 0x4c
  402938:	fbb2 f2f6 	udiv	r2, r2, r6

					if( ulStatsAsPercentage > 0UL )
  40293c:	b14a      	cbz	r2, 402952 <prvGenerateRunTimeStatsForTasksInList+0x6e>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
  40293e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  402940:	9200      	str	r2, [sp, #0]
  402942:	4648      	mov	r0, r9
  402944:	490d      	ldr	r1, [pc, #52]	; (40297c <prvGenerateRunTimeStatsForTasksInList+0x98>)
  402946:	f105 0234 	add.w	r2, r5, #52	; 0x34
  40294a:	f8df c02c 	ldr.w	ip, [pc, #44]	; 402978 <prvGenerateRunTimeStatsForTasksInList+0x94>
  40294e:	47e0      	blx	ip
  402950:	e007      	b.n	402962 <prvGenerateRunTimeStatsForTasksInList+0x7e>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter );
  402952:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  402954:	4648      	mov	r0, r9
  402956:	490a      	ldr	r1, [pc, #40]	; (402980 <prvGenerateRunTimeStatsForTasksInList+0x9c>)
  402958:	f105 0234 	add.w	r2, r5, #52	; 0x34
  40295c:	f8df c018 	ldr.w	ip, [pc, #24]	; 402978 <prvGenerateRunTimeStatsForTasksInList+0x94>
  402960:	47e0      	blx	ip
						}
						#endif
					}
				}

				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
  402962:	4658      	mov	r0, fp
  402964:	4649      	mov	r1, r9
  402966:	47d0      	blx	sl
			}

		} while( pxNextTCB != pxFirstTCB );
  402968:	4545      	cmp	r5, r8
  40296a:	d1d1      	bne.n	402910 <prvGenerateRunTimeStatsForTasksInList+0x2c>
	}
  40296c:	b003      	add	sp, #12
  40296e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402972:	bf00      	nop
  402974:	004099e0 	.word	0x004099e0
  402978:	00404379 	.word	0x00404379
  40297c:	004099f0 	.word	0x004099f0
  402980:	00409a00 	.word	0x00409a00
  402984:	20004da0 	.word	0x20004da0
  402988:	004043c5 	.word	0x004043c5

0040298c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  40298c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402990:	b083      	sub	sp, #12
  402992:	4688      	mov	r8, r1
  402994:	4615      	mov	r5, r2
  402996:	9301      	str	r3, [sp, #4]
  402998:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  40299a:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
  40299e:	9e0e      	ldr	r6, [sp, #56]	; 0x38
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
  4029a0:	9000      	str	r0, [sp, #0]
  4029a2:	b920      	cbnz	r0, 4029ae <xTaskGenericCreate+0x22>
  4029a4:	485f      	ldr	r0, [pc, #380]	; (402b24 <xTaskGenericCreate+0x198>)
  4029a6:	f240 11eb 	movw	r1, #491	; 0x1eb
  4029aa:	4b5f      	ldr	r3, [pc, #380]	; (402b28 <xTaskGenericCreate+0x19c>)
  4029ac:	4798      	blx	r3
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
  4029ae:	2f04      	cmp	r7, #4
  4029b0:	d904      	bls.n	4029bc <xTaskGenericCreate+0x30>
  4029b2:	485c      	ldr	r0, [pc, #368]	; (402b24 <xTaskGenericCreate+0x198>)
  4029b4:	f44f 71f6 	mov.w	r1, #492	; 0x1ec
  4029b8:	4b5b      	ldr	r3, [pc, #364]	; (402b28 <xTaskGenericCreate+0x19c>)
  4029ba:	4798      	blx	r3
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  4029bc:	2050      	movs	r0, #80	; 0x50
  4029be:	4b5b      	ldr	r3, [pc, #364]	; (402b2c <xTaskGenericCreate+0x1a0>)
  4029c0:	4798      	blx	r3

	if( pxNewTCB != NULL )
  4029c2:	4604      	mov	r4, r0
  4029c4:	2800      	cmp	r0, #0
  4029c6:	f000 80a7 	beq.w	402b18 <xTaskGenericCreate+0x18c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  4029ca:	2e00      	cmp	r6, #0
  4029cc:	f040 80a1 	bne.w	402b12 <xTaskGenericCreate+0x186>
  4029d0:	00a8      	lsls	r0, r5, #2
  4029d2:	4b56      	ldr	r3, [pc, #344]	; (402b2c <xTaskGenericCreate+0x1a0>)
  4029d4:	4798      	blx	r3
  4029d6:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
  4029d8:	b918      	cbnz	r0, 4029e2 <xTaskGenericCreate+0x56>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
  4029da:	4620      	mov	r0, r4
  4029dc:	4b54      	ldr	r3, [pc, #336]	; (402b30 <xTaskGenericCreate+0x1a4>)
  4029de:	4798      	blx	r3
  4029e0:	e09a      	b.n	402b18 <xTaskGenericCreate+0x18c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
  4029e2:	21a5      	movs	r1, #165	; 0xa5
  4029e4:	00aa      	lsls	r2, r5, #2
  4029e6:	4b53      	ldr	r3, [pc, #332]	; (402b34 <xTaskGenericCreate+0x1a8>)
  4029e8:	4798      	blx	r3
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
  4029ea:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
  4029ee:	3d01      	subs	r5, #1
  4029f0:	6b23      	ldr	r3, [r4, #48]	; 0x30
  4029f2:	eb03 0585 	add.w	r5, r3, r5, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
  4029f6:	f025 0507 	bic.w	r5, r5, #7
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
  4029fa:	f104 0034 	add.w	r0, r4, #52	; 0x34
  4029fe:	4641      	mov	r1, r8
  402a00:	220a      	movs	r2, #10
  402a02:	4b4d      	ldr	r3, [pc, #308]	; (402b38 <xTaskGenericCreate+0x1ac>)
  402a04:	4798      	blx	r3
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
  402a06:	f04f 0a00 	mov.w	sl, #0
  402a0a:	f884 a03d 	strb.w	sl, [r4, #61]	; 0x3d
  402a0e:	463e      	mov	r6, r7
  402a10:	2f04      	cmp	r7, #4
  402a12:	bf28      	it	cs
  402a14:	2604      	movcs	r6, #4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
  402a16:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  402a18:	64a6      	str	r6, [r4, #72]	; 0x48
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  402a1a:	f104 0804 	add.w	r8, r4, #4
  402a1e:	4640      	mov	r0, r8
  402a20:	f8df b164 	ldr.w	fp, [pc, #356]	; 402b88 <xTaskGenericCreate+0x1fc>
  402a24:	47d8      	blx	fp
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  402a26:	f104 0018 	add.w	r0, r4, #24
  402a2a:	47d8      	blx	fp

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  402a2c:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  402a2e:	f1c6 0605 	rsb	r6, r6, #5
  402a32:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  402a34:	6264      	str	r4, [r4, #36]	; 0x24
	}
	#endif

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
  402a36:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  402a3a:	4628      	mov	r0, r5
  402a3c:	9900      	ldr	r1, [sp, #0]
  402a3e:	9a01      	ldr	r2, [sp, #4]
  402a40:	4b3e      	ldr	r3, [pc, #248]	; (402b3c <xTaskGenericCreate+0x1b0>)
  402a42:	4798      	blx	r3
  402a44:	6020      	str	r0, [r4, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
  402a46:	f1b9 0f00 	cmp.w	r9, #0
  402a4a:	d001      	beq.n	402a50 <xTaskGenericCreate+0xc4>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
  402a4c:	f8c9 4000 	str.w	r4, [r9]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
  402a50:	4b3b      	ldr	r3, [pc, #236]	; (402b40 <xTaskGenericCreate+0x1b4>)
  402a52:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
  402a54:	4a3b      	ldr	r2, [pc, #236]	; (402b44 <xTaskGenericCreate+0x1b8>)
  402a56:	6813      	ldr	r3, [r2, #0]
  402a58:	3301      	adds	r3, #1
  402a5a:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
  402a5c:	4b3a      	ldr	r3, [pc, #232]	; (402b48 <xTaskGenericCreate+0x1bc>)
  402a5e:	681b      	ldr	r3, [r3, #0]
  402a60:	bb0b      	cbnz	r3, 402aa6 <xTaskGenericCreate+0x11a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
  402a62:	4b39      	ldr	r3, [pc, #228]	; (402b48 <xTaskGenericCreate+0x1bc>)
  402a64:	601c      	str	r4, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  402a66:	6813      	ldr	r3, [r2, #0]
  402a68:	2b01      	cmp	r3, #1
  402a6a:	d126      	bne.n	402aba <xTaskGenericCreate+0x12e>
  402a6c:	4d37      	ldr	r5, [pc, #220]	; (402b4c <xTaskGenericCreate+0x1c0>)
  402a6e:	f105 0964 	add.w	r9, r5, #100	; 0x64
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  402a72:	4e37      	ldr	r6, [pc, #220]	; (402b50 <xTaskGenericCreate+0x1c4>)
  402a74:	4628      	mov	r0, r5
  402a76:	47b0      	blx	r6
  402a78:	3514      	adds	r5, #20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  402a7a:	454d      	cmp	r5, r9
  402a7c:	d1fa      	bne.n	402a74 <xTaskGenericCreate+0xe8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  402a7e:	f8df 910c 	ldr.w	r9, [pc, #268]	; 402b8c <xTaskGenericCreate+0x200>
  402a82:	4648      	mov	r0, r9
  402a84:	4d32      	ldr	r5, [pc, #200]	; (402b50 <xTaskGenericCreate+0x1c4>)
  402a86:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  402a88:	4e32      	ldr	r6, [pc, #200]	; (402b54 <xTaskGenericCreate+0x1c8>)
  402a8a:	4630      	mov	r0, r6
  402a8c:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xPendingReadyList );
  402a8e:	4832      	ldr	r0, [pc, #200]	; (402b58 <xTaskGenericCreate+0x1cc>)
  402a90:	47a8      	blx	r5

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
  402a92:	4832      	ldr	r0, [pc, #200]	; (402b5c <xTaskGenericCreate+0x1d0>)
  402a94:	47a8      	blx	r5
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
  402a96:	4832      	ldr	r0, [pc, #200]	; (402b60 <xTaskGenericCreate+0x1d4>)
  402a98:	47a8      	blx	r5
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  402a9a:	4b32      	ldr	r3, [pc, #200]	; (402b64 <xTaskGenericCreate+0x1d8>)
  402a9c:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  402aa0:	4b31      	ldr	r3, [pc, #196]	; (402b68 <xTaskGenericCreate+0x1dc>)
  402aa2:	601e      	str	r6, [r3, #0]
  402aa4:	e009      	b.n	402aba <xTaskGenericCreate+0x12e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  402aa6:	4b31      	ldr	r3, [pc, #196]	; (402b6c <xTaskGenericCreate+0x1e0>)
  402aa8:	681b      	ldr	r3, [r3, #0]
  402aaa:	b933      	cbnz	r3, 402aba <xTaskGenericCreate+0x12e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  402aac:	4b26      	ldr	r3, [pc, #152]	; (402b48 <xTaskGenericCreate+0x1bc>)
  402aae:	681b      	ldr	r3, [r3, #0]
  402ab0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402ab2:	429f      	cmp	r7, r3
					{
						pxCurrentTCB = pxNewTCB;
  402ab4:	bf24      	itt	cs
  402ab6:	4b24      	ldrcs	r3, [pc, #144]	; (402b48 <xTaskGenericCreate+0x1bc>)
  402ab8:	601c      	strcs	r4, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
  402aba:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  402abc:	4b2c      	ldr	r3, [pc, #176]	; (402b70 <xTaskGenericCreate+0x1e4>)
  402abe:	681b      	ldr	r3, [r3, #0]
  402ac0:	4298      	cmp	r0, r3
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
  402ac2:	bf84      	itt	hi
  402ac4:	4b2a      	ldrhi	r3, [pc, #168]	; (402b70 <xTaskGenericCreate+0x1e4>)
  402ac6:	6018      	strhi	r0, [r3, #0]
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
  402ac8:	4a2a      	ldr	r2, [pc, #168]	; (402b74 <xTaskGenericCreate+0x1e8>)
  402aca:	6813      	ldr	r3, [r2, #0]
  402acc:	6423      	str	r3, [r4, #64]	; 0x40
			}
			#endif
			uxTaskNumber++;
  402ace:	3301      	adds	r3, #1
  402ad0:	6013      	str	r3, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
  402ad2:	4929      	ldr	r1, [pc, #164]	; (402b78 <xTaskGenericCreate+0x1ec>)
  402ad4:	680a      	ldr	r2, [r1, #0]
  402ad6:	2301      	movs	r3, #1
  402ad8:	4083      	lsls	r3, r0
  402ada:	4313      	orrs	r3, r2
  402adc:	600b      	str	r3, [r1, #0]
  402ade:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402ae2:	4b1a      	ldr	r3, [pc, #104]	; (402b4c <xTaskGenericCreate+0x1c0>)
  402ae4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  402ae8:	4641      	mov	r1, r8
  402aea:	4b24      	ldr	r3, [pc, #144]	; (402b7c <xTaskGenericCreate+0x1f0>)
  402aec:	4798      	blx	r3

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
  402aee:	4b24      	ldr	r3, [pc, #144]	; (402b80 <xTaskGenericCreate+0x1f4>)
  402af0:	4798      	blx	r3
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
  402af2:	4b1e      	ldr	r3, [pc, #120]	; (402b6c <xTaskGenericCreate+0x1e0>)
  402af4:	681b      	ldr	r3, [r3, #0]
  402af6:	b143      	cbz	r3, 402b0a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
  402af8:	4b13      	ldr	r3, [pc, #76]	; (402b48 <xTaskGenericCreate+0x1bc>)
  402afa:	681b      	ldr	r3, [r3, #0]
  402afc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402afe:	429f      	cmp	r7, r3
  402b00:	d905      	bls.n	402b0e <xTaskGenericCreate+0x182>
			{
				portYIELD_WITHIN_API();
  402b02:	4b20      	ldr	r3, [pc, #128]	; (402b84 <xTaskGenericCreate+0x1f8>)
  402b04:	4798      	blx	r3
  402b06:	2001      	movs	r0, #1
  402b08:	e008      	b.n	402b1c <xTaskGenericCreate+0x190>
  402b0a:	2001      	movs	r0, #1
  402b0c:	e006      	b.n	402b1c <xTaskGenericCreate+0x190>
  402b0e:	2001      	movs	r0, #1
  402b10:	e004      	b.n	402b1c <xTaskGenericCreate+0x190>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  402b12:	6306      	str	r6, [r0, #48]	; 0x30
  402b14:	4630      	mov	r0, r6
  402b16:	e764      	b.n	4029e2 <xTaskGenericCreate+0x56>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  402b18:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
  402b1c:	b003      	add	sp, #12
  402b1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402b22:	bf00      	nop
  402b24:	00409a10 	.word	0x00409a10
  402b28:	00403de1 	.word	0x00403de1
  402b2c:	004020d9 	.word	0x004020d9
  402b30:	004021ad 	.word	0x004021ad
  402b34:	004041d5 	.word	0x004041d5
  402b38:	00404611 	.word	0x00404611
  402b3c:	00401f05 	.word	0x00401f05
  402b40:	00401f65 	.word	0x00401f65
  402b44:	20004de8 	.word	0x20004de8
  402b48:	20004d9c 	.word	0x20004d9c
  402b4c:	20004cf8 	.word	0x20004cf8
  402b50:	00401e3d 	.word	0x00401e3d
  402b54:	20004e00 	.word	0x20004e00
  402b58:	20004d78 	.word	0x20004d78
  402b5c:	20004d60 	.word	0x20004d60
  402b60:	20004dd4 	.word	0x20004dd4
  402b64:	20004d74 	.word	0x20004d74
  402b68:	20004d5c 	.word	0x20004d5c
  402b6c:	20004d8c 	.word	0x20004d8c
  402b70:	20004e48 	.word	0x20004e48
  402b74:	20004d98 	.word	0x20004d98
  402b78:	20004cec 	.word	0x20004cec
  402b7c:	00401e5d 	.word	0x00401e5d
  402b80:	00401f85 	.word	0x00401f85
  402b84:	00401f45 	.word	0x00401f45
  402b88:	00401e55 	.word	0x00401e55
  402b8c:	20004dec 	.word	0x20004dec

00402b90 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
  402b90:	b570      	push	{r4, r5, r6, lr}
  402b92:	4604      	mov	r4, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
  402b94:	4b1c      	ldr	r3, [pc, #112]	; (402c08 <vTaskDelete+0x78>)
  402b96:	4798      	blx	r3
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
  402b98:	4b1c      	ldr	r3, [pc, #112]	; (402c0c <vTaskDelete+0x7c>)
  402b9a:	681b      	ldr	r3, [r3, #0]
  402b9c:	429c      	cmp	r4, r3
  402b9e:	d001      	beq.n	402ba4 <vTaskDelete+0x14>
  402ba0:	4625      	mov	r5, r4
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
  402ba2:	b91c      	cbnz	r4, 402bac <vTaskDelete+0x1c>
  402ba4:	4b19      	ldr	r3, [pc, #100]	; (402c0c <vTaskDelete+0x7c>)
  402ba6:	681c      	ldr	r4, [r3, #0]
  402ba8:	2500      	movs	r5, #0
  402baa:	e7ff      	b.n	402bac <vTaskDelete+0x1c>

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  402bac:	1d26      	adds	r6, r4, #4
  402bae:	4630      	mov	r0, r6
  402bb0:	4b17      	ldr	r3, [pc, #92]	; (402c10 <vTaskDelete+0x80>)
  402bb2:	4798      	blx	r3
  402bb4:	b968      	cbnz	r0, 402bd2 <vTaskDelete+0x42>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  402bb6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  402bb8:	eb02 0382 	add.w	r3, r2, r2, lsl #2
  402bbc:	009b      	lsls	r3, r3, #2
  402bbe:	4915      	ldr	r1, [pc, #84]	; (402c14 <vTaskDelete+0x84>)
  402bc0:	58cb      	ldr	r3, [r1, r3]
  402bc2:	b933      	cbnz	r3, 402bd2 <vTaskDelete+0x42>
  402bc4:	4814      	ldr	r0, [pc, #80]	; (402c18 <vTaskDelete+0x88>)
  402bc6:	6801      	ldr	r1, [r0, #0]
  402bc8:	2301      	movs	r3, #1
  402bca:	4093      	lsls	r3, r2
  402bcc:	ea21 0303 	bic.w	r3, r1, r3
  402bd0:	6003      	str	r3, [r0, #0]
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
  402bd2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  402bd4:	b11b      	cbz	r3, 402bde <vTaskDelete+0x4e>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
  402bd6:	f104 0018 	add.w	r0, r4, #24
  402bda:	4b0d      	ldr	r3, [pc, #52]	; (402c10 <vTaskDelete+0x80>)
  402bdc:	4798      	blx	r3
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
  402bde:	480f      	ldr	r0, [pc, #60]	; (402c1c <vTaskDelete+0x8c>)
  402be0:	4631      	mov	r1, r6
  402be2:	4b0f      	ldr	r3, [pc, #60]	; (402c20 <vTaskDelete+0x90>)
  402be4:	4798      	blx	r3

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  402be6:	4a0f      	ldr	r2, [pc, #60]	; (402c24 <vTaskDelete+0x94>)
  402be8:	6813      	ldr	r3, [r2, #0]
  402bea:	3301      	adds	r3, #1
  402bec:	6013      	str	r3, [r2, #0]

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
  402bee:	4a0e      	ldr	r2, [pc, #56]	; (402c28 <vTaskDelete+0x98>)
  402bf0:	6813      	ldr	r3, [r2, #0]
  402bf2:	3301      	adds	r3, #1
  402bf4:	6013      	str	r3, [r2, #0]

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
  402bf6:	4b0d      	ldr	r3, [pc, #52]	; (402c2c <vTaskDelete+0x9c>)
  402bf8:	4798      	blx	r3

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
  402bfa:	4b0d      	ldr	r3, [pc, #52]	; (402c30 <vTaskDelete+0xa0>)
  402bfc:	681b      	ldr	r3, [r3, #0]
  402bfe:	b113      	cbz	r3, 402c06 <vTaskDelete+0x76>
		{
			if( ( void * ) pxTaskToDelete == NULL )
  402c00:	b90d      	cbnz	r5, 402c06 <vTaskDelete+0x76>
			{
				portYIELD_WITHIN_API();
  402c02:	4b0c      	ldr	r3, [pc, #48]	; (402c34 <vTaskDelete+0xa4>)
  402c04:	4798      	blx	r3
  402c06:	bd70      	pop	{r4, r5, r6, pc}
  402c08:	00401f65 	.word	0x00401f65
  402c0c:	20004d9c 	.word	0x20004d9c
  402c10:	00401eb5 	.word	0x00401eb5
  402c14:	20004cf8 	.word	0x20004cf8
  402c18:	20004cec 	.word	0x20004cec
  402c1c:	20004d60 	.word	0x20004d60
  402c20:	00401e5d 	.word	0x00401e5d
  402c24:	20004cf0 	.word	0x20004cf0
  402c28:	20004d98 	.word	0x20004d98
  402c2c:	00401f85 	.word	0x00401f85
  402c30:	20004d8c 	.word	0x20004d8c
  402c34:	00401f45 	.word	0x00401f45

00402c38 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
  402c38:	b510      	push	{r4, lr}
  402c3a:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
  402c3c:	2300      	movs	r3, #0
  402c3e:	9300      	str	r3, [sp, #0]
  402c40:	9301      	str	r3, [sp, #4]
  402c42:	9302      	str	r3, [sp, #8]
  402c44:	9303      	str	r3, [sp, #12]
  402c46:	4810      	ldr	r0, [pc, #64]	; (402c88 <vTaskStartScheduler+0x50>)
  402c48:	4910      	ldr	r1, [pc, #64]	; (402c8c <vTaskStartScheduler+0x54>)
  402c4a:	22a0      	movs	r2, #160	; 0xa0
  402c4c:	4c10      	ldr	r4, [pc, #64]	; (402c90 <vTaskStartScheduler+0x58>)
  402c4e:	47a0      	blx	r4
	}
	#endif

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  402c50:	2801      	cmp	r0, #1
  402c52:	d110      	bne.n	402c76 <vTaskStartScheduler+0x3e>
		{
			xReturn = xTimerCreateTimerTask();
  402c54:	4b0f      	ldr	r3, [pc, #60]	; (402c94 <vTaskStartScheduler+0x5c>)
  402c56:	4798      	blx	r3
		}
	}
	#endif

	if( xReturn == pdPASS )
  402c58:	2801      	cmp	r0, #1
  402c5a:	d10c      	bne.n	402c76 <vTaskStartScheduler+0x3e>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
  402c5c:	4b0e      	ldr	r3, [pc, #56]	; (402c98 <vTaskStartScheduler+0x60>)
  402c5e:	4798      	blx	r3

		xSchedulerRunning = pdTRUE;
  402c60:	2201      	movs	r2, #1
  402c62:	4b0e      	ldr	r3, [pc, #56]	; (402c9c <vTaskStartScheduler+0x64>)
  402c64:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
  402c66:	2200      	movs	r2, #0
  402c68:	4b0d      	ldr	r3, [pc, #52]	; (402ca0 <vTaskStartScheduler+0x68>)
  402c6a:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
  402c6c:	4b0d      	ldr	r3, [pc, #52]	; (402ca4 <vTaskStartScheduler+0x6c>)
  402c6e:	4798      	blx	r3

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  402c70:	4b0d      	ldr	r3, [pc, #52]	; (402ca8 <vTaskStartScheduler+0x70>)
  402c72:	4798      	blx	r3
  402c74:	e005      	b.n	402c82 <vTaskStartScheduler+0x4a>
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
  402c76:	b920      	cbnz	r0, 402c82 <vTaskStartScheduler+0x4a>
  402c78:	480c      	ldr	r0, [pc, #48]	; (402cac <vTaskStartScheduler+0x74>)
  402c7a:	f240 5113 	movw	r1, #1299	; 0x513
  402c7e:	4b0c      	ldr	r3, [pc, #48]	; (402cb0 <vTaskStartScheduler+0x78>)
  402c80:	4798      	blx	r3
}
  402c82:	b004      	add	sp, #16
  402c84:	bd10      	pop	{r4, pc}
  402c86:	bf00      	nop
  402c88:	00402fa1 	.word	0x00402fa1
  402c8c:	00409a50 	.word	0x00409a50
  402c90:	0040298d 	.word	0x0040298d
  402c94:	004036e1 	.word	0x004036e1
  402c98:	00401f55 	.word	0x00401f55
  402c9c:	20004d8c 	.word	0x20004d8c
  402ca0:	20004cf4 	.word	0x20004cf4
  402ca4:	00403f81 	.word	0x00403f81
  402ca8:	00402035 	.word	0x00402035
  402cac:	00409a10 	.word	0x00409a10
  402cb0:	00403de1 	.word	0x00403de1

00402cb4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  402cb4:	4a02      	ldr	r2, [pc, #8]	; (402cc0 <vTaskSuspendAll+0xc>)
  402cb6:	6813      	ldr	r3, [r2, #0]
  402cb8:	3301      	adds	r3, #1
  402cba:	6013      	str	r3, [r2, #0]
  402cbc:	4770      	bx	lr
  402cbe:	bf00      	nop
  402cc0:	20004e3c 	.word	0x20004e3c

00402cc4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
  402cc4:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
  402cc6:	4b04      	ldr	r3, [pc, #16]	; (402cd8 <xTaskGetTickCount+0x14>)
  402cc8:	4798      	blx	r3
	{
		xTicks = xTickCount;
  402cca:	4b04      	ldr	r3, [pc, #16]	; (402cdc <xTaskGetTickCount+0x18>)
  402ccc:	681c      	ldr	r4, [r3, #0]
	}
	taskEXIT_CRITICAL();
  402cce:	4b04      	ldr	r3, [pc, #16]	; (402ce0 <xTaskGetTickCount+0x1c>)
  402cd0:	4798      	blx	r3

	return xTicks;
}
  402cd2:	4620      	mov	r0, r4
  402cd4:	bd10      	pop	{r4, pc}
  402cd6:	bf00      	nop
  402cd8:	00401f65 	.word	0x00401f65
  402cdc:	20004cf4 	.word	0x20004cf4
  402ce0:	00401f85 	.word	0x00401f85

00402ce4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
  402ce4:	b510      	push	{r4, lr}
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  402ce6:	4b04      	ldr	r3, [pc, #16]	; (402cf8 <xTaskGetTickCountFromISR+0x14>)
  402ce8:	4798      	blx	r3
	xReturn = xTickCount;
  402cea:	4b04      	ldr	r3, [pc, #16]	; (402cfc <xTaskGetTickCountFromISR+0x18>)
  402cec:	681c      	ldr	r4, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  402cee:	4b04      	ldr	r3, [pc, #16]	; (402d00 <xTaskGetTickCountFromISR+0x1c>)
  402cf0:	4798      	blx	r3

	return xReturn;
}
  402cf2:	4620      	mov	r0, r4
  402cf4:	bd10      	pop	{r4, pc}
  402cf6:	bf00      	nop
  402cf8:	00401f55 	.word	0x00401f55
  402cfc:	20004cf4 	.word	0x20004cf4
  402d00:	00401f7d 	.word	0x00401f7d

00402d04 <vTaskIncrementTick>:

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  402d04:	4b3d      	ldr	r3, [pc, #244]	; (402dfc <vTaskIncrementTick+0xf8>)
  402d06:	681b      	ldr	r3, [r3, #0]
  402d08:	2b00      	cmp	r3, #0
  402d0a:	d16f      	bne.n	402dec <vTaskIncrementTick+0xe8>
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
  402d0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
	{
		++xTickCount;
  402d10:	4b3b      	ldr	r3, [pc, #236]	; (402e00 <vTaskIncrementTick+0xfc>)
  402d12:	681a      	ldr	r2, [r3, #0]
  402d14:	3201      	adds	r2, #1
  402d16:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
  402d18:	681b      	ldr	r3, [r3, #0]
  402d1a:	bb0b      	cbnz	r3, 402d60 <vTaskIncrementTick+0x5c>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
  402d1c:	4b39      	ldr	r3, [pc, #228]	; (402e04 <vTaskIncrementTick+0x100>)
  402d1e:	681b      	ldr	r3, [r3, #0]
  402d20:	681b      	ldr	r3, [r3, #0]
  402d22:	b123      	cbz	r3, 402d2e <vTaskIncrementTick+0x2a>
  402d24:	4838      	ldr	r0, [pc, #224]	; (402e08 <vTaskIncrementTick+0x104>)
  402d26:	f240 618c 	movw	r1, #1676	; 0x68c
  402d2a:	4b38      	ldr	r3, [pc, #224]	; (402e0c <vTaskIncrementTick+0x108>)
  402d2c:	4798      	blx	r3

			pxTemp = pxDelayedTaskList;
  402d2e:	4b35      	ldr	r3, [pc, #212]	; (402e04 <vTaskIncrementTick+0x100>)
  402d30:	6819      	ldr	r1, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  402d32:	4a37      	ldr	r2, [pc, #220]	; (402e10 <vTaskIncrementTick+0x10c>)
  402d34:	6810      	ldr	r0, [r2, #0]
  402d36:	6018      	str	r0, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  402d38:	6011      	str	r1, [r2, #0]
			xNumOfOverflows++;
  402d3a:	4936      	ldr	r1, [pc, #216]	; (402e14 <vTaskIncrementTick+0x110>)
  402d3c:	680a      	ldr	r2, [r1, #0]
  402d3e:	3201      	adds	r2, #1
  402d40:	600a      	str	r2, [r1, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  402d42:	681b      	ldr	r3, [r3, #0]
  402d44:	681b      	ldr	r3, [r3, #0]
  402d46:	b923      	cbnz	r3, 402d52 <vTaskIncrementTick+0x4e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  402d48:	f04f 32ff 	mov.w	r2, #4294967295
  402d4c:	4b32      	ldr	r3, [pc, #200]	; (402e18 <vTaskIncrementTick+0x114>)
  402d4e:	601a      	str	r2, [r3, #0]
  402d50:	e006      	b.n	402d60 <vTaskIncrementTick+0x5c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  402d52:	4b2c      	ldr	r3, [pc, #176]	; (402e04 <vTaskIncrementTick+0x100>)
  402d54:	681b      	ldr	r3, [r3, #0]
  402d56:	68db      	ldr	r3, [r3, #12]
  402d58:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  402d5a:	685a      	ldr	r2, [r3, #4]
  402d5c:	4b2e      	ldr	r3, [pc, #184]	; (402e18 <vTaskIncrementTick+0x114>)
  402d5e:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  402d60:	4b27      	ldr	r3, [pc, #156]	; (402e00 <vTaskIncrementTick+0xfc>)
  402d62:	681a      	ldr	r2, [r3, #0]
  402d64:	4b2c      	ldr	r3, [pc, #176]	; (402e18 <vTaskIncrementTick+0x114>)
  402d66:	681b      	ldr	r3, [r3, #0]
  402d68:	429a      	cmp	r2, r3
  402d6a:	d344      	bcc.n	402df6 <vTaskIncrementTick+0xf2>
  402d6c:	4b25      	ldr	r3, [pc, #148]	; (402e04 <vTaskIncrementTick+0x100>)
  402d6e:	681b      	ldr	r3, [r3, #0]
  402d70:	681b      	ldr	r3, [r3, #0]
  402d72:	b16b      	cbz	r3, 402d90 <vTaskIncrementTick+0x8c>
  402d74:	4b23      	ldr	r3, [pc, #140]	; (402e04 <vTaskIncrementTick+0x100>)
  402d76:	681b      	ldr	r3, [r3, #0]
  402d78:	68db      	ldr	r3, [r3, #12]
  402d7a:	68dc      	ldr	r4, [r3, #12]
  402d7c:	6863      	ldr	r3, [r4, #4]
  402d7e:	4a20      	ldr	r2, [pc, #128]	; (402e00 <vTaskIncrementTick+0xfc>)
  402d80:	6812      	ldr	r2, [r2, #0]
  402d82:	4293      	cmp	r3, r2
  402d84:	d813      	bhi.n	402dae <vTaskIncrementTick+0xaa>
  402d86:	4f25      	ldr	r7, [pc, #148]	; (402e1c <vTaskIncrementTick+0x118>)
  402d88:	4e25      	ldr	r6, [pc, #148]	; (402e20 <vTaskIncrementTick+0x11c>)
  402d8a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 402e2c <vTaskIncrementTick+0x128>
  402d8e:	e012      	b.n	402db6 <vTaskIncrementTick+0xb2>
  402d90:	f04f 32ff 	mov.w	r2, #4294967295
  402d94:	4b20      	ldr	r3, [pc, #128]	; (402e18 <vTaskIncrementTick+0x114>)
  402d96:	601a      	str	r2, [r3, #0]
  402d98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402d9c:	4b19      	ldr	r3, [pc, #100]	; (402e04 <vTaskIncrementTick+0x100>)
  402d9e:	681b      	ldr	r3, [r3, #0]
  402da0:	68db      	ldr	r3, [r3, #12]
  402da2:	68dc      	ldr	r4, [r3, #12]
  402da4:	6863      	ldr	r3, [r4, #4]
  402da6:	4a16      	ldr	r2, [pc, #88]	; (402e00 <vTaskIncrementTick+0xfc>)
  402da8:	6812      	ldr	r2, [r2, #0]
  402daa:	4293      	cmp	r3, r2
  402dac:	d903      	bls.n	402db6 <vTaskIncrementTick+0xb2>
  402dae:	4a1a      	ldr	r2, [pc, #104]	; (402e18 <vTaskIncrementTick+0x114>)
  402db0:	6013      	str	r3, [r2, #0]
  402db2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402db6:	1d25      	adds	r5, r4, #4
  402db8:	4628      	mov	r0, r5
  402dba:	47b8      	blx	r7
  402dbc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  402dbe:	b113      	cbz	r3, 402dc6 <vTaskIncrementTick+0xc2>
  402dc0:	f104 0018 	add.w	r0, r4, #24
  402dc4:	47b8      	blx	r7
  402dc6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  402dc8:	6832      	ldr	r2, [r6, #0]
  402dca:	2301      	movs	r3, #1
  402dcc:	4083      	lsls	r3, r0
  402dce:	4313      	orrs	r3, r2
  402dd0:	6033      	str	r3, [r6, #0]
  402dd2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402dd6:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  402dda:	4629      	mov	r1, r5
  402ddc:	4b11      	ldr	r3, [pc, #68]	; (402e24 <vTaskIncrementTick+0x120>)
  402dde:	4798      	blx	r3
  402de0:	4b08      	ldr	r3, [pc, #32]	; (402e04 <vTaskIncrementTick+0x100>)
  402de2:	681b      	ldr	r3, [r3, #0]
  402de4:	681b      	ldr	r3, [r3, #0]
  402de6:	2b00      	cmp	r3, #0
  402de8:	d1d8      	bne.n	402d9c <vTaskIncrementTick+0x98>
  402dea:	e7d1      	b.n	402d90 <vTaskIncrementTick+0x8c>
	}
	else
	{
		++uxMissedTicks;
  402dec:	4a0e      	ldr	r2, [pc, #56]	; (402e28 <vTaskIncrementTick+0x124>)
  402dee:	6813      	ldr	r3, [r2, #0]
  402df0:	3301      	adds	r3, #1
  402df2:	6013      	str	r3, [r2, #0]
  402df4:	4770      	bx	lr
  402df6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402dfa:	bf00      	nop
  402dfc:	20004e3c 	.word	0x20004e3c
  402e00:	20004cf4 	.word	0x20004cf4
  402e04:	20004d74 	.word	0x20004d74
  402e08:	00409a10 	.word	0x00409a10
  402e0c:	00403de1 	.word	0x00403de1
  402e10:	20004d5c 	.word	0x20004d5c
  402e14:	20004e44 	.word	0x20004e44
  402e18:	2000001c 	.word	0x2000001c
  402e1c:	00401eb5 	.word	0x00401eb5
  402e20:	20004cec 	.word	0x20004cec
  402e24:	00401e5d 	.word	0x00401e5d
  402e28:	20004e40 	.word	0x20004e40
  402e2c:	20004cf8 	.word	0x20004cf8

00402e30 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  402e30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  402e34:	4b31      	ldr	r3, [pc, #196]	; (402efc <xTaskResumeAll+0xcc>)
  402e36:	681b      	ldr	r3, [r3, #0]
  402e38:	b923      	cbnz	r3, 402e44 <xTaskResumeAll+0x14>
  402e3a:	4831      	ldr	r0, [pc, #196]	; (402f00 <xTaskResumeAll+0xd0>)
  402e3c:	f240 514d 	movw	r1, #1357	; 0x54d
  402e40:	4b30      	ldr	r3, [pc, #192]	; (402f04 <xTaskResumeAll+0xd4>)
  402e42:	4798      	blx	r3
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  402e44:	4b30      	ldr	r3, [pc, #192]	; (402f08 <xTaskResumeAll+0xd8>)
  402e46:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  402e48:	4b2c      	ldr	r3, [pc, #176]	; (402efc <xTaskResumeAll+0xcc>)
  402e4a:	681a      	ldr	r2, [r3, #0]
  402e4c:	3a01      	subs	r2, #1
  402e4e:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  402e50:	681b      	ldr	r3, [r3, #0]
  402e52:	2b00      	cmp	r3, #0
  402e54:	d14a      	bne.n	402eec <xTaskResumeAll+0xbc>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  402e56:	4b2d      	ldr	r3, [pc, #180]	; (402f0c <xTaskResumeAll+0xdc>)
  402e58:	681b      	ldr	r3, [r3, #0]
  402e5a:	bb0b      	cbnz	r3, 402ea0 <xTaskResumeAll+0x70>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  402e5c:	2400      	movs	r4, #0
  402e5e:	e048      	b.n	402ef2 <xTaskResumeAll+0xc2>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  402e60:	68f3      	ldr	r3, [r6, #12]
  402e62:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
  402e64:	f104 0018 	add.w	r0, r4, #24
  402e68:	47c8      	blx	r9
					uxListRemove( &( pxTCB->xGenericListItem ) );
  402e6a:	1d25      	adds	r5, r4, #4
  402e6c:	4628      	mov	r0, r5
  402e6e:	47c8      	blx	r9
					prvAddTaskToReadyQueue( pxTCB );
  402e70:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  402e72:	f8d8 2000 	ldr.w	r2, [r8]
  402e76:	2301      	movs	r3, #1
  402e78:	4083      	lsls	r3, r0
  402e7a:	4313      	orrs	r3, r2
  402e7c:	f8c8 3000 	str.w	r3, [r8]
  402e80:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402e84:	4b22      	ldr	r3, [pc, #136]	; (402f10 <xTaskResumeAll+0xe0>)
  402e86:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  402e8a:	4629      	mov	r1, r5
  402e8c:	4b21      	ldr	r3, [pc, #132]	; (402f14 <xTaskResumeAll+0xe4>)
  402e8e:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  402e90:	4b21      	ldr	r3, [pc, #132]	; (402f18 <xTaskResumeAll+0xe8>)
  402e92:	681b      	ldr	r3, [r3, #0]
  402e94:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  402e96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
  402e98:	429a      	cmp	r2, r3
  402e9a:	bf28      	it	cs
  402e9c:	2701      	movcs	r7, #1
  402e9e:	e005      	b.n	402eac <xTaskResumeAll+0x7c>
  402ea0:	2700      	movs	r7, #0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  402ea2:	4e1e      	ldr	r6, [pc, #120]	; (402f1c <xTaskResumeAll+0xec>)
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
  402ea4:	f8df 908c 	ldr.w	r9, [pc, #140]	; 402f34 <xTaskResumeAll+0x104>
					uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
  402ea8:	f8df 808c 	ldr.w	r8, [pc, #140]	; 402f38 <xTaskResumeAll+0x108>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  402eac:	6833      	ldr	r3, [r6, #0]
  402eae:	2b00      	cmp	r3, #0
  402eb0:	d1d6      	bne.n	402e60 <xTaskResumeAll+0x30>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  402eb2:	4b1b      	ldr	r3, [pc, #108]	; (402f20 <xTaskResumeAll+0xf0>)
  402eb4:	681b      	ldr	r3, [r3, #0]
  402eb6:	b163      	cbz	r3, 402ed2 <xTaskResumeAll+0xa2>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  402eb8:	4b19      	ldr	r3, [pc, #100]	; (402f20 <xTaskResumeAll+0xf0>)
  402eba:	681b      	ldr	r3, [r3, #0]
  402ebc:	b17b      	cbz	r3, 402ede <xTaskResumeAll+0xae>
					{
						vTaskIncrementTick();
  402ebe:	4d19      	ldr	r5, [pc, #100]	; (402f24 <xTaskResumeAll+0xf4>)
						--uxMissedTicks;
  402ec0:	4c17      	ldr	r4, [pc, #92]	; (402f20 <xTaskResumeAll+0xf0>)
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
  402ec2:	47a8      	blx	r5
						--uxMissedTicks;
  402ec4:	6823      	ldr	r3, [r4, #0]
  402ec6:	3b01      	subs	r3, #1
  402ec8:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  402eca:	6823      	ldr	r3, [r4, #0]
  402ecc:	2b00      	cmp	r3, #0
  402ece:	d1f8      	bne.n	402ec2 <xTaskResumeAll+0x92>
  402ed0:	e005      	b.n	402ede <xTaskResumeAll+0xae>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  402ed2:	2f01      	cmp	r7, #1
  402ed4:	d003      	beq.n	402ede <xTaskResumeAll+0xae>
  402ed6:	4b14      	ldr	r3, [pc, #80]	; (402f28 <xTaskResumeAll+0xf8>)
  402ed8:	681b      	ldr	r3, [r3, #0]
  402eda:	2b01      	cmp	r3, #1
  402edc:	d108      	bne.n	402ef0 <xTaskResumeAll+0xc0>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  402ede:	2200      	movs	r2, #0
  402ee0:	4b11      	ldr	r3, [pc, #68]	; (402f28 <xTaskResumeAll+0xf8>)
  402ee2:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
  402ee4:	4b11      	ldr	r3, [pc, #68]	; (402f2c <xTaskResumeAll+0xfc>)
  402ee6:	4798      	blx	r3
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
  402ee8:	2401      	movs	r4, #1
  402eea:	e002      	b.n	402ef2 <xTaskResumeAll+0xc2>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  402eec:	2400      	movs	r4, #0
  402eee:	e000      	b.n	402ef2 <xTaskResumeAll+0xc2>
  402ef0:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  402ef2:	4b0f      	ldr	r3, [pc, #60]	; (402f30 <xTaskResumeAll+0x100>)
  402ef4:	4798      	blx	r3

	return xAlreadyYielded;
}
  402ef6:	4620      	mov	r0, r4
  402ef8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  402efc:	20004e3c 	.word	0x20004e3c
  402f00:	00409a10 	.word	0x00409a10
  402f04:	00403de1 	.word	0x00403de1
  402f08:	00401f65 	.word	0x00401f65
  402f0c:	20004de8 	.word	0x20004de8
  402f10:	20004cf8 	.word	0x20004cf8
  402f14:	00401e5d 	.word	0x00401e5d
  402f18:	20004d9c 	.word	0x20004d9c
  402f1c:	20004d78 	.word	0x20004d78
  402f20:	20004e40 	.word	0x20004e40
  402f24:	00402d05 	.word	0x00402d05
  402f28:	20004d94 	.word	0x20004d94
  402f2c:	00401f45 	.word	0x00401f45
  402f30:	00401f85 	.word	0x00401f85
  402f34:	00401eb5 	.word	0x00401eb5
  402f38:	20004cec 	.word	0x20004cec

00402f3c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
  402f3c:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
  402f3e:	b1d8      	cbz	r0, 402f78 <vTaskDelay+0x3c>
  402f40:	4604      	mov	r4, r0
		{
			vTaskSuspendAll();
  402f42:	4b0f      	ldr	r3, [pc, #60]	; (402f80 <vTaskDelay+0x44>)
  402f44:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  402f46:	4b0f      	ldr	r3, [pc, #60]	; (402f84 <vTaskDelay+0x48>)
  402f48:	681b      	ldr	r3, [r3, #0]
  402f4a:	441c      	add	r4, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  402f4c:	4b0e      	ldr	r3, [pc, #56]	; (402f88 <vTaskDelay+0x4c>)
  402f4e:	6818      	ldr	r0, [r3, #0]
  402f50:	3004      	adds	r0, #4
  402f52:	4b0e      	ldr	r3, [pc, #56]	; (402f8c <vTaskDelay+0x50>)
  402f54:	4798      	blx	r3
  402f56:	b948      	cbnz	r0, 402f6c <vTaskDelay+0x30>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  402f58:	4b0b      	ldr	r3, [pc, #44]	; (402f88 <vTaskDelay+0x4c>)
  402f5a:	681b      	ldr	r3, [r3, #0]
  402f5c:	490c      	ldr	r1, [pc, #48]	; (402f90 <vTaskDelay+0x54>)
  402f5e:	680a      	ldr	r2, [r1, #0]
  402f60:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  402f62:	2301      	movs	r3, #1
  402f64:	4083      	lsls	r3, r0
  402f66:	ea22 0303 	bic.w	r3, r2, r3
  402f6a:	600b      	str	r3, [r1, #0]
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
  402f6c:	4620      	mov	r0, r4
  402f6e:	4b09      	ldr	r3, [pc, #36]	; (402f94 <vTaskDelay+0x58>)
  402f70:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
  402f72:	4b09      	ldr	r3, [pc, #36]	; (402f98 <vTaskDelay+0x5c>)
  402f74:	4798      	blx	r3
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  402f76:	b908      	cbnz	r0, 402f7c <vTaskDelay+0x40>
		{
			portYIELD_WITHIN_API();
  402f78:	4b08      	ldr	r3, [pc, #32]	; (402f9c <vTaskDelay+0x60>)
  402f7a:	4798      	blx	r3
  402f7c:	bd10      	pop	{r4, pc}
  402f7e:	bf00      	nop
  402f80:	00402cb5 	.word	0x00402cb5
  402f84:	20004cf4 	.word	0x20004cf4
  402f88:	20004d9c 	.word	0x20004d9c
  402f8c:	00401eb5 	.word	0x00401eb5
  402f90:	20004cec 	.word	0x20004cec
  402f94:	004027f9 	.word	0x004027f9
  402f98:	00402e31 	.word	0x00402e31
  402f9c:	00401f45 	.word	0x00401f45

00402fa0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  402fa0:	b580      	push	{r7, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  402fa2:	4d15      	ldr	r5, [pc, #84]	; (402ff8 <prvIdleTask+0x58>)
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  402fa4:	4e15      	ldr	r6, [pc, #84]	; (402ffc <prvIdleTask+0x5c>)

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
  402fa6:	f8df 8074 	ldr.w	r8, [pc, #116]	; 40301c <prvIdleTask+0x7c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
			xTaskResumeAll();
  402faa:	4f15      	ldr	r7, [pc, #84]	; (403000 <prvIdleTask+0x60>)
  402fac:	e019      	b.n	402fe2 <prvIdleTask+0x42>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
  402fae:	47c0      	blx	r8
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  402fb0:	6834      	ldr	r4, [r6, #0]
			xTaskResumeAll();
  402fb2:	47b8      	blx	r7

			if( xListIsEmpty == pdFALSE )
  402fb4:	b1ac      	cbz	r4, 402fe2 <prvIdleTask+0x42>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
  402fb6:	4b13      	ldr	r3, [pc, #76]	; (403004 <prvIdleTask+0x64>)
  402fb8:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
  402fba:	68f3      	ldr	r3, [r6, #12]
  402fbc:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xGenericListItem ) );
  402fbe:	1d20      	adds	r0, r4, #4
  402fc0:	4b11      	ldr	r3, [pc, #68]	; (403008 <prvIdleTask+0x68>)
  402fc2:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  402fc4:	4a11      	ldr	r2, [pc, #68]	; (40300c <prvIdleTask+0x6c>)
  402fc6:	6813      	ldr	r3, [r2, #0]
  402fc8:	3b01      	subs	r3, #1
  402fca:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
  402fcc:	682b      	ldr	r3, [r5, #0]
  402fce:	3b01      	subs	r3, #1
  402fd0:	602b      	str	r3, [r5, #0]
				}
				taskEXIT_CRITICAL();
  402fd2:	4b0f      	ldr	r3, [pc, #60]	; (403010 <prvIdleTask+0x70>)
  402fd4:	4798      	blx	r3
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  402fd6:	6b20      	ldr	r0, [r4, #48]	; 0x30
  402fd8:	f8df 9044 	ldr.w	r9, [pc, #68]	; 403020 <prvIdleTask+0x80>
  402fdc:	47c8      	blx	r9
		vPortFree( pxTCB );
  402fde:	4620      	mov	r0, r4
  402fe0:	47c8      	blx	r9
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  402fe2:	682b      	ldr	r3, [r5, #0]
  402fe4:	2b00      	cmp	r3, #0
  402fe6:	d1e2      	bne.n	402fae <prvIdleTask+0xe>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  402fe8:	4b0a      	ldr	r3, [pc, #40]	; (403014 <prvIdleTask+0x74>)
  402fea:	681b      	ldr	r3, [r3, #0]
  402fec:	2b01      	cmp	r3, #1
  402fee:	d9f8      	bls.n	402fe2 <prvIdleTask+0x42>
			{
				taskYIELD();
  402ff0:	4b09      	ldr	r3, [pc, #36]	; (403018 <prvIdleTask+0x78>)
  402ff2:	4798      	blx	r3
  402ff4:	e7d7      	b.n	402fa6 <prvIdleTask+0x6>
  402ff6:	bf00      	nop
  402ff8:	20004cf0 	.word	0x20004cf0
  402ffc:	20004d60 	.word	0x20004d60
  403000:	00402e31 	.word	0x00402e31
  403004:	00401f65 	.word	0x00401f65
  403008:	00401eb5 	.word	0x00401eb5
  40300c:	20004de8 	.word	0x20004de8
  403010:	00401f85 	.word	0x00401f85
  403014:	20004cf8 	.word	0x20004cf8
  403018:	00401f45 	.word	0x00401f45
  40301c:	00402cb5 	.word	0x00402cb5
  403020:	004021ad 	.word	0x004021ad

00403024 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
  403024:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  403028:	4606      	mov	r6, r0
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
  40302a:	4b28      	ldr	r3, [pc, #160]	; (4030cc <vTaskList+0xa8>)
  40302c:	4798      	blx	r3
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
  40302e:	2300      	movs	r3, #0
  403030:	7033      	strb	r3, [r6, #0]
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
  403032:	4630      	mov	r0, r6
  403034:	4b26      	ldr	r3, [pc, #152]	; (4030d0 <vTaskList+0xac>)
  403036:	4798      	blx	r3
  403038:	1832      	adds	r2, r6, r0
  40303a:	4b26      	ldr	r3, [pc, #152]	; (4030d4 <vTaskList+0xb0>)
  40303c:	8819      	ldrh	r1, [r3, #0]
  40303e:	789b      	ldrb	r3, [r3, #2]
  403040:	5231      	strh	r1, [r6, r0]
  403042:	7093      	strb	r3, [r2, #2]

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
  403044:	4b24      	ldr	r3, [pc, #144]	; (4030d8 <vTaskList+0xb4>)
  403046:	681c      	ldr	r4, [r3, #0]
  403048:	3401      	adds	r4, #1
  40304a:	eb04 0584 	add.w	r5, r4, r4, lsl #2
  40304e:	4b23      	ldr	r3, [pc, #140]	; (4030dc <vTaskList+0xb8>)
  403050:	eb03 0585 	add.w	r5, r3, r5, lsl #2
  403054:	3d14      	subs	r5, #20

			do
			{
				uxQueue--;

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  403056:	461f      	mov	r7, r3
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
  403058:	f04f 0952 	mov.w	r9, #82	; 0x52
  40305c:	f8df 8084 	ldr.w	r8, [pc, #132]	; 4030e4 <vTaskList+0xc0>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;

			do
			{
				uxQueue--;
  403060:	3c01      	subs	r4, #1

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  403062:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  403066:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
  40306a:	b11b      	cbz	r3, 403074 <vTaskList+0x50>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
  40306c:	4630      	mov	r0, r6
  40306e:	4629      	mov	r1, r5
  403070:	464a      	mov	r2, r9
  403072:	47c0      	blx	r8
  403074:	3d14      	subs	r5, #20
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
  403076:	2c00      	cmp	r4, #0
  403078:	d1f2      	bne.n	403060 <vTaskList+0x3c>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
  40307a:	4b19      	ldr	r3, [pc, #100]	; (4030e0 <vTaskList+0xbc>)
  40307c:	681b      	ldr	r3, [r3, #0]
  40307e:	681b      	ldr	r3, [r3, #0]
  403080:	b12b      	cbz	r3, 40308e <vTaskList+0x6a>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
  403082:	4b17      	ldr	r3, [pc, #92]	; (4030e0 <vTaskList+0xbc>)
  403084:	6819      	ldr	r1, [r3, #0]
  403086:	4630      	mov	r0, r6
  403088:	2242      	movs	r2, #66	; 0x42
  40308a:	4b16      	ldr	r3, [pc, #88]	; (4030e4 <vTaskList+0xc0>)
  40308c:	4798      	blx	r3
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
  40308e:	4b16      	ldr	r3, [pc, #88]	; (4030e8 <vTaskList+0xc4>)
  403090:	681b      	ldr	r3, [r3, #0]
  403092:	681b      	ldr	r3, [r3, #0]
  403094:	b12b      	cbz	r3, 4030a2 <vTaskList+0x7e>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
  403096:	4b14      	ldr	r3, [pc, #80]	; (4030e8 <vTaskList+0xc4>)
  403098:	6819      	ldr	r1, [r3, #0]
  40309a:	4630      	mov	r0, r6
  40309c:	2242      	movs	r2, #66	; 0x42
  40309e:	4b11      	ldr	r3, [pc, #68]	; (4030e4 <vTaskList+0xc0>)
  4030a0:	4798      	blx	r3
			}

			#if( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
  4030a2:	4b12      	ldr	r3, [pc, #72]	; (4030ec <vTaskList+0xc8>)
  4030a4:	681b      	ldr	r3, [r3, #0]
  4030a6:	b123      	cbz	r3, 4030b2 <vTaskList+0x8e>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
  4030a8:	4630      	mov	r0, r6
  4030aa:	4910      	ldr	r1, [pc, #64]	; (4030ec <vTaskList+0xc8>)
  4030ac:	2244      	movs	r2, #68	; 0x44
  4030ae:	4b0d      	ldr	r3, [pc, #52]	; (4030e4 <vTaskList+0xc0>)
  4030b0:	4798      	blx	r3
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
  4030b2:	4b0f      	ldr	r3, [pc, #60]	; (4030f0 <vTaskList+0xcc>)
  4030b4:	681b      	ldr	r3, [r3, #0]
  4030b6:	b123      	cbz	r3, 4030c2 <vTaskList+0x9e>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
  4030b8:	4630      	mov	r0, r6
  4030ba:	490d      	ldr	r1, [pc, #52]	; (4030f0 <vTaskList+0xcc>)
  4030bc:	2253      	movs	r2, #83	; 0x53
  4030be:	4b09      	ldr	r3, [pc, #36]	; (4030e4 <vTaskList+0xc0>)
  4030c0:	4798      	blx	r3
				}
			}
			#endif
		}
		xTaskResumeAll();
  4030c2:	4b0c      	ldr	r3, [pc, #48]	; (4030f4 <vTaskList+0xd0>)
  4030c4:	4798      	blx	r3
  4030c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4030ca:	bf00      	nop
  4030cc:	00402cb5 	.word	0x00402cb5
  4030d0:	004044c1 	.word	0x004044c1
  4030d4:	00409d34 	.word	0x00409d34
  4030d8:	20004e48 	.word	0x20004e48
  4030dc:	20004cf8 	.word	0x20004cf8
  4030e0:	20004d74 	.word	0x20004d74
  4030e4:	00402851 	.word	0x00402851
  4030e8:	20004d5c 	.word	0x20004d5c
  4030ec:	20004d60 	.word	0x20004d60
  4030f0:	20004dd4 	.word	0x20004dd4
  4030f4:	00402e31 	.word	0x00402e31

004030f8 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
	{
  4030f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4030fc:	4607      	mov	r7, r0
	unsigned long ulTotalRunTime;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
  4030fe:	4b2a      	ldr	r3, [pc, #168]	; (4031a8 <vTaskGetRunTimeStats+0xb0>)
  403100:	4798      	blx	r3
		{
			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
			#else
				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
  403102:	4b2a      	ldr	r3, [pc, #168]	; (4031ac <vTaskGetRunTimeStats+0xb4>)
  403104:	4798      	blx	r3
			#endif

			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
			ulTotalRunTime /= 100UL;
  403106:	4e2a      	ldr	r6, [pc, #168]	; (4031b0 <vTaskGetRunTimeStats+0xb8>)
  403108:	fba6 3600 	umull	r3, r6, r6, r0
  40310c:	0976      	lsrs	r6, r6, #5

			/* Run through all the lists that could potentially contain a TCB,
			generating a table of run timer percentages in the provided
			buffer. */

			*pcWriteBuffer = ( signed char ) 0x00;
  40310e:	2300      	movs	r3, #0
  403110:	703b      	strb	r3, [r7, #0]
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
  403112:	4638      	mov	r0, r7
  403114:	4b27      	ldr	r3, [pc, #156]	; (4031b4 <vTaskGetRunTimeStats+0xbc>)
  403116:	4798      	blx	r3
  403118:	183a      	adds	r2, r7, r0
  40311a:	4b27      	ldr	r3, [pc, #156]	; (4031b8 <vTaskGetRunTimeStats+0xc0>)
  40311c:	8819      	ldrh	r1, [r3, #0]
  40311e:	789b      	ldrb	r3, [r3, #2]
  403120:	5239      	strh	r1, [r7, r0]
  403122:	7093      	strb	r3, [r2, #2]

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
  403124:	4b25      	ldr	r3, [pc, #148]	; (4031bc <vTaskGetRunTimeStats+0xc4>)
  403126:	681c      	ldr	r4, [r3, #0]
  403128:	3401      	adds	r4, #1
  40312a:	eb04 0584 	add.w	r5, r4, r4, lsl #2
  40312e:	4b24      	ldr	r3, [pc, #144]	; (4031c0 <vTaskGetRunTimeStats+0xc8>)
  403130:	eb03 0585 	add.w	r5, r3, r5, lsl #2
  403134:	3d14      	subs	r5, #20

			do
			{
				uxQueue--;

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  403136:	4698      	mov	r8, r3
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
  403138:	f8df 908c 	ldr.w	r9, [pc, #140]	; 4031c8 <vTaskGetRunTimeStats+0xd0>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;

			do
			{
				uxQueue--;
  40313c:	3c01      	subs	r4, #1

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  40313e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  403142:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
  403146:	b11b      	cbz	r3, 403150 <vTaskGetRunTimeStats+0x58>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
  403148:	4638      	mov	r0, r7
  40314a:	4629      	mov	r1, r5
  40314c:	4632      	mov	r2, r6
  40314e:	47c8      	blx	r9
  403150:	3d14      	subs	r5, #20
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
  403152:	2c00      	cmp	r4, #0
  403154:	d1f2      	bne.n	40313c <vTaskGetRunTimeStats+0x44>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
  403156:	4b1b      	ldr	r3, [pc, #108]	; (4031c4 <vTaskGetRunTimeStats+0xcc>)
  403158:	681b      	ldr	r3, [r3, #0]
  40315a:	681b      	ldr	r3, [r3, #0]
  40315c:	b12b      	cbz	r3, 40316a <vTaskGetRunTimeStats+0x72>
			{
				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRunTime );
  40315e:	4b19      	ldr	r3, [pc, #100]	; (4031c4 <vTaskGetRunTimeStats+0xcc>)
  403160:	6819      	ldr	r1, [r3, #0]
  403162:	4638      	mov	r0, r7
  403164:	4632      	mov	r2, r6
  403166:	4b18      	ldr	r3, [pc, #96]	; (4031c8 <vTaskGetRunTimeStats+0xd0>)
  403168:	4798      	blx	r3
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
  40316a:	4b18      	ldr	r3, [pc, #96]	; (4031cc <vTaskGetRunTimeStats+0xd4>)
  40316c:	681b      	ldr	r3, [r3, #0]
  40316e:	681b      	ldr	r3, [r3, #0]
  403170:	b12b      	cbz	r3, 40317e <vTaskGetRunTimeStats+0x86>
			{
				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ulTotalRunTime );
  403172:	4b16      	ldr	r3, [pc, #88]	; (4031cc <vTaskGetRunTimeStats+0xd4>)
  403174:	6819      	ldr	r1, [r3, #0]
  403176:	4638      	mov	r0, r7
  403178:	4632      	mov	r2, r6
  40317a:	4b13      	ldr	r3, [pc, #76]	; (4031c8 <vTaskGetRunTimeStats+0xd0>)
  40317c:	4798      	blx	r3
			}

			#if ( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
  40317e:	4b14      	ldr	r3, [pc, #80]	; (4031d0 <vTaskGetRunTimeStats+0xd8>)
  403180:	681b      	ldr	r3, [r3, #0]
  403182:	b123      	cbz	r3, 40318e <vTaskGetRunTimeStats+0x96>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTime );
  403184:	4638      	mov	r0, r7
  403186:	4912      	ldr	r1, [pc, #72]	; (4031d0 <vTaskGetRunTimeStats+0xd8>)
  403188:	4632      	mov	r2, r6
  40318a:	4b0f      	ldr	r3, [pc, #60]	; (4031c8 <vTaskGetRunTimeStats+0xd0>)
  40318c:	4798      	blx	r3
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
  40318e:	4b11      	ldr	r3, [pc, #68]	; (4031d4 <vTaskGetRunTimeStats+0xdc>)
  403190:	681b      	ldr	r3, [r3, #0]
  403192:	b123      	cbz	r3, 40319e <vTaskGetRunTimeStats+0xa6>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
  403194:	4638      	mov	r0, r7
  403196:	490f      	ldr	r1, [pc, #60]	; (4031d4 <vTaskGetRunTimeStats+0xdc>)
  403198:	4632      	mov	r2, r6
  40319a:	4b0b      	ldr	r3, [pc, #44]	; (4031c8 <vTaskGetRunTimeStats+0xd0>)
  40319c:	4798      	blx	r3
				}
			}
			#endif
		}
		xTaskResumeAll();
  40319e:	4b0e      	ldr	r3, [pc, #56]	; (4031d8 <vTaskGetRunTimeStats+0xe0>)
  4031a0:	4798      	blx	r3
  4031a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4031a6:	bf00      	nop
  4031a8:	00402cb5 	.word	0x00402cb5
  4031ac:	00403f91 	.word	0x00403f91
  4031b0:	51eb851f 	.word	0x51eb851f
  4031b4:	004044c1 	.word	0x004044c1
  4031b8:	00409d34 	.word	0x00409d34
  4031bc:	20004e48 	.word	0x20004e48
  4031c0:	20004cf8 	.word	0x20004cf8
  4031c4:	20004d74 	.word	0x20004d74
  4031c8:	004028e5 	.word	0x004028e5
  4031cc:	20004d5c 	.word	0x20004d5c
  4031d0:	20004d60 	.word	0x20004d60
  4031d4:	20004dd4 	.word	0x20004dd4
  4031d8:	00402e31 	.word	0x00402e31

004031dc <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  4031dc:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  4031de:	4b2d      	ldr	r3, [pc, #180]	; (403294 <vTaskSwitchContext+0xb8>)
  4031e0:	681b      	ldr	r3, [r3, #0]
  4031e2:	b11b      	cbz	r3, 4031ec <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  4031e4:	2201      	movs	r2, #1
  4031e6:	4b2c      	ldr	r3, [pc, #176]	; (403298 <vTaskSwitchContext+0xbc>)
  4031e8:	601a      	str	r2, [r3, #0]
  4031ea:	bd38      	pop	{r3, r4, r5, pc}
			unsigned long ulTempCounter;

				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
  4031ec:	4b2b      	ldr	r3, [pc, #172]	; (40329c <vTaskSwitchContext+0xc0>)
  4031ee:	4798      	blx	r3
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
  4031f0:	4a2b      	ldr	r2, [pc, #172]	; (4032a0 <vTaskSwitchContext+0xc4>)
  4031f2:	6814      	ldr	r4, [r2, #0]
  4031f4:	492b      	ldr	r1, [pc, #172]	; (4032a4 <vTaskSwitchContext+0xc8>)
  4031f6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  4031f8:	680d      	ldr	r5, [r1, #0]
  4031fa:	1b5b      	subs	r3, r3, r5
  4031fc:	4403      	add	r3, r0
  4031fe:	64e3      	str	r3, [r4, #76]	; 0x4c
				ulTaskSwitchedInTime = ulTempCounter;
  403200:	6008      	str	r0, [r1, #0]
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
  403202:	6811      	ldr	r1, [r2, #0]
  403204:	6813      	ldr	r3, [r2, #0]
  403206:	680a      	ldr	r2, [r1, #0]
  403208:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40320a:	429a      	cmp	r2, r3
  40320c:	d805      	bhi.n	40321a <vTaskSwitchContext+0x3e>
  40320e:	4b24      	ldr	r3, [pc, #144]	; (4032a0 <vTaskSwitchContext+0xc4>)
  403210:	6818      	ldr	r0, [r3, #0]
  403212:	6819      	ldr	r1, [r3, #0]
  403214:	3134      	adds	r1, #52	; 0x34
  403216:	4b24      	ldr	r3, [pc, #144]	; (4032a8 <vTaskSwitchContext+0xcc>)
  403218:	4798      	blx	r3
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
  40321a:	4b21      	ldr	r3, [pc, #132]	; (4032a0 <vTaskSwitchContext+0xc4>)
  40321c:	681b      	ldr	r3, [r3, #0]
  40321e:	6b18      	ldr	r0, [r3, #48]	; 0x30
  403220:	4922      	ldr	r1, [pc, #136]	; (4032ac <vTaskSwitchContext+0xd0>)
  403222:	2214      	movs	r2, #20
  403224:	4b22      	ldr	r3, [pc, #136]	; (4032b0 <vTaskSwitchContext+0xd4>)
  403226:	4798      	blx	r3
  403228:	b128      	cbz	r0, 403236 <vTaskSwitchContext+0x5a>
  40322a:	4b1d      	ldr	r3, [pc, #116]	; (4032a0 <vTaskSwitchContext+0xc4>)
  40322c:	6818      	ldr	r0, [r3, #0]
  40322e:	6819      	ldr	r1, [r3, #0]
  403230:	3134      	adds	r1, #52	; 0x34
  403232:	4b1d      	ldr	r3, [pc, #116]	; (4032a8 <vTaskSwitchContext+0xcc>)
  403234:	4798      	blx	r3

		taskSELECT_HIGHEST_PRIORITY_TASK();
  403236:	4b1f      	ldr	r3, [pc, #124]	; (4032b4 <vTaskSwitchContext+0xd8>)
  403238:	681c      	ldr	r4, [r3, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline unsigned char ucPortCountLeadingZeros( unsigned long ulBitmap )
	{
	unsigned char ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
  40323a:	fab4 f484 	clz	r4, r4
  40323e:	b2e4      	uxtb	r4, r4
  403240:	f1c4 041f 	rsb	r4, r4, #31
  403244:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  403248:	009b      	lsls	r3, r3, #2
  40324a:	4a1b      	ldr	r2, [pc, #108]	; (4032b8 <vTaskSwitchContext+0xdc>)
  40324c:	58d3      	ldr	r3, [r2, r3]
  40324e:	b923      	cbnz	r3, 40325a <vTaskSwitchContext+0x7e>
  403250:	481a      	ldr	r0, [pc, #104]	; (4032bc <vTaskSwitchContext+0xe0>)
  403252:	f240 713e 	movw	r1, #1854	; 0x73e
  403256:	4b1a      	ldr	r3, [pc, #104]	; (4032c0 <vTaskSwitchContext+0xe4>)
  403258:	4798      	blx	r3
  40325a:	4b17      	ldr	r3, [pc, #92]	; (4032b8 <vTaskSwitchContext+0xdc>)
  40325c:	00a2      	lsls	r2, r4, #2
  40325e:	1911      	adds	r1, r2, r4
  403260:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  403264:	6848      	ldr	r0, [r1, #4]
  403266:	6840      	ldr	r0, [r0, #4]
  403268:	6048      	str	r0, [r1, #4]
  40326a:	460b      	mov	r3, r1
  40326c:	3308      	adds	r3, #8
  40326e:	4298      	cmp	r0, r3
  403270:	d106      	bne.n	403280 <vTaskSwitchContext+0xa4>
  403272:	6841      	ldr	r1, [r0, #4]
  403274:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  403278:	4a0f      	ldr	r2, [pc, #60]	; (4032b8 <vTaskSwitchContext+0xdc>)
  40327a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  40327e:	6059      	str	r1, [r3, #4]
  403280:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  403284:	4b0c      	ldr	r3, [pc, #48]	; (4032b8 <vTaskSwitchContext+0xdc>)
  403286:	eb03 0484 	add.w	r4, r3, r4, lsl #2
  40328a:	6863      	ldr	r3, [r4, #4]
  40328c:	68da      	ldr	r2, [r3, #12]
  40328e:	4b04      	ldr	r3, [pc, #16]	; (4032a0 <vTaskSwitchContext+0xc4>)
  403290:	601a      	str	r2, [r3, #0]
  403292:	bd38      	pop	{r3, r4, r5, pc}
  403294:	20004e3c 	.word	0x20004e3c
  403298:	20004d94 	.word	0x20004d94
  40329c:	00403f91 	.word	0x00403f91
  4032a0:	20004d9c 	.word	0x20004d9c
  4032a4:	20004d90 	.word	0x20004d90
  4032a8:	00403dd5 	.word	0x00403dd5
  4032ac:	004099b8 	.word	0x004099b8
  4032b0:	0040403d 	.word	0x0040403d
  4032b4:	20004cec 	.word	0x20004cec
  4032b8:	20004cf8 	.word	0x20004cf8
  4032bc:	00409a10 	.word	0x00409a10
  4032c0:	00403de1 	.word	0x00403de1

004032c4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  4032c4:	b570      	push	{r4, r5, r6, lr}
  4032c6:	460d      	mov	r5, r1
portTickType xTimeToWake;

	configASSERT( pxEventList );
  4032c8:	4606      	mov	r6, r0
  4032ca:	b920      	cbnz	r0, 4032d6 <vTaskPlaceOnEventList+0x12>
  4032cc:	4814      	ldr	r0, [pc, #80]	; (403320 <vTaskPlaceOnEventList+0x5c>)
  4032ce:	f240 7149 	movw	r1, #1865	; 0x749
  4032d2:	4b14      	ldr	r3, [pc, #80]	; (403324 <vTaskPlaceOnEventList+0x60>)
  4032d4:	4798      	blx	r3
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  4032d6:	4c14      	ldr	r4, [pc, #80]	; (403328 <vTaskPlaceOnEventList+0x64>)
  4032d8:	6821      	ldr	r1, [r4, #0]
  4032da:	4630      	mov	r0, r6
  4032dc:	3118      	adds	r1, #24
  4032de:	4b13      	ldr	r3, [pc, #76]	; (40332c <vTaskPlaceOnEventList+0x68>)
  4032e0:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  4032e2:	6820      	ldr	r0, [r4, #0]
  4032e4:	3004      	adds	r0, #4
  4032e6:	4b12      	ldr	r3, [pc, #72]	; (403330 <vTaskPlaceOnEventList+0x6c>)
  4032e8:	4798      	blx	r3
  4032ea:	b940      	cbnz	r0, 4032fe <vTaskPlaceOnEventList+0x3a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  4032ec:	6823      	ldr	r3, [r4, #0]
  4032ee:	4911      	ldr	r1, [pc, #68]	; (403334 <vTaskPlaceOnEventList+0x70>)
  4032f0:	680a      	ldr	r2, [r1, #0]
  4032f2:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  4032f4:	2301      	movs	r3, #1
  4032f6:	4083      	lsls	r3, r0
  4032f8:	ea22 0303 	bic.w	r3, r2, r3
  4032fc:	600b      	str	r3, [r1, #0]
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  4032fe:	f1b5 3fff 	cmp.w	r5, #4294967295
  403302:	d106      	bne.n	403312 <vTaskPlaceOnEventList+0x4e>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  403304:	4b08      	ldr	r3, [pc, #32]	; (403328 <vTaskPlaceOnEventList+0x64>)
  403306:	6819      	ldr	r1, [r3, #0]
  403308:	480b      	ldr	r0, [pc, #44]	; (403338 <vTaskPlaceOnEventList+0x74>)
  40330a:	3104      	adds	r1, #4
  40330c:	4b0b      	ldr	r3, [pc, #44]	; (40333c <vTaskPlaceOnEventList+0x78>)
  40330e:	4798      	blx	r3
  403310:	bd70      	pop	{r4, r5, r6, pc}
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  403312:	4b0b      	ldr	r3, [pc, #44]	; (403340 <vTaskPlaceOnEventList+0x7c>)
  403314:	6818      	ldr	r0, [r3, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  403316:	4428      	add	r0, r5
  403318:	4b0a      	ldr	r3, [pc, #40]	; (403344 <vTaskPlaceOnEventList+0x80>)
  40331a:	4798      	blx	r3
  40331c:	bd70      	pop	{r4, r5, r6, pc}
  40331e:	bf00      	nop
  403320:	00409a10 	.word	0x00409a10
  403324:	00403de1 	.word	0x00403de1
  403328:	20004d9c 	.word	0x20004d9c
  40332c:	00401e79 	.word	0x00401e79
  403330:	00401eb5 	.word	0x00401eb5
  403334:	20004cec 	.word	0x20004cec
  403338:	20004dd4 	.word	0x20004dd4
  40333c:	00401e5d 	.word	0x00401e5d
  403340:	20004cf4 	.word	0x20004cf4
  403344:	004027f9 	.word	0x004027f9

00403348 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
  403348:	b570      	push	{r4, r5, r6, lr}
  40334a:	460d      	mov	r5, r1
	portTickType xTimeToWake;

		configASSERT( pxEventList );
  40334c:	4606      	mov	r6, r0
  40334e:	b920      	cbnz	r0, 40335a <vTaskPlaceOnEventListRestricted+0x12>
  403350:	480f      	ldr	r0, [pc, #60]	; (403390 <vTaskPlaceOnEventListRestricted+0x48>)
  403352:	f240 717f 	movw	r1, #1919	; 0x77f
  403356:	4b0f      	ldr	r3, [pc, #60]	; (403394 <vTaskPlaceOnEventListRestricted+0x4c>)
  403358:	4798      	blx	r3

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  40335a:	4c0f      	ldr	r4, [pc, #60]	; (403398 <vTaskPlaceOnEventListRestricted+0x50>)
  40335c:	6821      	ldr	r1, [r4, #0]
  40335e:	4630      	mov	r0, r6
  403360:	3118      	adds	r1, #24
  403362:	4b0e      	ldr	r3, [pc, #56]	; (40339c <vTaskPlaceOnEventListRestricted+0x54>)
  403364:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  403366:	6820      	ldr	r0, [r4, #0]
  403368:	3004      	adds	r0, #4
  40336a:	4b0d      	ldr	r3, [pc, #52]	; (4033a0 <vTaskPlaceOnEventListRestricted+0x58>)
  40336c:	4798      	blx	r3
  40336e:	b940      	cbnz	r0, 403382 <vTaskPlaceOnEventListRestricted+0x3a>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  403370:	6823      	ldr	r3, [r4, #0]
  403372:	490c      	ldr	r1, [pc, #48]	; (4033a4 <vTaskPlaceOnEventListRestricted+0x5c>)
  403374:	680a      	ldr	r2, [r1, #0]
  403376:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  403378:	2301      	movs	r3, #1
  40337a:	4083      	lsls	r3, r0
  40337c:	ea22 0303 	bic.w	r3, r2, r3
  403380:	600b      	str	r3, [r1, #0]
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  403382:	4b09      	ldr	r3, [pc, #36]	; (4033a8 <vTaskPlaceOnEventListRestricted+0x60>)
  403384:	6818      	ldr	r0, [r3, #0]
		
		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  403386:	4428      	add	r0, r5
  403388:	4b08      	ldr	r3, [pc, #32]	; (4033ac <vTaskPlaceOnEventListRestricted+0x64>)
  40338a:	4798      	blx	r3
  40338c:	bd70      	pop	{r4, r5, r6, pc}
  40338e:	bf00      	nop
  403390:	00409a10 	.word	0x00409a10
  403394:	00403de1 	.word	0x00403de1
  403398:	20004d9c 	.word	0x20004d9c
  40339c:	00401e5d 	.word	0x00401e5d
  4033a0:	00401eb5 	.word	0x00401eb5
  4033a4:	20004cec 	.word	0x20004cec
  4033a8:	20004cf4 	.word	0x20004cf4
  4033ac:	004027f9 	.word	0x004027f9

004033b0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  4033b0:	b538      	push	{r3, r4, r5, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  4033b2:	68c3      	ldr	r3, [r0, #12]
  4033b4:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
  4033b6:	b924      	cbnz	r4, 4033c2 <xTaskRemoveFromEventList+0x12>
  4033b8:	4816      	ldr	r0, [pc, #88]	; (403414 <xTaskRemoveFromEventList+0x64>)
  4033ba:	f240 71b5 	movw	r1, #1973	; 0x7b5
  4033be:	4b16      	ldr	r3, [pc, #88]	; (403418 <xTaskRemoveFromEventList+0x68>)
  4033c0:	4798      	blx	r3
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  4033c2:	f104 0518 	add.w	r5, r4, #24
  4033c6:	4628      	mov	r0, r5
  4033c8:	4b14      	ldr	r3, [pc, #80]	; (40341c <xTaskRemoveFromEventList+0x6c>)
  4033ca:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4033cc:	4b14      	ldr	r3, [pc, #80]	; (403420 <xTaskRemoveFromEventList+0x70>)
  4033ce:	681b      	ldr	r3, [r3, #0]
  4033d0:	b99b      	cbnz	r3, 4033fa <xTaskRemoveFromEventList+0x4a>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  4033d2:	1d25      	adds	r5, r4, #4
  4033d4:	4628      	mov	r0, r5
  4033d6:	4b11      	ldr	r3, [pc, #68]	; (40341c <xTaskRemoveFromEventList+0x6c>)
  4033d8:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  4033da:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4033dc:	4911      	ldr	r1, [pc, #68]	; (403424 <xTaskRemoveFromEventList+0x74>)
  4033de:	680a      	ldr	r2, [r1, #0]
  4033e0:	2301      	movs	r3, #1
  4033e2:	4083      	lsls	r3, r0
  4033e4:	4313      	orrs	r3, r2
  4033e6:	600b      	str	r3, [r1, #0]
  4033e8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4033ec:	4b0e      	ldr	r3, [pc, #56]	; (403428 <xTaskRemoveFromEventList+0x78>)
  4033ee:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4033f2:	4629      	mov	r1, r5
  4033f4:	4b0d      	ldr	r3, [pc, #52]	; (40342c <xTaskRemoveFromEventList+0x7c>)
  4033f6:	4798      	blx	r3
  4033f8:	e003      	b.n	403402 <xTaskRemoveFromEventList+0x52>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  4033fa:	480d      	ldr	r0, [pc, #52]	; (403430 <xTaskRemoveFromEventList+0x80>)
  4033fc:	4629      	mov	r1, r5
  4033fe:	4b0b      	ldr	r3, [pc, #44]	; (40342c <xTaskRemoveFromEventList+0x7c>)
  403400:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  403402:	4b0c      	ldr	r3, [pc, #48]	; (403434 <xTaskRemoveFromEventList+0x84>)
  403404:	681b      	ldr	r3, [r3, #0]
  403406:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  403408:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
  40340a:	4298      	cmp	r0, r3
  40340c:	bf34      	ite	cc
  40340e:	2000      	movcc	r0, #0
  403410:	2001      	movcs	r0, #1
  403412:	bd38      	pop	{r3, r4, r5, pc}
  403414:	00409a10 	.word	0x00409a10
  403418:	00403de1 	.word	0x00403de1
  40341c:	00401eb5 	.word	0x00401eb5
  403420:	20004e3c 	.word	0x20004e3c
  403424:	20004cec 	.word	0x20004cec
  403428:	20004cf8 	.word	0x20004cf8
  40342c:	00401e5d 	.word	0x00401e5d
  403430:	20004d78 	.word	0x20004d78
  403434:	20004d9c 	.word	0x20004d9c

00403438 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
  403438:	b510      	push	{r4, lr}
	configASSERT( pxTimeOut );
  40343a:	4604      	mov	r4, r0
  40343c:	b920      	cbnz	r0, 403448 <vTaskSetTimeOutState+0x10>
  40343e:	4806      	ldr	r0, [pc, #24]	; (403458 <vTaskSetTimeOutState+0x20>)
  403440:	f240 71d7 	movw	r1, #2007	; 0x7d7
  403444:	4b05      	ldr	r3, [pc, #20]	; (40345c <vTaskSetTimeOutState+0x24>)
  403446:	4798      	blx	r3
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  403448:	4b05      	ldr	r3, [pc, #20]	; (403460 <vTaskSetTimeOutState+0x28>)
  40344a:	681b      	ldr	r3, [r3, #0]
  40344c:	6023      	str	r3, [r4, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  40344e:	4b05      	ldr	r3, [pc, #20]	; (403464 <vTaskSetTimeOutState+0x2c>)
  403450:	681b      	ldr	r3, [r3, #0]
  403452:	6063      	str	r3, [r4, #4]
  403454:	bd10      	pop	{r4, pc}
  403456:	bf00      	nop
  403458:	00409a10 	.word	0x00409a10
  40345c:	00403de1 	.word	0x00403de1
  403460:	20004e44 	.word	0x20004e44
  403464:	20004cf4 	.word	0x20004cf4

00403468 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  403468:	b538      	push	{r3, r4, r5, lr}
  40346a:	460c      	mov	r4, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
  40346c:	4605      	mov	r5, r0
  40346e:	b920      	cbnz	r0, 40347a <xTaskCheckForTimeOut+0x12>
  403470:	4819      	ldr	r0, [pc, #100]	; (4034d8 <xTaskCheckForTimeOut+0x70>)
  403472:	f240 71e1 	movw	r1, #2017	; 0x7e1
  403476:	4b19      	ldr	r3, [pc, #100]	; (4034dc <xTaskCheckForTimeOut+0x74>)
  403478:	4798      	blx	r3
	configASSERT( pxTicksToWait );
  40347a:	b924      	cbnz	r4, 403486 <xTaskCheckForTimeOut+0x1e>
  40347c:	4816      	ldr	r0, [pc, #88]	; (4034d8 <xTaskCheckForTimeOut+0x70>)
  40347e:	f240 71e2 	movw	r1, #2018	; 0x7e2
  403482:	4b16      	ldr	r3, [pc, #88]	; (4034dc <xTaskCheckForTimeOut+0x74>)
  403484:	4798      	blx	r3

	taskENTER_CRITICAL();
  403486:	4b16      	ldr	r3, [pc, #88]	; (4034e0 <xTaskCheckForTimeOut+0x78>)
  403488:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  40348a:	6823      	ldr	r3, [r4, #0]
  40348c:	f1b3 3fff 	cmp.w	r3, #4294967295
  403490:	d019      	beq.n	4034c6 <xTaskCheckForTimeOut+0x5e>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
  403492:	4a14      	ldr	r2, [pc, #80]	; (4034e4 <xTaskCheckForTimeOut+0x7c>)
  403494:	6812      	ldr	r2, [r2, #0]
  403496:	6829      	ldr	r1, [r5, #0]
  403498:	4291      	cmp	r1, r2
  40349a:	d004      	beq.n	4034a6 <xTaskCheckForTimeOut+0x3e>
  40349c:	4a12      	ldr	r2, [pc, #72]	; (4034e8 <xTaskCheckForTimeOut+0x80>)
  40349e:	6812      	ldr	r2, [r2, #0]
  4034a0:	6869      	ldr	r1, [r5, #4]
  4034a2:	4291      	cmp	r1, r2
  4034a4:	d911      	bls.n	4034ca <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  4034a6:	4a10      	ldr	r2, [pc, #64]	; (4034e8 <xTaskCheckForTimeOut+0x80>)
  4034a8:	6812      	ldr	r2, [r2, #0]
  4034aa:	6869      	ldr	r1, [r5, #4]
  4034ac:	1a52      	subs	r2, r2, r1
  4034ae:	4293      	cmp	r3, r2
  4034b0:	d90d      	bls.n	4034ce <xTaskCheckForTimeOut+0x66>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  4034b2:	4a0d      	ldr	r2, [pc, #52]	; (4034e8 <xTaskCheckForTimeOut+0x80>)
  4034b4:	6812      	ldr	r2, [r2, #0]
  4034b6:	1a51      	subs	r1, r2, r1
  4034b8:	1a5b      	subs	r3, r3, r1
  4034ba:	6023      	str	r3, [r4, #0]
			vTaskSetTimeOutState( pxTimeOut );
  4034bc:	4628      	mov	r0, r5
  4034be:	4b0b      	ldr	r3, [pc, #44]	; (4034ec <xTaskCheckForTimeOut+0x84>)
  4034c0:	4798      	blx	r3
			xReturn = pdFALSE;
  4034c2:	2400      	movs	r4, #0
  4034c4:	e004      	b.n	4034d0 <xTaskCheckForTimeOut+0x68>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
  4034c6:	2400      	movs	r4, #0
  4034c8:	e002      	b.n	4034d0 <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  4034ca:	2401      	movs	r4, #1
  4034cc:	e000      	b.n	4034d0 <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
  4034ce:	2401      	movs	r4, #1
		}
	}
	taskEXIT_CRITICAL();
  4034d0:	4b07      	ldr	r3, [pc, #28]	; (4034f0 <xTaskCheckForTimeOut+0x88>)
  4034d2:	4798      	blx	r3

	return xReturn;
}
  4034d4:	4620      	mov	r0, r4
  4034d6:	bd38      	pop	{r3, r4, r5, pc}
  4034d8:	00409a10 	.word	0x00409a10
  4034dc:	00403de1 	.word	0x00403de1
  4034e0:	00401f65 	.word	0x00401f65
  4034e4:	20004e44 	.word	0x20004e44
  4034e8:	20004cf4 	.word	0x20004cf4
  4034ec:	00403439 	.word	0x00403439
  4034f0:	00401f85 	.word	0x00401f85

004034f4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
  4034f4:	2201      	movs	r2, #1
  4034f6:	4b01      	ldr	r3, [pc, #4]	; (4034fc <vTaskMissedYield+0x8>)
  4034f8:	601a      	str	r2, [r3, #0]
  4034fa:	4770      	bx	lr
  4034fc:	20004d94 	.word	0x20004d94

00403500 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  403500:	4b01      	ldr	r3, [pc, #4]	; (403508 <xTaskGetCurrentTaskHandle+0x8>)
  403502:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
  403504:	4770      	bx	lr
  403506:	bf00      	nop
  403508:	20004d9c 	.word	0x20004d9c

0040350c <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
  40350c:	4b05      	ldr	r3, [pc, #20]	; (403524 <xTaskGetSchedulerState+0x18>)
  40350e:	681b      	ldr	r3, [r3, #0]
  403510:	b133      	cbz	r3, 403520 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  403512:	4b05      	ldr	r3, [pc, #20]	; (403528 <xTaskGetSchedulerState+0x1c>)
  403514:	681b      	ldr	r3, [r3, #0]
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  403516:	2b00      	cmp	r3, #0
  403518:	bf0c      	ite	eq
  40351a:	2001      	moveq	r0, #1
  40351c:	2002      	movne	r0, #2
  40351e:	4770      	bx	lr
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  403520:	2000      	movs	r0, #0
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
  403522:	4770      	bx	lr
  403524:	20004d8c 	.word	0x20004d8c
  403528:	20004e3c 	.word	0x20004e3c

0040352c <vTaskPriorityInherit>:
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  40352c:	2800      	cmp	r0, #0
  40352e:	d040      	beq.n	4035b2 <vTaskPriorityInherit+0x86>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  403530:	b538      	push	{r3, r4, r5, lr}

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  403532:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  403534:	491f      	ldr	r1, [pc, #124]	; (4035b4 <vTaskPriorityInherit+0x88>)
  403536:	6809      	ldr	r1, [r1, #0]
  403538:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  40353a:	428b      	cmp	r3, r1
  40353c:	d238      	bcs.n	4035b0 <vTaskPriorityInherit+0x84>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  40353e:	491d      	ldr	r1, [pc, #116]	; (4035b4 <vTaskPriorityInherit+0x88>)
  403540:	6809      	ldr	r1, [r1, #0]
  403542:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  403544:	f1c1 0105 	rsb	r1, r1, #5
  403548:	6181      	str	r1, [r0, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  40354a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40354e:	491a      	ldr	r1, [pc, #104]	; (4035b8 <vTaskPriorityInherit+0x8c>)
  403550:	eb01 0383 	add.w	r3, r1, r3, lsl #2
  403554:	6941      	ldr	r1, [r0, #20]
  403556:	4299      	cmp	r1, r3
  403558:	d126      	bne.n	4035a8 <vTaskPriorityInherit+0x7c>
  40355a:	4604      	mov	r4, r0
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  40355c:	1d05      	adds	r5, r0, #4
  40355e:	4628      	mov	r0, r5
  403560:	4b16      	ldr	r3, [pc, #88]	; (4035bc <vTaskPriorityInherit+0x90>)
  403562:	4798      	blx	r3
  403564:	b968      	cbnz	r0, 403582 <vTaskPriorityInherit+0x56>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  403566:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  403568:	eb02 0382 	add.w	r3, r2, r2, lsl #2
  40356c:	009b      	lsls	r3, r3, #2
  40356e:	4912      	ldr	r1, [pc, #72]	; (4035b8 <vTaskPriorityInherit+0x8c>)
  403570:	58cb      	ldr	r3, [r1, r3]
  403572:	b933      	cbnz	r3, 403582 <vTaskPriorityInherit+0x56>
  403574:	4812      	ldr	r0, [pc, #72]	; (4035c0 <vTaskPriorityInherit+0x94>)
  403576:	6801      	ldr	r1, [r0, #0]
  403578:	2301      	movs	r3, #1
  40357a:	4093      	lsls	r3, r2
  40357c:	ea21 0303 	bic.w	r3, r1, r3
  403580:	6003      	str	r3, [r0, #0]
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403582:	4b0c      	ldr	r3, [pc, #48]	; (4035b4 <vTaskPriorityInherit+0x88>)
  403584:	681b      	ldr	r3, [r3, #0]
  403586:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  403588:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
  40358a:	490d      	ldr	r1, [pc, #52]	; (4035c0 <vTaskPriorityInherit+0x94>)
  40358c:	680a      	ldr	r2, [r1, #0]
  40358e:	2301      	movs	r3, #1
  403590:	4083      	lsls	r3, r0
  403592:	4313      	orrs	r3, r2
  403594:	600b      	str	r3, [r1, #0]
  403596:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40359a:	4b07      	ldr	r3, [pc, #28]	; (4035b8 <vTaskPriorityInherit+0x8c>)
  40359c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4035a0:	4629      	mov	r1, r5
  4035a2:	4b08      	ldr	r3, [pc, #32]	; (4035c4 <vTaskPriorityInherit+0x98>)
  4035a4:	4798      	blx	r3
  4035a6:	bd38      	pop	{r3, r4, r5, pc}
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4035a8:	4b02      	ldr	r3, [pc, #8]	; (4035b4 <vTaskPriorityInherit+0x88>)
  4035aa:	681b      	ldr	r3, [r3, #0]
  4035ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4035ae:	62c3      	str	r3, [r0, #44]	; 0x2c
  4035b0:	bd38      	pop	{r3, r4, r5, pc}
  4035b2:	4770      	bx	lr
  4035b4:	20004d9c 	.word	0x20004d9c
  4035b8:	20004cf8 	.word	0x20004cf8
  4035bc:	00401eb5 	.word	0x00401eb5
  4035c0:	20004cec 	.word	0x20004cec
  4035c4:	00401e5d 	.word	0x00401e5d

004035c8 <vTaskPriorityDisinherit>:

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
  4035c8:	2800      	cmp	r0, #0
  4035ca:	d02c      	beq.n	403626 <vTaskPriorityDisinherit+0x5e>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
  4035cc:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  4035ce:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  4035d0:	6c82      	ldr	r2, [r0, #72]	; 0x48
  4035d2:	4291      	cmp	r1, r2
  4035d4:	d026      	beq.n	403624 <vTaskPriorityDisinherit+0x5c>
  4035d6:	4604      	mov	r4, r0
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  4035d8:	1d05      	adds	r5, r0, #4
  4035da:	4628      	mov	r0, r5
  4035dc:	4b12      	ldr	r3, [pc, #72]	; (403628 <vTaskPriorityDisinherit+0x60>)
  4035de:	4798      	blx	r3
  4035e0:	b968      	cbnz	r0, 4035fe <vTaskPriorityDisinherit+0x36>
				{
					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  4035e2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4035e4:	eb02 0382 	add.w	r3, r2, r2, lsl #2
  4035e8:	009b      	lsls	r3, r3, #2
  4035ea:	4910      	ldr	r1, [pc, #64]	; (40362c <vTaskPriorityDisinherit+0x64>)
  4035ec:	58cb      	ldr	r3, [r1, r3]
  4035ee:	b933      	cbnz	r3, 4035fe <vTaskPriorityDisinherit+0x36>
  4035f0:	480f      	ldr	r0, [pc, #60]	; (403630 <vTaskPriorityDisinherit+0x68>)
  4035f2:	6801      	ldr	r1, [r0, #0]
  4035f4:	2301      	movs	r3, #1
  4035f6:	4093      	lsls	r3, r2
  4035f8:	ea21 0303 	bic.w	r3, r1, r3
  4035fc:	6003      	str	r3, [r0, #0]
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  4035fe:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403600:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  403602:	f1c3 0205 	rsb	r2, r3, #5
  403606:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
  403608:	4809      	ldr	r0, [pc, #36]	; (403630 <vTaskPriorityDisinherit+0x68>)
  40360a:	6801      	ldr	r1, [r0, #0]
  40360c:	2201      	movs	r2, #1
  40360e:	409a      	lsls	r2, r3
  403610:	430a      	orrs	r2, r1
  403612:	6002      	str	r2, [r0, #0]
  403614:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  403618:	4804      	ldr	r0, [pc, #16]	; (40362c <vTaskPriorityDisinherit+0x64>)
  40361a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  40361e:	4629      	mov	r1, r5
  403620:	4b04      	ldr	r3, [pc, #16]	; (403634 <vTaskPriorityDisinherit+0x6c>)
  403622:	4798      	blx	r3
  403624:	bd38      	pop	{r3, r4, r5, pc}
  403626:	4770      	bx	lr
  403628:	00401eb5 	.word	0x00401eb5
  40362c:	20004cf8 	.word	0x20004cf8
  403630:	20004cec 	.word	0x20004cec
  403634:	00401e5d 	.word	0x00401e5d

00403638 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
  403638:	b510      	push	{r4, lr}
  40363a:	4604      	mov	r4, r0
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  40363c:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  40363e:	6120      	str	r0, [r4, #16]

	if( xNextExpiryTime <= xTimeNow )
  403640:	4291      	cmp	r1, r2
  403642:	d80a      	bhi.n	40365a <prvInsertTimerInActiveList+0x22>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
  403644:	1ad2      	subs	r2, r2, r3
  403646:	6983      	ldr	r3, [r0, #24]
  403648:	429a      	cmp	r2, r3
  40364a:	d211      	bcs.n	403670 <prvInsertTimerInActiveList+0x38>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  40364c:	4b0a      	ldr	r3, [pc, #40]	; (403678 <prvInsertTimerInActiveList+0x40>)
  40364e:	6818      	ldr	r0, [r3, #0]
  403650:	1d21      	adds	r1, r4, #4
  403652:	4b0a      	ldr	r3, [pc, #40]	; (40367c <prvInsertTimerInActiveList+0x44>)
  403654:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
  403656:	2000      	movs	r0, #0
  403658:	bd10      	pop	{r4, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  40365a:	429a      	cmp	r2, r3
  40365c:	d201      	bcs.n	403662 <prvInsertTimerInActiveList+0x2a>
  40365e:	4299      	cmp	r1, r3
  403660:	d208      	bcs.n	403674 <prvInsertTimerInActiveList+0x3c>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  403662:	4b07      	ldr	r3, [pc, #28]	; (403680 <prvInsertTimerInActiveList+0x48>)
  403664:	6818      	ldr	r0, [r3, #0]
  403666:	1d21      	adds	r1, r4, #4
  403668:	4b04      	ldr	r3, [pc, #16]	; (40367c <prvInsertTimerInActiveList+0x44>)
  40366a:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
  40366c:	2000      	movs	r0, #0
  40366e:	bd10      	pop	{r4, pc}
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  403670:	2001      	movs	r0, #1
  403672:	bd10      	pop	{r4, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  403674:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
  403676:	bd10      	pop	{r4, pc}
  403678:	20004e80 	.word	0x20004e80
  40367c:	00401e79 	.word	0x00401e79
  403680:	20004e4c 	.word	0x20004e4c

00403684 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  403684:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  403686:	4b0d      	ldr	r3, [pc, #52]	; (4036bc <prvCheckForValidListAndQueue+0x38>)
  403688:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  40368a:	4b0d      	ldr	r3, [pc, #52]	; (4036c0 <prvCheckForValidListAndQueue+0x3c>)
  40368c:	681b      	ldr	r3, [r3, #0]
  40368e:	b98b      	cbnz	r3, 4036b4 <prvCheckForValidListAndQueue+0x30>
		{
			vListInitialise( &xActiveTimerList1 );
  403690:	4d0c      	ldr	r5, [pc, #48]	; (4036c4 <prvCheckForValidListAndQueue+0x40>)
  403692:	4628      	mov	r0, r5
  403694:	4e0c      	ldr	r6, [pc, #48]	; (4036c8 <prvCheckForValidListAndQueue+0x44>)
  403696:	47b0      	blx	r6
			vListInitialise( &xActiveTimerList2 );
  403698:	4c0c      	ldr	r4, [pc, #48]	; (4036cc <prvCheckForValidListAndQueue+0x48>)
  40369a:	4620      	mov	r0, r4
  40369c:	47b0      	blx	r6
			pxCurrentTimerList = &xActiveTimerList1;
  40369e:	4b0c      	ldr	r3, [pc, #48]	; (4036d0 <prvCheckForValidListAndQueue+0x4c>)
  4036a0:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  4036a2:	4b0c      	ldr	r3, [pc, #48]	; (4036d4 <prvCheckForValidListAndQueue+0x50>)
  4036a4:	601c      	str	r4, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  4036a6:	2005      	movs	r0, #5
  4036a8:	210c      	movs	r1, #12
  4036aa:	2200      	movs	r2, #0
  4036ac:	4b0a      	ldr	r3, [pc, #40]	; (4036d8 <prvCheckForValidListAndQueue+0x54>)
  4036ae:	4798      	blx	r3
  4036b0:	4b03      	ldr	r3, [pc, #12]	; (4036c0 <prvCheckForValidListAndQueue+0x3c>)
  4036b2:	6018      	str	r0, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
  4036b4:	4b09      	ldr	r3, [pc, #36]	; (4036dc <prvCheckForValidListAndQueue+0x58>)
  4036b6:	4798      	blx	r3
  4036b8:	bd70      	pop	{r4, r5, r6, pc}
  4036ba:	bf00      	nop
  4036bc:	00401f65 	.word	0x00401f65
  4036c0:	20004e7c 	.word	0x20004e7c
  4036c4:	20004e50 	.word	0x20004e50
  4036c8:	00401e3d 	.word	0x00401e3d
  4036cc:	20004e64 	.word	0x20004e64
  4036d0:	20004e4c 	.word	0x20004e4c
  4036d4:	20004e80 	.word	0x20004e80
  4036d8:	00402385 	.word	0x00402385
  4036dc:	00401f85 	.word	0x00401f85

004036e0 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
  4036e0:	b510      	push	{r4, lr}
  4036e2:	b084      	sub	sp, #16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  4036e4:	4b0d      	ldr	r3, [pc, #52]	; (40371c <xTimerCreateTimerTask+0x3c>)
  4036e6:	4798      	blx	r3

	if( xTimerQueue != NULL )
  4036e8:	4b0d      	ldr	r3, [pc, #52]	; (403720 <xTimerCreateTimerTask+0x40>)
  4036ea:	681b      	ldr	r3, [r3, #0]
  4036ec:	b16b      	cbz	r3, 40370a <xTimerCreateTimerTask+0x2a>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
  4036ee:	2304      	movs	r3, #4
  4036f0:	9300      	str	r3, [sp, #0]
  4036f2:	2300      	movs	r3, #0
  4036f4:	9301      	str	r3, [sp, #4]
  4036f6:	9302      	str	r3, [sp, #8]
  4036f8:	9303      	str	r3, [sp, #12]
  4036fa:	480a      	ldr	r0, [pc, #40]	; (403724 <xTimerCreateTimerTask+0x44>)
  4036fc:	490a      	ldr	r1, [pc, #40]	; (403728 <xTimerCreateTimerTask+0x48>)
  4036fe:	f44f 72a0 	mov.w	r2, #320	; 0x140
  403702:	4c0a      	ldr	r4, [pc, #40]	; (40372c <xTimerCreateTimerTask+0x4c>)
  403704:	47a0      	blx	r4
		}
		#endif
	}

	configASSERT( xReturn );
  403706:	4603      	mov	r3, r0
  403708:	b920      	cbnz	r0, 403714 <xTimerCreateTimerTask+0x34>
  40370a:	4809      	ldr	r0, [pc, #36]	; (403730 <xTimerCreateTimerTask+0x50>)
  40370c:	21d7      	movs	r1, #215	; 0xd7
  40370e:	4b09      	ldr	r3, [pc, #36]	; (403734 <xTimerCreateTimerTask+0x54>)
  403710:	4798      	blx	r3
  403712:	2300      	movs	r3, #0
	return xReturn;
}
  403714:	4618      	mov	r0, r3
  403716:	b004      	add	sp, #16
  403718:	bd10      	pop	{r4, pc}
  40371a:	bf00      	nop
  40371c:	00403685 	.word	0x00403685
  403720:	20004e7c 	.word	0x20004e7c
  403724:	004038a1 	.word	0x004038a1
  403728:	00409a58 	.word	0x00409a58
  40372c:	0040298d 	.word	0x0040298d
  403730:	00409a60 	.word	0x00409a60
  403734:	00403de1 	.word	0x00403de1

00403738 <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
  403738:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
  40373c:	b929      	cbnz	r1, 40374a <xTimerCreate+0x12>
	{
		pxNewTimer = NULL;
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
  40373e:	480f      	ldr	r0, [pc, #60]	; (40377c <xTimerCreate+0x44>)
  403740:	21e4      	movs	r1, #228	; 0xe4
  403742:	4b0f      	ldr	r3, [pc, #60]	; (403780 <xTimerCreate+0x48>)
  403744:	4798      	blx	r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
	{
		pxNewTimer = NULL;
  403746:	2400      	movs	r4, #0
  403748:	e014      	b.n	403774 <xTimerCreate+0x3c>
  40374a:	4680      	mov	r8, r0
  40374c:	4616      	mov	r6, r2
  40374e:	461d      	mov	r5, r3
  403750:	460f      	mov	r7, r1
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
  403752:	2028      	movs	r0, #40	; 0x28
  403754:	4b0b      	ldr	r3, [pc, #44]	; (403784 <xTimerCreate+0x4c>)
  403756:	4798      	blx	r3
		if( pxNewTimer != NULL )
  403758:	4604      	mov	r4, r0
  40375a:	b158      	cbz	r0, 403774 <xTimerCreate+0x3c>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
  40375c:	4b0a      	ldr	r3, [pc, #40]	; (403788 <xTimerCreate+0x50>)
  40375e:	4798      	blx	r3

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
  403760:	f8c4 8000 	str.w	r8, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
  403764:	61a7      	str	r7, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
  403766:	61e6      	str	r6, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
  403768:	6225      	str	r5, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
  40376a:	9b06      	ldr	r3, [sp, #24]
  40376c:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
  40376e:	1d20      	adds	r0, r4, #4
  403770:	4b06      	ldr	r3, [pc, #24]	; (40378c <xTimerCreate+0x54>)
  403772:	4798      	blx	r3
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
}
  403774:	4620      	mov	r0, r4
  403776:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40377a:	bf00      	nop
  40377c:	00409a60 	.word	0x00409a60
  403780:	00403de1 	.word	0x00403de1
  403784:	004020d9 	.word	0x004020d9
  403788:	00403685 	.word	0x00403685
  40378c:	00401e55 	.word	0x00401e55

00403790 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
  403790:	b530      	push	{r4, r5, lr}
  403792:	b085      	sub	sp, #20
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  403794:	4c0f      	ldr	r4, [pc, #60]	; (4037d4 <xTimerGenericCommand+0x44>)
  403796:	6825      	ldr	r5, [r4, #0]
  403798:	b1c5      	cbz	r5, 4037cc <xTimerGenericCommand+0x3c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  40379a:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
  40379c:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
  40379e:	9003      	str	r0, [sp, #12]

		if( pxHigherPriorityTaskWoken == NULL )
  4037a0:	b96b      	cbnz	r3, 4037be <xTimerGenericCommand+0x2e>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  4037a2:	4b0d      	ldr	r3, [pc, #52]	; (4037d8 <xTimerGenericCommand+0x48>)
  4037a4:	4798      	blx	r3
  4037a6:	2801      	cmp	r0, #1
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
  4037a8:	4b0a      	ldr	r3, [pc, #40]	; (4037d4 <xTimerGenericCommand+0x44>)
  4037aa:	6818      	ldr	r0, [r3, #0]
  4037ac:	a901      	add	r1, sp, #4
  4037ae:	bf07      	ittee	eq
  4037b0:	9a08      	ldreq	r2, [sp, #32]
  4037b2:	2300      	moveq	r3, #0
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  4037b4:	2200      	movne	r2, #0
  4037b6:	4613      	movne	r3, r2
  4037b8:	4c08      	ldr	r4, [pc, #32]	; (4037dc <xTimerGenericCommand+0x4c>)
  4037ba:	47a0      	blx	r4
  4037bc:	e007      	b.n	4037ce <xTimerGenericCommand+0x3e>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  4037be:	4628      	mov	r0, r5
  4037c0:	a901      	add	r1, sp, #4
  4037c2:	461a      	mov	r2, r3
  4037c4:	2300      	movs	r3, #0
  4037c6:	4c06      	ldr	r4, [pc, #24]	; (4037e0 <xTimerGenericCommand+0x50>)
  4037c8:	47a0      	blx	r4
  4037ca:	e000      	b.n	4037ce <xTimerGenericCommand+0x3e>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
  4037cc:	2000      	movs	r0, #0

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
  4037ce:	b005      	add	sp, #20
  4037d0:	bd30      	pop	{r4, r5, pc}
  4037d2:	bf00      	nop
  4037d4:	20004e7c 	.word	0x20004e7c
  4037d8:	0040350d 	.word	0x0040350d
  4037dc:	00402415 	.word	0x00402415
  4037e0:	004025ad 	.word	0x004025ad

004037e4 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
  4037e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4037e8:	b082      	sub	sp, #8
  4037ea:	4681      	mov	r9, r0
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  4037ec:	4b23      	ldr	r3, [pc, #140]	; (40387c <prvSampleTimeNow+0x98>)
  4037ee:	4798      	blx	r3
  4037f0:	4680      	mov	r8, r0

	if( xTimeNow < xLastTime )
  4037f2:	4b23      	ldr	r3, [pc, #140]	; (403880 <prvSampleTimeNow+0x9c>)
  4037f4:	681b      	ldr	r3, [r3, #0]
  4037f6:	4298      	cmp	r0, r3
  4037f8:	d236      	bcs.n	403868 <prvSampleTimeNow+0x84>
  4037fa:	e026      	b.n	40384a <prvSampleTimeNow+0x66>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  4037fc:	68da      	ldr	r2, [r3, #12]
  4037fe:	f8d2 a000 	ldr.w	sl, [r2]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  403802:	68db      	ldr	r3, [r3, #12]
  403804:	68dc      	ldr	r4, [r3, #12]
		uxListRemove( &( pxTimer->xTimerListItem ) );
  403806:	1d25      	adds	r5, r4, #4
  403808:	4628      	mov	r0, r5
  40380a:	47b8      	blx	r7

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  40380c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40380e:	4620      	mov	r0, r4
  403810:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  403812:	69e3      	ldr	r3, [r4, #28]
  403814:	2b01      	cmp	r3, #1
  403816:	d11a      	bne.n	40384e <prvSampleTimeNow+0x6a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  403818:	69a3      	ldr	r3, [r4, #24]
  40381a:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
  40381c:	4553      	cmp	r3, sl
  40381e:	d906      	bls.n	40382e <prvSampleTimeNow+0x4a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  403820:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  403822:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  403824:	6830      	ldr	r0, [r6, #0]
  403826:	4629      	mov	r1, r5
  403828:	4b16      	ldr	r3, [pc, #88]	; (403884 <prvSampleTimeNow+0xa0>)
  40382a:	4798      	blx	r3
  40382c:	e00f      	b.n	40384e <prvSampleTimeNow+0x6a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  40382e:	2300      	movs	r3, #0
  403830:	9300      	str	r3, [sp, #0]
  403832:	4620      	mov	r0, r4
  403834:	4619      	mov	r1, r3
  403836:	4652      	mov	r2, sl
  403838:	4c13      	ldr	r4, [pc, #76]	; (403888 <prvSampleTimeNow+0xa4>)
  40383a:	47a0      	blx	r4
				configASSERT( xResult );
  40383c:	b938      	cbnz	r0, 40384e <prvSampleTimeNow+0x6a>
  40383e:	4813      	ldr	r0, [pc, #76]	; (40388c <prvSampleTimeNow+0xa8>)
  403840:	f240 2172 	movw	r1, #626	; 0x272
  403844:	4b12      	ldr	r3, [pc, #72]	; (403890 <prvSampleTimeNow+0xac>)
  403846:	4798      	blx	r3
  403848:	e001      	b.n	40384e <prvSampleTimeNow+0x6a>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40384a:	4e12      	ldr	r6, [pc, #72]	; (403894 <prvSampleTimeNow+0xb0>)
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		uxListRemove( &( pxTimer->xTimerListItem ) );
  40384c:	4f12      	ldr	r7, [pc, #72]	; (403898 <prvSampleTimeNow+0xb4>)

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40384e:	6833      	ldr	r3, [r6, #0]
  403850:	681a      	ldr	r2, [r3, #0]
  403852:	2a00      	cmp	r2, #0
  403854:	d1d2      	bne.n	4037fc <prvSampleTimeNow+0x18>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
  403856:	4a11      	ldr	r2, [pc, #68]	; (40389c <prvSampleTimeNow+0xb8>)
  403858:	6810      	ldr	r0, [r2, #0]
  40385a:	490e      	ldr	r1, [pc, #56]	; (403894 <prvSampleTimeNow+0xb0>)
  40385c:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
  40385e:	6013      	str	r3, [r2, #0]
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
		*pxTimerListsWereSwitched = pdTRUE;
  403860:	2301      	movs	r3, #1
  403862:	f8c9 3000 	str.w	r3, [r9]
  403866:	e002      	b.n	40386e <prvSampleTimeNow+0x8a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
  403868:	2300      	movs	r3, #0
  40386a:	f8c9 3000 	str.w	r3, [r9]
	}

	xLastTime = xTimeNow;
  40386e:	4b04      	ldr	r3, [pc, #16]	; (403880 <prvSampleTimeNow+0x9c>)
  403870:	f8c3 8000 	str.w	r8, [r3]

	return xTimeNow;
}
  403874:	4640      	mov	r0, r8
  403876:	b002      	add	sp, #8
  403878:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40387c:	00402cc5 	.word	0x00402cc5
  403880:	20004e78 	.word	0x20004e78
  403884:	00401e79 	.word	0x00401e79
  403888:	00403791 	.word	0x00403791
  40388c:	00409a60 	.word	0x00409a60
  403890:	00403de1 	.word	0x00403de1
  403894:	20004e4c 	.word	0x20004e4c
  403898:	00401eb5 	.word	0x00401eb5
  40389c:	20004e80 	.word	0x20004e80

004038a0 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  4038a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4038a4:	b087      	sub	sp, #28
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  4038a6:	f8df a16c 	ldr.w	sl, [pc, #364]	; 403a14 <prvTimerTask+0x174>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  4038aa:	f8df b16c 	ldr.w	fp, [pc, #364]	; 403a18 <prvTimerTask+0x178>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  4038ae:	4e4e      	ldr	r6, [pc, #312]	; (4039e8 <prvTimerTask+0x148>)
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
	uxListRemove( &( pxTimer->xTimerListItem ) );
  4038b0:	f8df 8168 	ldr.w	r8, [pc, #360]	; 403a1c <prvTimerTask+0x17c>
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  4038b4:	f8da 3000 	ldr.w	r3, [sl]
  4038b8:	681a      	ldr	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  4038ba:	2a00      	cmp	r2, #0
  4038bc:	f000 808b 	beq.w	4039d6 <prvTimerTask+0x136>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  4038c0:	68db      	ldr	r3, [r3, #12]
  4038c2:	681d      	ldr	r5, [r3, #0]
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  4038c4:	47d8      	blx	fp
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  4038c6:	a803      	add	r0, sp, #12
  4038c8:	4b48      	ldr	r3, [pc, #288]	; (4039ec <prvTimerTask+0x14c>)
  4038ca:	4798      	blx	r3
  4038cc:	4604      	mov	r4, r0
		if( xTimerListsWereSwitched == pdFALSE )
  4038ce:	9b03      	ldr	r3, [sp, #12]
  4038d0:	2b00      	cmp	r3, #0
  4038d2:	d131      	bne.n	403938 <prvTimerTask+0x98>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  4038d4:	4285      	cmp	r5, r0
  4038d6:	d825      	bhi.n	403924 <prvTimerTask+0x84>
			{
				xTaskResumeAll();
  4038d8:	4b45      	ldr	r3, [pc, #276]	; (4039f0 <prvTimerTask+0x150>)
  4038da:	4798      	blx	r3
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  4038dc:	f8da 3000 	ldr.w	r3, [sl]
  4038e0:	68db      	ldr	r3, [r3, #12]
  4038e2:	68df      	ldr	r7, [r3, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
  4038e4:	1d38      	adds	r0, r7, #4
  4038e6:	47c0      	blx	r8
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  4038e8:	69fb      	ldr	r3, [r7, #28]
  4038ea:	2b01      	cmp	r3, #1
  4038ec:	d115      	bne.n	40391a <prvTimerTask+0x7a>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  4038ee:	69b9      	ldr	r1, [r7, #24]
  4038f0:	4638      	mov	r0, r7
  4038f2:	4429      	add	r1, r5
  4038f4:	4622      	mov	r2, r4
  4038f6:	462b      	mov	r3, r5
  4038f8:	4c3e      	ldr	r4, [pc, #248]	; (4039f4 <prvTimerTask+0x154>)
  4038fa:	47a0      	blx	r4
  4038fc:	2801      	cmp	r0, #1
  4038fe:	d10c      	bne.n	40391a <prvTimerTask+0x7a>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  403900:	2300      	movs	r3, #0
  403902:	9300      	str	r3, [sp, #0]
  403904:	4638      	mov	r0, r7
  403906:	4619      	mov	r1, r3
  403908:	462a      	mov	r2, r5
  40390a:	4c3b      	ldr	r4, [pc, #236]	; (4039f8 <prvTimerTask+0x158>)
  40390c:	47a0      	blx	r4
			configASSERT( xResult );
  40390e:	b920      	cbnz	r0, 40391a <prvTimerTask+0x7a>
  403910:	483a      	ldr	r0, [pc, #232]	; (4039fc <prvTimerTask+0x15c>)
  403912:	f240 114f 	movw	r1, #335	; 0x14f
  403916:	4b3a      	ldr	r3, [pc, #232]	; (403a00 <prvTimerTask+0x160>)
  403918:	4798      	blx	r3
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  40391a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40391c:	4638      	mov	r0, r7
  40391e:	4798      	blx	r3
  403920:	e00c      	b.n	40393c <prvTimerTask+0x9c>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
  403922:	2500      	movs	r5, #0
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  403924:	6830      	ldr	r0, [r6, #0]
  403926:	1b29      	subs	r1, r5, r4
  403928:	4b36      	ldr	r3, [pc, #216]	; (403a04 <prvTimerTask+0x164>)
  40392a:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
  40392c:	4b30      	ldr	r3, [pc, #192]	; (4039f0 <prvTimerTask+0x150>)
  40392e:	4798      	blx	r3
  403930:	b920      	cbnz	r0, 40393c <prvTimerTask+0x9c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  403932:	4b35      	ldr	r3, [pc, #212]	; (403a08 <prvTimerTask+0x168>)
  403934:	4798      	blx	r3
  403936:	e001      	b.n	40393c <prvTimerTask+0x9c>
				}
			}
		}
		else
		{
			xTaskResumeAll();
  403938:	4b2d      	ldr	r3, [pc, #180]	; (4039f0 <prvTimerTask+0x150>)
  40393a:	4798      	blx	r3
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40393c:	a802      	add	r0, sp, #8
  40393e:	4b2b      	ldr	r3, [pc, #172]	; (4039ec <prvTimerTask+0x14c>)
  403940:	4798      	blx	r3
  403942:	4607      	mov	r7, r0

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  403944:	4d31      	ldr	r5, [pc, #196]	; (403a0c <prvTimerTask+0x16c>)
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  403946:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 4039f4 <prvTimerTask+0x154>
  40394a:	e03c      	b.n	4039c6 <prvTimerTask+0x126>
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
  40394c:	9c05      	ldr	r4, [sp, #20]

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
  40394e:	b11c      	cbz	r4, 403958 <prvTimerTask+0xb8>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  403950:	6963      	ldr	r3, [r4, #20]
  403952:	b10b      	cbz	r3, 403958 <prvTimerTask+0xb8>
			{
				/* The timer is in a list, remove it. */
				uxListRemove( &( pxTimer->xTimerListItem ) );
  403954:	1d20      	adds	r0, r4, #4
  403956:	47c0      	blx	r8
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );

		switch( xMessage.xMessageID )
  403958:	9b03      	ldr	r3, [sp, #12]
  40395a:	2b02      	cmp	r3, #2
  40395c:	d021      	beq.n	4039a2 <prvTimerTask+0x102>
  40395e:	2b03      	cmp	r3, #3
  403960:	d02e      	beq.n	4039c0 <prvTimerTask+0x120>
  403962:	2b00      	cmp	r3, #0
  403964:	d12f      	bne.n	4039c6 <prvTimerTask+0x126>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
  403966:	9b04      	ldr	r3, [sp, #16]
  403968:	69a1      	ldr	r1, [r4, #24]
  40396a:	4620      	mov	r0, r4
  40396c:	4419      	add	r1, r3
  40396e:	463a      	mov	r2, r7
  403970:	47c8      	blx	r9
  403972:	2801      	cmp	r0, #1
  403974:	d127      	bne.n	4039c6 <prvTimerTask+0x126>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  403976:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403978:	4620      	mov	r0, r4
  40397a:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  40397c:	69e3      	ldr	r3, [r4, #28]
  40397e:	2b01      	cmp	r3, #1
  403980:	d121      	bne.n	4039c6 <prvTimerTask+0x126>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  403982:	69a2      	ldr	r2, [r4, #24]
  403984:	2300      	movs	r3, #0
  403986:	9300      	str	r3, [sp, #0]
  403988:	4620      	mov	r0, r4
  40398a:	4619      	mov	r1, r3
  40398c:	9c04      	ldr	r4, [sp, #16]
  40398e:	4422      	add	r2, r4
  403990:	4c19      	ldr	r4, [pc, #100]	; (4039f8 <prvTimerTask+0x158>)
  403992:	47a0      	blx	r4
						configASSERT( xResult );
  403994:	b9b8      	cbnz	r0, 4039c6 <prvTimerTask+0x126>
  403996:	4819      	ldr	r0, [pc, #100]	; (4039fc <prvTimerTask+0x15c>)
  403998:	f240 2126 	movw	r1, #550	; 0x226
  40399c:	4b18      	ldr	r3, [pc, #96]	; (403a00 <prvTimerTask+0x160>)
  40399e:	4798      	blx	r3
  4039a0:	e011      	b.n	4039c6 <prvTimerTask+0x126>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
  4039a2:	9b04      	ldr	r3, [sp, #16]
  4039a4:	61a3      	str	r3, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  4039a6:	b923      	cbnz	r3, 4039b2 <prvTimerTask+0x112>
  4039a8:	4814      	ldr	r0, [pc, #80]	; (4039fc <prvTimerTask+0x15c>)
  4039aa:	f240 2133 	movw	r1, #563	; 0x233
  4039ae:	4b14      	ldr	r3, [pc, #80]	; (403a00 <prvTimerTask+0x160>)
  4039b0:	4798      	blx	r3
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  4039b2:	69a1      	ldr	r1, [r4, #24]
  4039b4:	4620      	mov	r0, r4
  4039b6:	4439      	add	r1, r7
  4039b8:	463a      	mov	r2, r7
  4039ba:	463b      	mov	r3, r7
  4039bc:	47c8      	blx	r9
  4039be:	e002      	b.n	4039c6 <prvTimerTask+0x126>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
  4039c0:	4620      	mov	r0, r4
  4039c2:	4b13      	ldr	r3, [pc, #76]	; (403a10 <prvTimerTask+0x170>)
  4039c4:	4798      	blx	r3

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  4039c6:	6830      	ldr	r0, [r6, #0]
  4039c8:	a903      	add	r1, sp, #12
  4039ca:	2200      	movs	r2, #0
  4039cc:	4613      	mov	r3, r2
  4039ce:	47a8      	blx	r5
  4039d0:	2800      	cmp	r0, #0
  4039d2:	d1bb      	bne.n	40394c <prvTimerTask+0xac>
  4039d4:	e76e      	b.n	4038b4 <prvTimerTask+0x14>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  4039d6:	47d8      	blx	fp
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  4039d8:	a803      	add	r0, sp, #12
  4039da:	4b04      	ldr	r3, [pc, #16]	; (4039ec <prvTimerTask+0x14c>)
  4039dc:	4798      	blx	r3
  4039de:	4604      	mov	r4, r0
		if( xTimerListsWereSwitched == pdFALSE )
  4039e0:	9b03      	ldr	r3, [sp, #12]
  4039e2:	2b00      	cmp	r3, #0
  4039e4:	d09d      	beq.n	403922 <prvTimerTask+0x82>
  4039e6:	e7a7      	b.n	403938 <prvTimerTask+0x98>
  4039e8:	20004e7c 	.word	0x20004e7c
  4039ec:	004037e5 	.word	0x004037e5
  4039f0:	00402e31 	.word	0x00402e31
  4039f4:	00403639 	.word	0x00403639
  4039f8:	00403791 	.word	0x00403791
  4039fc:	00409a60 	.word	0x00409a60
  403a00:	00403de1 	.word	0x00403de1
  403a04:	004027ad 	.word	0x004027ad
  403a08:	00401f45 	.word	0x00401f45
  403a0c:	00402649 	.word	0x00402649
  403a10:	004021ad 	.word	0x004021ad
  403a14:	20004e4c 	.word	0x20004e4c
  403a18:	00402cb5 	.word	0x00402cb5
  403a1c:	00401eb5 	.word	0x00401eb5

00403a20 <delete_task_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE delete_task_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403a20:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403a22:	4604      	mov	r4, r0
  403a24:	b920      	cbnz	r0, 403a30 <delete_task_command+0x10>
  403a26:	480f      	ldr	r0, [pc, #60]	; (403a64 <delete_task_command+0x44>)
  403a28:	f240 11b1 	movw	r1, #433	; 0x1b1
  403a2c:	4b0e      	ldr	r3, [pc, #56]	; (403a68 <delete_task_command+0x48>)
  403a2e:	4798      	blx	r3

	/* See if the task is running. */
	if (created_task_handle != NULL) {
  403a30:	4b0e      	ldr	r3, [pc, #56]	; (403a6c <delete_task_command+0x4c>)
  403a32:	6818      	ldr	r0, [r3, #0]
  403a34:	b170      	cbz	r0, 403a54 <delete_task_command+0x34>
		vTaskDelete(created_task_handle);
  403a36:	4b0e      	ldr	r3, [pc, #56]	; (403a70 <delete_task_command+0x50>)
  403a38:	4798      	blx	r3
		created_task_handle = NULL;
  403a3a:	2200      	movs	r2, #0
  403a3c:	4b0b      	ldr	r3, [pc, #44]	; (403a6c <delete_task_command+0x4c>)
  403a3e:	601a      	str	r2, [r3, #0]
		strcpy((char *) pcWriteBuffer, (const char *) success_message);
  403a40:	4b0c      	ldr	r3, [pc, #48]	; (403a74 <delete_task_command+0x54>)
  403a42:	cb07      	ldmia	r3!, {r0, r1, r2}
  403a44:	6020      	str	r0, [r4, #0]
  403a46:	6061      	str	r1, [r4, #4]
  403a48:	60a2      	str	r2, [r4, #8]
  403a4a:	881a      	ldrh	r2, [r3, #0]
  403a4c:	789b      	ldrb	r3, [r3, #2]
  403a4e:	81a2      	strh	r2, [r4, #12]
  403a50:	73a3      	strb	r3, [r4, #14]
  403a52:	e004      	b.n	403a5e <delete_task_command+0x3e>
	} else {
		strcpy((char *) pcWriteBuffer, (const char *) failure_message);
  403a54:	4620      	mov	r0, r4
  403a56:	4908      	ldr	r1, [pc, #32]	; (403a78 <delete_task_command+0x58>)
  403a58:	2244      	movs	r2, #68	; 0x44
  403a5a:	4b08      	ldr	r3, [pc, #32]	; (403a7c <delete_task_command+0x5c>)
  403a5c:	4798      	blx	r3
	}

	/* There is no more data to return after this single string, so return
	 * pdFALSE. */
	return pdFALSE;
}
  403a5e:	2000      	movs	r0, #0
  403a60:	bd10      	pop	{r4, pc}
  403a62:	bf00      	nop
  403a64:	00409ad0 	.word	0x00409ad0
  403a68:	00403de1 	.word	0x00403de1
  403a6c:	20004e84 	.word	0x20004e84
  403a70:	00402b91 	.word	0x00402b91
  403a74:	00409af4 	.word	0x00409af4
  403a78:	00409b04 	.word	0x00409b04
  403a7c:	004040a1 	.word	0x004040a1

00403a80 <create_task_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE create_task_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403a80:	b530      	push	{r4, r5, lr}
  403a82:	b087      	sub	sp, #28
  403a84:	4615      	mov	r5, r2

	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403a86:	4604      	mov	r4, r0
  403a88:	b920      	cbnz	r0, 403a94 <create_task_command+0x14>
  403a8a:	481d      	ldr	r0, [pc, #116]	; (403b00 <create_task_command+0x80>)
  403a8c:	f240 1181 	movw	r1, #385	; 0x181
  403a90:	4b1c      	ldr	r3, [pc, #112]	; (403b04 <create_task_command+0x84>)
  403a92:	4798      	blx	r3

	/* Obtain the parameter string. */
	parameter_string = (int8_t *) FreeRTOS_CLIGetParameter(
  403a94:	4628      	mov	r0, r5
  403a96:	2101      	movs	r1, #1
  403a98:	aa05      	add	r2, sp, #20
  403a9a:	4b1b      	ldr	r3, [pc, #108]	; (403b08 <create_task_command+0x88>)
  403a9c:	4798      	blx	r3
									1,						/* Return the first parameter. */
									&parameter_string_length	/* Store the parameter string length. */
								);

	/* Turn the parameter into a number. */
	parameter_value = (int32_t) atol((const char *) parameter_string);
  403a9e:	4b1b      	ldr	r3, [pc, #108]	; (403b0c <create_task_command+0x8c>)
  403aa0:	4798      	blx	r3
  403aa2:	4603      	mov	r3, r0

	/* Attempt to create the task. */
	if (created_task_handle != NULL) {
  403aa4:	4a1a      	ldr	r2, [pc, #104]	; (403b10 <create_task_command+0x90>)
  403aa6:	6812      	ldr	r2, [r2, #0]
  403aa8:	b12a      	cbz	r2, 403ab6 <create_task_command+0x36>
		strcpy((char *) pcWriteBuffer,
  403aaa:	4620      	mov	r0, r4
  403aac:	4919      	ldr	r1, [pc, #100]	; (403b14 <create_task_command+0x94>)
  403aae:	224c      	movs	r2, #76	; 0x4c
  403ab0:	4b19      	ldr	r3, [pc, #100]	; (403b18 <create_task_command+0x98>)
  403ab2:	4798      	blx	r3
  403ab4:	e020      	b.n	403af8 <create_task_command+0x78>
				(const char *) task_already_created_message);
	} else {
		if (xTaskCreate(created_task, (const signed char *) "Created",
  403ab6:	2200      	movs	r2, #0
  403ab8:	9200      	str	r2, [sp, #0]
  403aba:	4915      	ldr	r1, [pc, #84]	; (403b10 <create_task_command+0x90>)
  403abc:	9101      	str	r1, [sp, #4]
  403abe:	9202      	str	r2, [sp, #8]
  403ac0:	9203      	str	r2, [sp, #12]
  403ac2:	4816      	ldr	r0, [pc, #88]	; (403b1c <create_task_command+0x9c>)
  403ac4:	4916      	ldr	r1, [pc, #88]	; (403b20 <create_task_command+0xa0>)
  403ac6:	22a0      	movs	r2, #160	; 0xa0
  403ac8:	4d16      	ldr	r5, [pc, #88]	; (403b24 <create_task_command+0xa4>)
  403aca:	47a8      	blx	r5
  403acc:	2801      	cmp	r0, #1
  403ace:	d109      	bne.n	403ae4 <create_task_command+0x64>
				configMINIMAL_STACK_SIZE,
				(void *) parameter_value, tskIDLE_PRIORITY,
				&created_task_handle) == pdPASS) {
			strcpy((char *) pcWriteBuffer,
  403ad0:	4b15      	ldr	r3, [pc, #84]	; (403b28 <create_task_command+0xa8>)
  403ad2:	cb07      	ldmia	r3!, {r0, r1, r2}
  403ad4:	6020      	str	r0, [r4, #0]
  403ad6:	6061      	str	r1, [r4, #4]
  403ad8:	60a2      	str	r2, [r4, #8]
  403ada:	881a      	ldrh	r2, [r3, #0]
  403adc:	789b      	ldrb	r3, [r3, #2]
  403ade:	81a2      	strh	r2, [r4, #12]
  403ae0:	73a3      	strb	r3, [r4, #14]
  403ae2:	e009      	b.n	403af8 <create_task_command+0x78>
					(const char *) success_message);
		} else {
			strcpy((char *) pcWriteBuffer,
  403ae4:	4d11      	ldr	r5, [pc, #68]	; (403b2c <create_task_command+0xac>)
  403ae6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  403ae8:	6020      	str	r0, [r4, #0]
  403aea:	6061      	str	r1, [r4, #4]
  403aec:	60a2      	str	r2, [r4, #8]
  403aee:	60e3      	str	r3, [r4, #12]
  403af0:	882a      	ldrh	r2, [r5, #0]
  403af2:	78ab      	ldrb	r3, [r5, #2]
  403af4:	8222      	strh	r2, [r4, #16]
  403af6:	74a3      	strb	r3, [r4, #18]
	}

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
  403af8:	2000      	movs	r0, #0
  403afa:	b007      	add	sp, #28
  403afc:	bd30      	pop	{r4, r5, pc}
  403afe:	bf00      	nop
  403b00:	00409ad0 	.word	0x00409ad0
  403b04:	00403de1 	.word	0x00403de1
  403b08:	00401dcd 	.word	0x00401dcd
  403b0c:	00403fe5 	.word	0x00403fe5
  403b10:	20004e84 	.word	0x20004e84
  403b14:	00409b48 	.word	0x00409b48
  403b18:	004040a1 	.word	0x004040a1
  403b1c:	00403d25 	.word	0x00403d25
  403b20:	00409b94 	.word	0x00409b94
  403b24:	0040298d 	.word	0x0040298d
  403b28:	00409b9c 	.word	0x00409b9c
  403b2c:	00409bac 	.word	0x00409bac

00403b30 <multi_parameter_echo_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE multi_parameter_echo_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403b30:	b5f0      	push	{r4, r5, r6, r7, lr}
  403b32:	b083      	sub	sp, #12
  403b34:	460e      	mov	r6, r1
  403b36:	4615      	mov	r5, r2
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403b38:	4604      	mov	r4, r0
  403b3a:	b920      	cbnz	r0, 403b46 <multi_parameter_echo_command+0x16>
  403b3c:	4820      	ldr	r0, [pc, #128]	; (403bc0 <multi_parameter_echo_command+0x90>)
  403b3e:	f240 113f 	movw	r1, #319	; 0x13f
  403b42:	4b20      	ldr	r3, [pc, #128]	; (403bc4 <multi_parameter_echo_command+0x94>)
  403b44:	4798      	blx	r3

	if (parameter_number == 0) {
  403b46:	4b20      	ldr	r3, [pc, #128]	; (403bc8 <multi_parameter_echo_command+0x98>)
  403b48:	6819      	ldr	r1, [r3, #0]
  403b4a:	b979      	cbnz	r1, 403b6c <multi_parameter_echo_command+0x3c>
		/* The first time the function is called after the command has been
		entered just a header string is returned. */
		sprintf((char *) pcWriteBuffer, "The parameters were:\r\n");
  403b4c:	4d1f      	ldr	r5, [pc, #124]	; (403bcc <multi_parameter_echo_command+0x9c>)
  403b4e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  403b50:	6020      	str	r0, [r4, #0]
  403b52:	6061      	str	r1, [r4, #4]
  403b54:	60a2      	str	r2, [r4, #8]
  403b56:	60e3      	str	r3, [r4, #12]
  403b58:	6828      	ldr	r0, [r5, #0]
  403b5a:	6120      	str	r0, [r4, #16]
  403b5c:	88aa      	ldrh	r2, [r5, #4]
  403b5e:	79ab      	ldrb	r3, [r5, #6]
  403b60:	82a2      	strh	r2, [r4, #20]
  403b62:	75a3      	strb	r3, [r4, #22]

		/* Next time the function is called the first parameter will be echoed
		back. */
		parameter_number = 1L;
  403b64:	2001      	movs	r0, #1
  403b66:	4b18      	ldr	r3, [pc, #96]	; (403bc8 <multi_parameter_echo_command+0x98>)
  403b68:	6018      	str	r0, [r3, #0]
  403b6a:	e027      	b.n	403bbc <multi_parameter_echo_command+0x8c>
		/* There is more data to be returned as no parameters have been echoed
		back yet. */
		return_value = pdPASS;
	} else {
		/* Obtain the parameter string. */
		parameter_string = (int8_t *) FreeRTOS_CLIGetParameter
  403b6c:	4628      	mov	r0, r5
  403b6e:	aa01      	add	r2, sp, #4
  403b70:	4b17      	ldr	r3, [pc, #92]	; (403bd0 <multi_parameter_echo_command+0xa0>)
  403b72:	4798      	blx	r3
										pcCommandString,		/* The command string itself. */
										parameter_number,		/* Return the next parameter. */
										&parameter_string_length	/* Store the parameter string length. */
									);

		if (parameter_string != NULL) {
  403b74:	4607      	mov	r7, r0
  403b76:	b1e8      	cbz	r0, 403bb4 <multi_parameter_echo_command+0x84>
			/* Return the parameter string. */
			memset(pcWriteBuffer, 0x00, xWriteBufferLen);
  403b78:	4620      	mov	r0, r4
  403b7a:	2100      	movs	r1, #0
  403b7c:	4632      	mov	r2, r6
  403b7e:	4b15      	ldr	r3, [pc, #84]	; (403bd4 <multi_parameter_echo_command+0xa4>)
  403b80:	4798      	blx	r3
			sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
  403b82:	4d11      	ldr	r5, [pc, #68]	; (403bc8 <multi_parameter_echo_command+0x98>)
  403b84:	4620      	mov	r0, r4
  403b86:	4914      	ldr	r1, [pc, #80]	; (403bd8 <multi_parameter_echo_command+0xa8>)
  403b88:	682a      	ldr	r2, [r5, #0]
  403b8a:	4b14      	ldr	r3, [pc, #80]	; (403bdc <multi_parameter_echo_command+0xac>)
  403b8c:	4798      	blx	r3
			strncat((char *) pcWriteBuffer, (const char *) parameter_string, parameter_string_length);
  403b8e:	4620      	mov	r0, r4
  403b90:	4639      	mov	r1, r7
  403b92:	9a01      	ldr	r2, [sp, #4]
  403b94:	4b12      	ldr	r3, [pc, #72]	; (403be0 <multi_parameter_echo_command+0xb0>)
  403b96:	4798      	blx	r3
			strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));
  403b98:	4620      	mov	r0, r4
  403b9a:	4b12      	ldr	r3, [pc, #72]	; (403be4 <multi_parameter_echo_command+0xb4>)
  403b9c:	4798      	blx	r3
  403b9e:	1822      	adds	r2, r4, r0
  403ba0:	4b11      	ldr	r3, [pc, #68]	; (403be8 <multi_parameter_echo_command+0xb8>)
  403ba2:	8819      	ldrh	r1, [r3, #0]
  403ba4:	789b      	ldrb	r3, [r3, #2]
  403ba6:	5221      	strh	r1, [r4, r0]
  403ba8:	7093      	strb	r3, [r2, #2]

			/* There might be more parameters to return after this one. */
			return_value = pdTRUE;
			parameter_number++;
  403baa:	682b      	ldr	r3, [r5, #0]
  403bac:	3301      	adds	r3, #1
  403bae:	602b      	str	r3, [r5, #0]
			sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
			strncat((char *) pcWriteBuffer, (const char *) parameter_string, parameter_string_length);
			strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));

			/* There might be more parameters to return after this one. */
			return_value = pdTRUE;
  403bb0:	2001      	movs	r0, #1
  403bb2:	e003      	b.n	403bbc <multi_parameter_echo_command+0x8c>
			parameter_number++;
		} else {
			/* No more parameters were found.  Make sure the write buffer does
			not contain a valid string. */
			pcWriteBuffer[0] = 0x00;
  403bb4:	2000      	movs	r0, #0
  403bb6:	7020      	strb	r0, [r4, #0]

			/* No more data to return. */
			return_value = pdFALSE;

			/* Start over the next time this command is executed. */
			parameter_number = 0;
  403bb8:	4b03      	ldr	r3, [pc, #12]	; (403bc8 <multi_parameter_echo_command+0x98>)
  403bba:	6018      	str	r0, [r3, #0]
		}
	}

	return return_value;
}
  403bbc:	b003      	add	sp, #12
  403bbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
  403bc0:	00409ad0 	.word	0x00409ad0
  403bc4:	00403de1 	.word	0x00403de1
  403bc8:	20004ec8 	.word	0x20004ec8
  403bcc:	00409bc0 	.word	0x00409bc0
  403bd0:	00401dcd 	.word	0x00401dcd
  403bd4:	004041d5 	.word	0x004041d5
  403bd8:	00409bd8 	.word	0x00409bd8
  403bdc:	00404379 	.word	0x00404379
  403be0:	0040451d 	.word	0x0040451d
  403be4:	004044c1 	.word	0x004044c1
  403be8:	00409d34 	.word	0x00409d34

00403bec <three_parameter_echo_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE three_parameter_echo_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403bec:	b570      	push	{r4, r5, r6, lr}
  403bee:	b082      	sub	sp, #8
  403bf0:	460d      	mov	r5, r1
  403bf2:	4616      	mov	r6, r2
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403bf4:	4604      	mov	r4, r0
  403bf6:	b918      	cbnz	r0, 403c00 <three_parameter_echo_command+0x14>
  403bf8:	4823      	ldr	r0, [pc, #140]	; (403c88 <three_parameter_echo_command+0x9c>)
  403bfa:	21fd      	movs	r1, #253	; 0xfd
  403bfc:	4b23      	ldr	r3, [pc, #140]	; (403c8c <three_parameter_echo_command+0xa0>)
  403bfe:	4798      	blx	r3

	if (parameter_number == 0) {
  403c00:	4b23      	ldr	r3, [pc, #140]	; (403c90 <three_parameter_echo_command+0xa4>)
  403c02:	6819      	ldr	r1, [r3, #0]
  403c04:	b979      	cbnz	r1, 403c26 <three_parameter_echo_command+0x3a>
		/* The first time the function is called after the command has been
		entered just a header string is returned. */
		sprintf((char *) pcWriteBuffer,
  403c06:	4d23      	ldr	r5, [pc, #140]	; (403c94 <three_parameter_echo_command+0xa8>)
  403c08:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  403c0a:	6020      	str	r0, [r4, #0]
  403c0c:	6061      	str	r1, [r4, #4]
  403c0e:	60a2      	str	r2, [r4, #8]
  403c10:	60e3      	str	r3, [r4, #12]
  403c12:	cd07      	ldmia	r5!, {r0, r1, r2}
  403c14:	6120      	str	r0, [r4, #16]
  403c16:	6161      	str	r1, [r4, #20]
  403c18:	61a2      	str	r2, [r4, #24]
  403c1a:	782b      	ldrb	r3, [r5, #0]
  403c1c:	7723      	strb	r3, [r4, #28]
				"The three parameters were:\r\n");

		/* Next time the function is called the first parameter will be echoed
		back. */
		parameter_number = 1L;
  403c1e:	2001      	movs	r0, #1
  403c20:	4b1b      	ldr	r3, [pc, #108]	; (403c90 <three_parameter_echo_command+0xa4>)
  403c22:	6018      	str	r0, [r3, #0]
  403c24:	e02d      	b.n	403c82 <three_parameter_echo_command+0x96>
		/* There is more data to be returned as no parameters have been echoed
		back yet. */
		return_value = pdPASS;
	} else {
		/* Obtain the parameter string. */
		parameter_string = (int8_t *) FreeRTOS_CLIGetParameter
  403c26:	4630      	mov	r0, r6
  403c28:	aa01      	add	r2, sp, #4
  403c2a:	4b1b      	ldr	r3, [pc, #108]	; (403c98 <three_parameter_echo_command+0xac>)
  403c2c:	4798      	blx	r3
										parameter_number,		/* Return the next parameter. */
										&parameter_string_length	/* Store the parameter string length. */
									);

		/* Sanity check something was returned. */
		configASSERT(parameter_string);
  403c2e:	4606      	mov	r6, r0
  403c30:	b920      	cbnz	r0, 403c3c <three_parameter_echo_command+0x50>
  403c32:	4815      	ldr	r0, [pc, #84]	; (403c88 <three_parameter_echo_command+0x9c>)
  403c34:	f44f 718b 	mov.w	r1, #278	; 0x116
  403c38:	4b14      	ldr	r3, [pc, #80]	; (403c8c <three_parameter_echo_command+0xa0>)
  403c3a:	4798      	blx	r3

		/* Return the parameter string. */
		memset(pcWriteBuffer, 0x00, xWriteBufferLen);
  403c3c:	4620      	mov	r0, r4
  403c3e:	2100      	movs	r1, #0
  403c40:	462a      	mov	r2, r5
  403c42:	4b16      	ldr	r3, [pc, #88]	; (403c9c <three_parameter_echo_command+0xb0>)
  403c44:	4798      	blx	r3
		sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
  403c46:	4d12      	ldr	r5, [pc, #72]	; (403c90 <three_parameter_echo_command+0xa4>)
  403c48:	4620      	mov	r0, r4
  403c4a:	4915      	ldr	r1, [pc, #84]	; (403ca0 <three_parameter_echo_command+0xb4>)
  403c4c:	682a      	ldr	r2, [r5, #0]
  403c4e:	4b15      	ldr	r3, [pc, #84]	; (403ca4 <three_parameter_echo_command+0xb8>)
  403c50:	4798      	blx	r3
		strncat((char *) pcWriteBuffer, (const char *) parameter_string,
  403c52:	4620      	mov	r0, r4
  403c54:	4631      	mov	r1, r6
  403c56:	9a01      	ldr	r2, [sp, #4]
  403c58:	4b13      	ldr	r3, [pc, #76]	; (403ca8 <three_parameter_echo_command+0xbc>)
  403c5a:	4798      	blx	r3
				parameter_string_length);
		strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));
  403c5c:	4620      	mov	r0, r4
  403c5e:	4b13      	ldr	r3, [pc, #76]	; (403cac <three_parameter_echo_command+0xc0>)
  403c60:	4798      	blx	r3
  403c62:	1822      	adds	r2, r4, r0
  403c64:	4b12      	ldr	r3, [pc, #72]	; (403cb0 <three_parameter_echo_command+0xc4>)
  403c66:	8819      	ldrh	r1, [r3, #0]
  403c68:	789b      	ldrb	r3, [r3, #2]
  403c6a:	5221      	strh	r1, [r4, r0]
  403c6c:	7093      	strb	r3, [r2, #2]

		/* If this is the last of the three parameters then there are no more
		strings to return after this one. */
		if (parameter_number == 3L) {
  403c6e:	682b      	ldr	r3, [r5, #0]
  403c70:	2b03      	cmp	r3, #3
  403c72:	d102      	bne.n	403c7a <three_parameter_echo_command+0x8e>
			/* If this is the last of the three parameters then there are no more
			strings to return after this one. */
			return_value = pdFALSE;
			parameter_number = 0L;
  403c74:	2000      	movs	r0, #0
  403c76:	6028      	str	r0, [r5, #0]
  403c78:	e003      	b.n	403c82 <three_parameter_echo_command+0x96>
		} else {
			/* There are more parameters to return after this one. */
			return_value = pdTRUE;
			parameter_number++;
  403c7a:	3301      	adds	r3, #1
  403c7c:	4a04      	ldr	r2, [pc, #16]	; (403c90 <three_parameter_echo_command+0xa4>)
  403c7e:	6013      	str	r3, [r2, #0]
			strings to return after this one. */
			return_value = pdFALSE;
			parameter_number = 0L;
		} else {
			/* There are more parameters to return after this one. */
			return_value = pdTRUE;
  403c80:	2001      	movs	r0, #1
			parameter_number++;
		}
	}

	return return_value;
}
  403c82:	b002      	add	sp, #8
  403c84:	bd70      	pop	{r4, r5, r6, pc}
  403c86:	bf00      	nop
  403c88:	00409ad0 	.word	0x00409ad0
  403c8c:	00403de1 	.word	0x00403de1
  403c90:	20004e88 	.word	0x20004e88
  403c94:	00409be0 	.word	0x00409be0
  403c98:	00401dcd 	.word	0x00401dcd
  403c9c:	004041d5 	.word	0x004041d5
  403ca0:	00409bd8 	.word	0x00409bd8
  403ca4:	00404379 	.word	0x00404379
  403ca8:	0040451d 	.word	0x0040451d
  403cac:	004044c1 	.word	0x004044c1
  403cb0:	00409d34 	.word	0x00409d34

00403cb4 <run_time_stats_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE run_time_stats_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403cb4:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403cb6:	4604      	mov	r4, r0
  403cb8:	b918      	cbnz	r0, 403cc2 <run_time_stats_command+0xe>
  403cba:	4807      	ldr	r0, [pc, #28]	; (403cd8 <run_time_stats_command+0x24>)
  403cbc:	21e2      	movs	r1, #226	; 0xe2
  403cbe:	4b07      	ldr	r3, [pc, #28]	; (403cdc <run_time_stats_command+0x28>)
  403cc0:	4798      	blx	r3

	/* Generate a table of task stats. */
	strcpy((char *) pcWriteBuffer, (char *) stats_table_header);
  403cc2:	4620      	mov	r0, r4
  403cc4:	4906      	ldr	r1, [pc, #24]	; (403ce0 <run_time_stats_command+0x2c>)
  403cc6:	2251      	movs	r2, #81	; 0x51
  403cc8:	4b06      	ldr	r3, [pc, #24]	; (403ce4 <run_time_stats_command+0x30>)
  403cca:	4798      	blx	r3
	vTaskGetRunTimeStats(pcWriteBuffer + strlen(
  403ccc:	f104 0050 	add.w	r0, r4, #80	; 0x50
  403cd0:	4b05      	ldr	r3, [pc, #20]	; (403ce8 <run_time_stats_command+0x34>)
  403cd2:	4798      	blx	r3
			(char *) stats_table_header));

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
  403cd4:	2000      	movs	r0, #0
  403cd6:	bd10      	pop	{r4, pc}
  403cd8:	00409ad0 	.word	0x00409ad0
  403cdc:	00403de1 	.word	0x00403de1
  403ce0:	00409c00 	.word	0x00409c00
  403ce4:	004040a1 	.word	0x004040a1
  403ce8:	004030f9 	.word	0x004030f9

00403cec <task_stats_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE task_stats_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403cec:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403cee:	4604      	mov	r4, r0
  403cf0:	b918      	cbnz	r0, 403cfa <task_stats_command+0xe>
  403cf2:	4807      	ldr	r0, [pc, #28]	; (403d10 <task_stats_command+0x24>)
  403cf4:	21ca      	movs	r1, #202	; 0xca
  403cf6:	4b07      	ldr	r3, [pc, #28]	; (403d14 <task_stats_command+0x28>)
  403cf8:	4798      	blx	r3

	/* Generate a table of task stats. */
	strcpy((char *) pcWriteBuffer, (char *) task_table_header);
  403cfa:	4620      	mov	r0, r4
  403cfc:	4906      	ldr	r1, [pc, #24]	; (403d18 <task_stats_command+0x2c>)
  403cfe:	225b      	movs	r2, #91	; 0x5b
  403d00:	4b06      	ldr	r3, [pc, #24]	; (403d1c <task_stats_command+0x30>)
  403d02:	4798      	blx	r3
	vTaskList(pcWriteBuffer + strlen((char *) task_table_header));
  403d04:	f104 005a 	add.w	r0, r4, #90	; 0x5a
  403d08:	4b05      	ldr	r3, [pc, #20]	; (403d20 <task_stats_command+0x34>)
  403d0a:	4798      	blx	r3

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
  403d0c:	2000      	movs	r0, #0
  403d0e:	bd10      	pop	{r4, pc}
  403d10:	00409ad0 	.word	0x00409ad0
  403d14:	00403de1 	.word	0x00403de1
  403d18:	00409c54 	.word	0x00409c54
  403d1c:	004040a1 	.word	0x004040a1
  403d20:	00403025 	.word	0x00403025

00403d24 <created_task>:
}

/*-----------------------------------------------------------*/

void created_task(void *pvParameters)
{
  403d24:	b538      	push	{r3, r4, r5, lr}
  403d26:	4605      	mov	r5, r0
	static uint8_t local_buffer[60];

	/* Cast the parameter to an appropriate type. */
	parameter_value = (int32_t)pvParameters;

	memset((void *) local_buffer, 0x00, sizeof(local_buffer));
  403d28:	4c09      	ldr	r4, [pc, #36]	; (403d50 <created_task+0x2c>)
  403d2a:	4620      	mov	r0, r4
  403d2c:	2100      	movs	r1, #0
  403d2e:	223c      	movs	r2, #60	; 0x3c
  403d30:	4b08      	ldr	r3, [pc, #32]	; (403d54 <created_task+0x30>)
  403d32:	4798      	blx	r3
	sprintf((char *) local_buffer,
  403d34:	4620      	mov	r0, r4
  403d36:	4908      	ldr	r1, [pc, #32]	; (403d58 <created_task+0x34>)
  403d38:	462a      	mov	r2, r5
  403d3a:	4b08      	ldr	r3, [pc, #32]	; (403d5c <created_task+0x38>)
  403d3c:	4798      	blx	r3
			(long) parameter_value);

	/* Cannot yet tell which CLI interface is in use, but both output functions
	guard check the port is initialised before it is used. */
#if (defined confINCLUDE_USART_CLI)
	usart_cli_output(local_buffer);
  403d3e:	4620      	mov	r0, r4
  403d40:	4b07      	ldr	r3, [pc, #28]	; (403d60 <created_task+0x3c>)
  403d42:	4798      	blx	r3
#if (defined confINCLUDE_CDC_CLI)
	cdc_cli_output(local_buffer);
#endif

	for (;;) {
		vTaskDelay(portMAX_DELAY);
  403d44:	f04f 35ff 	mov.w	r5, #4294967295
  403d48:	4c06      	ldr	r4, [pc, #24]	; (403d64 <created_task+0x40>)
  403d4a:	4628      	mov	r0, r5
  403d4c:	47a0      	blx	r4
	}
  403d4e:	e7fc      	b.n	403d4a <created_task+0x26>
  403d50:	20004e8c 	.word	0x20004e8c
  403d54:	004041d5 	.word	0x004041d5
  403d58:	00409cb0 	.word	0x00409cb0
  403d5c:	00404379 	.word	0x00404379
  403d60:	00401c11 	.word	0x00401c11
  403d64:	00402f3d 	.word	0x00402f3d

00403d68 <vRegisterCLICommands>:
};

/*-----------------------------------------------------------*/

void vRegisterCLICommands(void)
{
  403d68:	b510      	push	{r4, lr}
	/* Register all the command line commands defined immediately above. */
	FreeRTOS_CLIRegisterCommand(&task_stats_command_definition);
  403d6a:	4807      	ldr	r0, [pc, #28]	; (403d88 <vRegisterCLICommands+0x20>)
  403d6c:	4c07      	ldr	r4, [pc, #28]	; (403d8c <vRegisterCLICommands+0x24>)
  403d6e:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&run_time_stats_command_definition);
  403d70:	4807      	ldr	r0, [pc, #28]	; (403d90 <vRegisterCLICommands+0x28>)
  403d72:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&three_parameter_echo_command_definition);
  403d74:	4807      	ldr	r0, [pc, #28]	; (403d94 <vRegisterCLICommands+0x2c>)
  403d76:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&multi_parameter_echo_command_definition);
  403d78:	4807      	ldr	r0, [pc, #28]	; (403d98 <vRegisterCLICommands+0x30>)
  403d7a:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&create_task_command_definition);
  403d7c:	4807      	ldr	r0, [pc, #28]	; (403d9c <vRegisterCLICommands+0x34>)
  403d7e:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&delete_task_command_definition);
  403d80:	4807      	ldr	r0, [pc, #28]	; (403da0 <vRegisterCLICommands+0x38>)
  403d82:	47a0      	blx	r4
  403d84:	bd10      	pop	{r4, pc}
  403d86:	bf00      	nop
  403d88:	00409f64 	.word	0x00409f64
  403d8c:	00401c75 	.word	0x00401c75
  403d90:	00409ac0 	.word	0x00409ac0
  403d94:	00409f74 	.word	0x00409f74
  403d98:	00409ab0 	.word	0x00409ab0
  403d9c:	00409aa0 	.word	0x00409aa0
  403da0:	00409f54 	.word	0x00409f54

00403da4 <prvPrintTimerCallback>:
	/* Toggle an LED to show the system is executing. */
	vParTestToggleLED(mainSOFTWARE_TIMER_LED);
}

static void prvPrintTimerCallback(void *pvParameters)
{
  403da4:	b508      	push	{r3, lr}
	/* Just to remove compiler warnings. */
	(void) pvParameters;
	usart_cli_output("X");
  403da6:	4802      	ldr	r0, [pc, #8]	; (403db0 <prvPrintTimerCallback+0xc>)
  403da8:	4b02      	ldr	r3, [pc, #8]	; (403db4 <prvPrintTimerCallback+0x10>)
  403daa:	4798      	blx	r3
  403dac:	bd08      	pop	{r3, pc}
  403dae:	bf00      	nop
  403db0:	0040a130 	.word	0x0040a130
  403db4:	00401c11 	.word	0x00401c11

00403db8 <prvLEDTimerCallback>:
}

/*-----------------------------------------------------------*/

static void prvLEDTimerCallback(void *pvParameters)
{
  403db8:	b508      	push	{r3, lr}
	if (xStatus != pdPASS) {
		vParTestSetLED(mainERROR_LED, pdTRUE);
	}

	/* Toggle an LED to show the system is executing. */
	vParTestToggleLED(mainSOFTWARE_TIMER_LED);
  403dba:	2000      	movs	r0, #0
  403dbc:	4b01      	ldr	r3, [pc, #4]	; (403dc4 <prvLEDTimerCallback+0xc>)
  403dbe:	4798      	blx	r3
  403dc0:	bd08      	pop	{r3, pc}
  403dc2:	bf00      	nop
  403dc4:	00403f51 	.word	0x00403f51

00403dc8 <vApplicationMallocFailedHook>:
}

/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook(void)
{
  403dc8:	b508      	push	{r3, lr}
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
  403dca:	4b01      	ldr	r3, [pc, #4]	; (403dd0 <vApplicationMallocFailedHook+0x8>)
  403dcc:	4798      	blx	r3
	for (;;) {
	}
  403dce:	e7fe      	b.n	403dce <vApplicationMallocFailedHook+0x6>
  403dd0:	00401f55 	.word	0x00401f55

00403dd4 <vApplicationStackOverflowHook>:

/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook(xTaskHandle pxTask,
		signed char *pcTaskName)
{
  403dd4:	b508      	push	{r3, lr}
	(void) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
  403dd6:	4b01      	ldr	r3, [pc, #4]	; (403ddc <vApplicationStackOverflowHook+0x8>)
  403dd8:	4798      	blx	r3
	for (;;) {
	}
  403dda:	e7fe      	b.n	403dda <vApplicationStackOverflowHook+0x6>
  403ddc:	00401f55 	.word	0x00401f55

00403de0 <assert_triggered>:
}

/*-----------------------------------------------------------*/

void assert_triggered(const char *file, uint32_t line)
{
  403de0:	b500      	push	{lr}
  403de2:	b083      	sub	sp, #12
	volatile uint32_t block_var = 0, line_in;
  403de4:	2300      	movs	r3, #0
  403de6:	9301      	str	r3, [sp, #4]
	const char *file_in;

	/* These assignments are made to prevent the compiler optimizing the
	values away. */
	file_in = file;
	line_in = line;
  403de8:	9100      	str	r1, [sp, #0]
	(void) file_in;
	(void) line_in;
  403dea:	9b00      	ldr	r3, [sp, #0]

	taskENTER_CRITICAL();
  403dec:	4b04      	ldr	r3, [pc, #16]	; (403e00 <assert_triggered+0x20>)
  403dee:	4798      	blx	r3
	{
		while (block_var == 0) {
  403df0:	9b01      	ldr	r3, [sp, #4]
  403df2:	2b00      	cmp	r3, #0
  403df4:	d0fc      	beq.n	403df0 <assert_triggered+0x10>
			/* Set block_var to a non-zero value in the debugger to
			step out of this function. */
		}
	}
	taskEXIT_CRITICAL();
  403df6:	4b03      	ldr	r3, [pc, #12]	; (403e04 <assert_triggered+0x24>)
  403df8:	4798      	blx	r3
}
  403dfa:	b003      	add	sp, #12
  403dfc:	f85d fb04 	ldr.w	pc, [sp], #4
  403e00:	00401f65 	.word	0x00401f65
  403e04:	00401f85 	.word	0x00401f85

00403e08 <main>:
void vApplicationTickHook(void);

/*-----------------------------------------------------------*/

int main(void)
{
  403e08:	b530      	push	{r4, r5, lr}
  403e0a:	b083      	sub	sp, #12
/*-----------------------------------------------------------*/

static void prvSetupHardware(void)
{
	/* ASF function to setup clocking. */
	sysclk_init();
  403e0c:	4b27      	ldr	r3, [pc, #156]	; (403eac <main+0xa4>)
  403e0e:	4798      	blx	r3
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  403e10:	4a27      	ldr	r2, [pc, #156]	; (403eb0 <main+0xa8>)
  403e12:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  403e14:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  403e18:	041b      	lsls	r3, r3, #16
  403e1a:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                 |
  403e1c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  403e20:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
  403e24:	60d3      	str	r3, [r2, #12]

	/* Ensure all priority bits are assigned as preemption priority bits. */
	NVIC_SetPriorityGrouping(0);

	/* Atmel library function to setup for the evaluation kit being used. */
	board_init();
  403e26:	4b23      	ldr	r3, [pc, #140]	; (403eb4 <main+0xac>)
  403e28:	4798      	blx	r3

	/* Perform any initialisation required by the partest LED IO functions. */
	vParTestInitialise();
  403e2a:	4b23      	ldr	r3, [pc, #140]	; (403eb8 <main+0xb0>)
  403e2c:	4798      	blx	r3
	/* Prepare the hardware to run this demo. */
	prvSetupHardware();

	/* Create the timer that toggles an LED to show that the system is running,
	and that the other tasks are behaving as expected. */
	xLEDTimer = xTimerCreate((const signed char * const) "LED timer",/* A text name, purely to help debugging. */
  403e2e:	4b23      	ldr	r3, [pc, #140]	; (403ebc <main+0xb4>)
  403e30:	9300      	str	r3, [sp, #0]
  403e32:	4823      	ldr	r0, [pc, #140]	; (403ec0 <main+0xb8>)
  403e34:	21c8      	movs	r1, #200	; 0xc8
  403e36:	2201      	movs	r2, #1
  403e38:	2300      	movs	r3, #0
  403e3a:	4c22      	ldr	r4, [pc, #136]	; (403ec4 <main+0xbc>)
  403e3c:	47a0      	blx	r4
							prvLEDTimerCallback			/* The function that is called each time the timer expires. */
							);

	/* Sanity check the timer's creation, then start the timer.  The timer
	will not actually start until the FreeRTOS kernel is started. */
	configASSERT(xLEDTimer);
  403e3e:	b920      	cbnz	r0, 403e4a <main+0x42>
  403e40:	4821      	ldr	r0, [pc, #132]	; (403ec8 <main+0xc0>)
  403e42:	f240 117b 	movw	r1, #379	; 0x17b
  403e46:	4b21      	ldr	r3, [pc, #132]	; (403ecc <main+0xc4>)
  403e48:	4798      	blx	r3
	//xTimerStart(xLEDTimer, mainDONT_BLOCK);

	xPrintTimer = xTimerCreate((const signed char * const) "Print timer",/* A text name, purely to help debugging. */
  403e4a:	4b21      	ldr	r3, [pc, #132]	; (403ed0 <main+0xc8>)
  403e4c:	9300      	str	r3, [sp, #0]
  403e4e:	4821      	ldr	r0, [pc, #132]	; (403ed4 <main+0xcc>)
  403e50:	f640 31b8 	movw	r1, #3000	; 0xbb8
  403e54:	2201      	movs	r2, #1
  403e56:	2300      	movs	r3, #0
  403e58:	4c1a      	ldr	r4, [pc, #104]	; (403ec4 <main+0xbc>)
  403e5a:	47a0      	blx	r4
							(3000 / portTICK_RATE_MS),	/* The timer period. */
							pdTRUE,						/* This is an auto-reload timer, so xAutoReload is set to pdTRUE. */
							NULL,						/* The timer does not use its ID, so the ID is just set to NULL. */
							prvPrintTimerCallback		/* The function that is called each time the timer expires. */
							);
	configASSERT(xPrintTimer);
  403e5c:	4605      	mov	r5, r0
  403e5e:	b920      	cbnz	r0, 403e6a <main+0x62>
  403e60:	4819      	ldr	r0, [pc, #100]	; (403ec8 <main+0xc0>)
  403e62:	f44f 71c2 	mov.w	r1, #388	; 0x184
  403e66:	4b19      	ldr	r3, [pc, #100]	; (403ecc <main+0xc4>)
  403e68:	4798      	blx	r3
	xTimerStart(xPrintTimer, mainDONT_BLOCK);
  403e6a:	4b1b      	ldr	r3, [pc, #108]	; (403ed8 <main+0xd0>)
  403e6c:	4798      	blx	r3
  403e6e:	4602      	mov	r2, r0
  403e70:	2400      	movs	r4, #0
  403e72:	9400      	str	r4, [sp, #0]
  403e74:	4628      	mov	r0, r5
  403e76:	4621      	mov	r1, r4
  403e78:	4623      	mov	r3, r4
  403e7a:	4d18      	ldr	r5, [pc, #96]	; (403edc <main+0xd4>)
  403e7c:	47a8      	blx	r5
	}
	#endif /* confINCLUDE_USART_ECHO_TASKS */

	#if (defined confINCLUDE_USART_CLI)
	{
		create_usart_cli_task(BOARD_USART_CLI,
  403e7e:	4818      	ldr	r0, [pc, #96]	; (403ee0 <main+0xd8>)
  403e80:	f44f 71a0 	mov.w	r1, #320	; 0x140
  403e84:	2201      	movs	r2, #1
  403e86:	4b17      	ldr	r3, [pc, #92]	; (403ee4 <main+0xdc>)
  403e88:	4798      	blx	r3
		create_twi_eeprom_test_task(BOARD_BASE_TWI_EEPROM,
				mainTWI_EEPROM_TASK_STACK_SIZE,
				mainTWI_EEPROM_TASK_PRIORITY,
				mainDEMONSTRATE_ASYNCHRONOUS_API);
		*/		
		prepare_twi_task(TWI4,
  403e8a:	4817      	ldr	r0, [pc, #92]	; (403ee8 <main+0xe0>)
  403e8c:	f44f 71a0 	mov.w	r1, #320	; 0x140
  403e90:	2201      	movs	r2, #1
  403e92:	4623      	mov	r3, r4
  403e94:	4d15      	ldr	r5, [pc, #84]	; (403eec <main+0xe4>)
  403e96:	47a8      	blx	r5
				
	}
	#endif /* confINCLUDE_TWI_EEPROM_TASK */

	#if defined(__GNUC__)
		setbuf(stdout, NULL);
  403e98:	4b15      	ldr	r3, [pc, #84]	; (403ef0 <main+0xe8>)
  403e9a:	681b      	ldr	r3, [r3, #0]
  403e9c:	6898      	ldr	r0, [r3, #8]
  403e9e:	4621      	mov	r1, r4
  403ea0:	4b14      	ldr	r3, [pc, #80]	; (403ef4 <main+0xec>)
  403ea2:	4798      	blx	r3
		 * emits one character at a time.
		 */
	#endif

	/* Start the RTOS scheduler. */
	vTaskStartScheduler();
  403ea4:	4b14      	ldr	r3, [pc, #80]	; (403ef8 <main+0xf0>)
  403ea6:	4798      	blx	r3
	will never be reached.  If the following line does execute, then there was
	insufficient FreeRTOS heap memory available for the idle and/or timer tasks
	to be created.  See the memory management section on the FreeRTOS web site
	for more details. */
	for (;;) {
	}
  403ea8:	e7fe      	b.n	403ea8 <main+0xa0>
  403eaa:	bf00      	nop
  403eac:	00400795 	.word	0x00400795
  403eb0:	e000ed00 	.word	0xe000ed00
  403eb4:	004011f9 	.word	0x004011f9
  403eb8:	00403f31 	.word	0x00403f31
  403ebc:	00403db9 	.word	0x00403db9
  403ec0:	00409f84 	.word	0x00409f84
  403ec4:	00403739 	.word	0x00403739
  403ec8:	00409f90 	.word	0x00409f90
  403ecc:	00403de1 	.word	0x00403de1
  403ed0:	00403da5 	.word	0x00403da5
  403ed4:	00409fa0 	.word	0x00409fa0
  403ed8:	00402cc5 	.word	0x00402cc5
  403edc:	00403791 	.word	0x00403791
  403ee0:	40034200 	.word	0x40034200
  403ee4:	00401b91 	.word	0x00401b91
  403ee8:	4001c600 	.word	0x4001c600
  403eec:	004006ad 	.word	0x004006ad
  403ef0:	20000448 	.word	0x20000448
  403ef4:	00404271 	.word	0x00404271
  403ef8:	00402c39 	.word	0x00402c39

00403efc <vParTestSetLED>:

/*-----------------------------------------------------------*/

void vParTestSetLED(unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue)
{
	if (uxLED < partestNUM_LEDS) {
  403efc:	b988      	cbnz	r0, 403f22 <vParTestSetLED+0x26>
}

/*-----------------------------------------------------------*/

void vParTestSetLED(unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue)
{
  403efe:	b508      	push	{r3, lr}
	if (uxLED < partestNUM_LEDS) {
		if (xValue != pdFALSE) {
  403f00:	b139      	cbz	r1, 403f12 <vParTestSetLED+0x16>
			/* Turn the LED on. */
			taskENTER_CRITICAL();
  403f02:	4b08      	ldr	r3, [pc, #32]	; (403f24 <vParTestSetLED+0x28>)
  403f04:	4798      	blx	r3
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  403f06:	2240      	movs	r2, #64	; 0x40
  403f08:	4b07      	ldr	r3, [pc, #28]	; (403f28 <vParTestSetLED+0x2c>)
  403f0a:	635a      	str	r2, [r3, #52]	; 0x34
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
				} else {
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
				}
			}
			taskEXIT_CRITICAL();
  403f0c:	4b07      	ldr	r3, [pc, #28]	; (403f2c <vParTestSetLED+0x30>)
  403f0e:	4798      	blx	r3
  403f10:	bd08      	pop	{r3, pc}
		} else {
			/* Turn the LED off. */
			taskENTER_CRITICAL();
  403f12:	4b04      	ldr	r3, [pc, #16]	; (403f24 <vParTestSetLED+0x28>)
  403f14:	4798      	blx	r3
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  403f16:	2240      	movs	r2, #64	; 0x40
  403f18:	4b03      	ldr	r3, [pc, #12]	; (403f28 <vParTestSetLED+0x2c>)
  403f1a:	631a      	str	r2, [r3, #48]	; 0x30
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
				} else {
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
				}
			}
			taskEXIT_CRITICAL();
  403f1c:	4b03      	ldr	r3, [pc, #12]	; (403f2c <vParTestSetLED+0x30>)
  403f1e:	4798      	blx	r3
  403f20:	bd08      	pop	{r3, pc}
  403f22:	4770      	bx	lr
  403f24:	00401f65 	.word	0x00401f65
  403f28:	400e0e00 	.word	0x400e0e00
  403f2c:	00401f85 	.word	0x00401f85

00403f30 <vParTestInitialise>:
	= {LED0_ACTIVE_LEVEL, LED1_ACTIVE_LEVEL, LED2_ACTIVE_LEVEL};

/*-----------------------------------------------------------*/

void vParTestInitialise(void)
{
  403f30:	b508      	push	{r3, lr}
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  403f32:	4b05      	ldr	r3, [pc, #20]	; (403f48 <vParTestInitialise+0x18>)
  403f34:	2240      	movs	r2, #64	; 0x40
  403f36:	611a      	str	r2, [r3, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  403f38:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  403f3c:	631a      	str	r2, [r3, #48]	; 0x30
	for (ul = 0; ul < partestNUM_LEDS; ul++) {
		/* Configure the LED, before ensuring it starts in the off
		state. */
		ioport_set_pin_dir(ulLED[ ul ], IOPORT_DIR_OUTPUT);
        ioport_set_pin_level(ulLED[ ul ], IOPORT_PIN_LEVEL_HIGH);
		vParTestSetLED(ul, xActiveStates[ ul ]);
  403f3e:	2000      	movs	r0, #0
  403f40:	4601      	mov	r1, r0
  403f42:	4b02      	ldr	r3, [pc, #8]	; (403f4c <vParTestInitialise+0x1c>)
  403f44:	4798      	blx	r3
  403f46:	bd08      	pop	{r3, pc}
  403f48:	400e0e00 	.word	0x400e0e00
  403f4c:	00403efd 	.word	0x00403efd

00403f50 <vParTestToggleLED>:

/*-----------------------------------------------------------*/

void vParTestToggleLED(unsigned portBASE_TYPE uxLED)
{
	if (uxLED < partestNUM_LEDS) {
  403f50:	b978      	cbnz	r0, 403f72 <vParTestToggleLED+0x22>
}

/*-----------------------------------------------------------*/

void vParTestToggleLED(unsigned portBASE_TYPE uxLED)
{
  403f52:	b508      	push	{r3, lr}
	if (uxLED < partestNUM_LEDS) {
		taskENTER_CRITICAL();
  403f54:	4b07      	ldr	r3, [pc, #28]	; (403f74 <vParTestToggleLED+0x24>)
  403f56:	4798      	blx	r3
__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);

	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  403f58:	4b07      	ldr	r3, [pc, #28]	; (403f78 <vParTestToggleLED+0x28>)
  403f5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  403f5c:	f013 0f40 	tst.w	r3, #64	; 0x40
		port->PIO_CODR = mask;
  403f60:	f04f 0240 	mov.w	r2, #64	; 0x40
  403f64:	4b04      	ldr	r3, [pc, #16]	; (403f78 <vParTestToggleLED+0x28>)
  403f66:	bf14      	ite	ne
  403f68:	635a      	strne	r2, [r3, #52]	; 0x34
	} else {
		port->PIO_SODR = mask;
  403f6a:	631a      	streq	r2, [r3, #48]	; 0x30
		{
			ioport_toggle_pin_level(ulLED[ uxLED ]);
		}
		taskEXIT_CRITICAL();
  403f6c:	4b03      	ldr	r3, [pc, #12]	; (403f7c <vParTestToggleLED+0x2c>)
  403f6e:	4798      	blx	r3
  403f70:	bd08      	pop	{r3, pc}
  403f72:	4770      	bx	lr
  403f74:	00401f65 	.word	0x00401f65
  403f78:	400e0e00 	.word	0x400e0e00
  403f7c:	00401f85 	.word	0x00401f85

00403f80 <configure_timer_for_run_time_stats>:
/*-----------------------------------------------------------*/

void configure_timer_for_run_time_stats(void)
{
	/* How many clocks are there per tenth of a millisecond? */
	clocks_per_10th_ms = configCPU_CLOCK_HZ / 10000UL;
  403f80:	f642 62df 	movw	r2, #11999	; 0x2edf
  403f84:	4b01      	ldr	r3, [pc, #4]	; (403f8c <configure_timer_for_run_time_stats+0xc>)
  403f86:	601a      	str	r2, [r3, #0]
  403f88:	4770      	bx	lr
  403f8a:	bf00      	nop
  403f8c:	20004ecc 	.word	0x20004ecc

00403f90 <get_run_time_counter_value>:
}

/*-----------------------------------------------------------*/

uint32_t get_run_time_counter_value(void)
{
  403f90:	b538      	push	{r3, r4, r5, lr}
	used anyway to keep the examples simple, and to avoid reliance on a
	separate timer peripheral. */

	/* The SysTick is a down counter.  How many clocks have passed since it
	was last reloaded? */
	sys_tick_counts = sys_tick_reload_value - *current_sys_tick_count;
  403f92:	4b0f      	ldr	r3, [pc, #60]	; (403fd0 <get_run_time_counter_value+0x40>)
  403f94:	681c      	ldr	r4, [r3, #0]

	/* How many times has it overflowed? */
	tick_count = xTaskGetTickCountFromISR();
  403f96:	4b0f      	ldr	r3, [pc, #60]	; (403fd4 <get_run_time_counter_value+0x44>)
  403f98:	4798      	blx	r3
  403f9a:	4605      	mov	r5, r0

	/* This is called from the context switch, so will be called from a
	critical section.  xTaskGetTickCountFromISR() contains its own critical
	section, and the ISR safe critical sections are not designed to nest,
	so reset the critical section. */
	ulReturn = portSET_INTERRUPT_MASK_FROM_ISR();
  403f9c:	4b0e      	ldr	r3, [pc, #56]	; (403fd8 <get_run_time_counter_value+0x48>)
  403f9e:	4798      	blx	r3
	(void) ulReturn;

	/* Is there a SysTick interrupt pending? */
	if ((*interrupt_ctrl_statee & sys_tick_pending_bit) != 0UL) {
  403fa0:	4b0e      	ldr	r3, [pc, #56]	; (403fdc <get_run_time_counter_value+0x4c>)
  403fa2:	681b      	ldr	r3, [r3, #0]
  403fa4:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
  403fa8:	d103      	bne.n	403fb2 <get_run_time_counter_value+0x22>
	used anyway to keep the examples simple, and to avoid reliance on a
	separate timer peripheral. */

	/* The SysTick is a down counter.  How many clocks have passed since it
	was last reloaded? */
	sys_tick_counts = sys_tick_reload_value - *current_sys_tick_count;
  403faa:	f5c4 33ea 	rsb	r3, r4, #119808	; 0x1d400
  403fae:	33bb      	adds	r3, #187	; 0xbb
  403fb0:	e005      	b.n	403fbe <get_run_time_counter_value+0x2e>

	/* Is there a SysTick interrupt pending? */
	if ((*interrupt_ctrl_statee & sys_tick_pending_bit) != 0UL) {
		/* There is a SysTick interrupt pending, so the SysTick has overflowed
		but the tick count not yet incremented. */
		tick_count++;
  403fb2:	3501      	adds	r5, #1

		/* Read the SysTick again, as the overflow might have occurred since
		it was read last. */
		sys_tick_counts = sys_tick_reload_value -
				*current_sys_tick_count;
  403fb4:	4b06      	ldr	r3, [pc, #24]	; (403fd0 <get_run_time_counter_value+0x40>)
  403fb6:	681b      	ldr	r3, [r3, #0]
		but the tick count not yet incremented. */
		tick_count++;

		/* Read the SysTick again, as the overflow might have occurred since
		it was read last. */
		sys_tick_counts = sys_tick_reload_value -
  403fb8:	f5c3 33ea 	rsb	r3, r3, #119808	; 0x1d400
  403fbc:	33bb      	adds	r3, #187	; 0xbb
				*current_sys_tick_count;
	}

	/* Convert the tick count into tenths of a millisecond.  THIS ASSUMES
	configTICK_RATE_HZ is 1000! */
	ulReturn = (tick_count * 10UL);
  403fbe:	eb05 0585 	add.w	r5, r5, r5, lsl #2

	/* Add on the number of tenths of a millisecond that have passed since
	the tick count last got updated. */
	ulReturn += (sys_tick_counts / clocks_per_10th_ms);
  403fc2:	4a07      	ldr	r2, [pc, #28]	; (403fe0 <get_run_time_counter_value+0x50>)
  403fc4:	6810      	ldr	r0, [r2, #0]
  403fc6:	fbb3 f0f0 	udiv	r0, r3, r0

	return ulReturn;
}
  403fca:	eb00 0045 	add.w	r0, r0, r5, lsl #1
  403fce:	bd38      	pop	{r3, r4, r5, pc}
  403fd0:	e000e018 	.word	0xe000e018
  403fd4:	00402ce5 	.word	0x00402ce5
  403fd8:	00401f55 	.word	0x00401f55
  403fdc:	e000ed04 	.word	0xe000ed04
  403fe0:	20004ecc 	.word	0x20004ecc

00403fe4 <atol>:
  403fe4:	2100      	movs	r1, #0
  403fe6:	220a      	movs	r2, #10
  403fe8:	f000 bbd4 	b.w	404794 <strtol>

00403fec <__libc_init_array>:
  403fec:	b570      	push	{r4, r5, r6, lr}
  403fee:	4e0f      	ldr	r6, [pc, #60]	; (40402c <__libc_init_array+0x40>)
  403ff0:	4d0f      	ldr	r5, [pc, #60]	; (404030 <__libc_init_array+0x44>)
  403ff2:	1b76      	subs	r6, r6, r5
  403ff4:	10b6      	asrs	r6, r6, #2
  403ff6:	bf18      	it	ne
  403ff8:	2400      	movne	r4, #0
  403ffa:	d005      	beq.n	404008 <__libc_init_array+0x1c>
  403ffc:	3401      	adds	r4, #1
  403ffe:	f855 3b04 	ldr.w	r3, [r5], #4
  404002:	4798      	blx	r3
  404004:	42a6      	cmp	r6, r4
  404006:	d1f9      	bne.n	403ffc <__libc_init_array+0x10>
  404008:	4e0a      	ldr	r6, [pc, #40]	; (404034 <__libc_init_array+0x48>)
  40400a:	4d0b      	ldr	r5, [pc, #44]	; (404038 <__libc_init_array+0x4c>)
  40400c:	1b76      	subs	r6, r6, r5
  40400e:	f006 f913 	bl	40a238 <_init>
  404012:	10b6      	asrs	r6, r6, #2
  404014:	bf18      	it	ne
  404016:	2400      	movne	r4, #0
  404018:	d006      	beq.n	404028 <__libc_init_array+0x3c>
  40401a:	3401      	adds	r4, #1
  40401c:	f855 3b04 	ldr.w	r3, [r5], #4
  404020:	4798      	blx	r3
  404022:	42a6      	cmp	r6, r4
  404024:	d1f9      	bne.n	40401a <__libc_init_array+0x2e>
  404026:	bd70      	pop	{r4, r5, r6, pc}
  404028:	bd70      	pop	{r4, r5, r6, pc}
  40402a:	bf00      	nop
  40402c:	0040a244 	.word	0x0040a244
  404030:	0040a244 	.word	0x0040a244
  404034:	0040a24c 	.word	0x0040a24c
  404038:	0040a244 	.word	0x0040a244

0040403c <memcmp>:
  40403c:	2a03      	cmp	r2, #3
  40403e:	b470      	push	{r4, r5, r6}
  404040:	d926      	bls.n	404090 <memcmp+0x54>
  404042:	ea40 0301 	orr.w	r3, r0, r1
  404046:	079b      	lsls	r3, r3, #30
  404048:	d011      	beq.n	40406e <memcmp+0x32>
  40404a:	7804      	ldrb	r4, [r0, #0]
  40404c:	780d      	ldrb	r5, [r1, #0]
  40404e:	42ac      	cmp	r4, r5
  404050:	d122      	bne.n	404098 <memcmp+0x5c>
  404052:	4402      	add	r2, r0
  404054:	1c43      	adds	r3, r0, #1
  404056:	e005      	b.n	404064 <memcmp+0x28>
  404058:	f813 4b01 	ldrb.w	r4, [r3], #1
  40405c:	f811 5f01 	ldrb.w	r5, [r1, #1]!
  404060:	42ac      	cmp	r4, r5
  404062:	d119      	bne.n	404098 <memcmp+0x5c>
  404064:	4293      	cmp	r3, r2
  404066:	d1f7      	bne.n	404058 <memcmp+0x1c>
  404068:	2000      	movs	r0, #0
  40406a:	bc70      	pop	{r4, r5, r6}
  40406c:	4770      	bx	lr
  40406e:	460c      	mov	r4, r1
  404070:	4603      	mov	r3, r0
  404072:	681e      	ldr	r6, [r3, #0]
  404074:	6825      	ldr	r5, [r4, #0]
  404076:	42ae      	cmp	r6, r5
  404078:	4618      	mov	r0, r3
  40407a:	4621      	mov	r1, r4
  40407c:	f103 0304 	add.w	r3, r3, #4
  404080:	f104 0404 	add.w	r4, r4, #4
  404084:	d104      	bne.n	404090 <memcmp+0x54>
  404086:	3a04      	subs	r2, #4
  404088:	2a03      	cmp	r2, #3
  40408a:	4618      	mov	r0, r3
  40408c:	4621      	mov	r1, r4
  40408e:	d8f0      	bhi.n	404072 <memcmp+0x36>
  404090:	2a00      	cmp	r2, #0
  404092:	d1da      	bne.n	40404a <memcmp+0xe>
  404094:	4610      	mov	r0, r2
  404096:	e7e8      	b.n	40406a <memcmp+0x2e>
  404098:	1b60      	subs	r0, r4, r5
  40409a:	bc70      	pop	{r4, r5, r6}
  40409c:	4770      	bx	lr
  40409e:	bf00      	nop

004040a0 <memcpy>:
  4040a0:	4684      	mov	ip, r0
  4040a2:	ea41 0300 	orr.w	r3, r1, r0
  4040a6:	f013 0303 	ands.w	r3, r3, #3
  4040aa:	d16d      	bne.n	404188 <memcpy+0xe8>
  4040ac:	3a40      	subs	r2, #64	; 0x40
  4040ae:	d341      	bcc.n	404134 <memcpy+0x94>
  4040b0:	f851 3b04 	ldr.w	r3, [r1], #4
  4040b4:	f840 3b04 	str.w	r3, [r0], #4
  4040b8:	f851 3b04 	ldr.w	r3, [r1], #4
  4040bc:	f840 3b04 	str.w	r3, [r0], #4
  4040c0:	f851 3b04 	ldr.w	r3, [r1], #4
  4040c4:	f840 3b04 	str.w	r3, [r0], #4
  4040c8:	f851 3b04 	ldr.w	r3, [r1], #4
  4040cc:	f840 3b04 	str.w	r3, [r0], #4
  4040d0:	f851 3b04 	ldr.w	r3, [r1], #4
  4040d4:	f840 3b04 	str.w	r3, [r0], #4
  4040d8:	f851 3b04 	ldr.w	r3, [r1], #4
  4040dc:	f840 3b04 	str.w	r3, [r0], #4
  4040e0:	f851 3b04 	ldr.w	r3, [r1], #4
  4040e4:	f840 3b04 	str.w	r3, [r0], #4
  4040e8:	f851 3b04 	ldr.w	r3, [r1], #4
  4040ec:	f840 3b04 	str.w	r3, [r0], #4
  4040f0:	f851 3b04 	ldr.w	r3, [r1], #4
  4040f4:	f840 3b04 	str.w	r3, [r0], #4
  4040f8:	f851 3b04 	ldr.w	r3, [r1], #4
  4040fc:	f840 3b04 	str.w	r3, [r0], #4
  404100:	f851 3b04 	ldr.w	r3, [r1], #4
  404104:	f840 3b04 	str.w	r3, [r0], #4
  404108:	f851 3b04 	ldr.w	r3, [r1], #4
  40410c:	f840 3b04 	str.w	r3, [r0], #4
  404110:	f851 3b04 	ldr.w	r3, [r1], #4
  404114:	f840 3b04 	str.w	r3, [r0], #4
  404118:	f851 3b04 	ldr.w	r3, [r1], #4
  40411c:	f840 3b04 	str.w	r3, [r0], #4
  404120:	f851 3b04 	ldr.w	r3, [r1], #4
  404124:	f840 3b04 	str.w	r3, [r0], #4
  404128:	f851 3b04 	ldr.w	r3, [r1], #4
  40412c:	f840 3b04 	str.w	r3, [r0], #4
  404130:	3a40      	subs	r2, #64	; 0x40
  404132:	d2bd      	bcs.n	4040b0 <memcpy+0x10>
  404134:	3230      	adds	r2, #48	; 0x30
  404136:	d311      	bcc.n	40415c <memcpy+0xbc>
  404138:	f851 3b04 	ldr.w	r3, [r1], #4
  40413c:	f840 3b04 	str.w	r3, [r0], #4
  404140:	f851 3b04 	ldr.w	r3, [r1], #4
  404144:	f840 3b04 	str.w	r3, [r0], #4
  404148:	f851 3b04 	ldr.w	r3, [r1], #4
  40414c:	f840 3b04 	str.w	r3, [r0], #4
  404150:	f851 3b04 	ldr.w	r3, [r1], #4
  404154:	f840 3b04 	str.w	r3, [r0], #4
  404158:	3a10      	subs	r2, #16
  40415a:	d2ed      	bcs.n	404138 <memcpy+0x98>
  40415c:	320c      	adds	r2, #12
  40415e:	d305      	bcc.n	40416c <memcpy+0xcc>
  404160:	f851 3b04 	ldr.w	r3, [r1], #4
  404164:	f840 3b04 	str.w	r3, [r0], #4
  404168:	3a04      	subs	r2, #4
  40416a:	d2f9      	bcs.n	404160 <memcpy+0xc0>
  40416c:	3204      	adds	r2, #4
  40416e:	d008      	beq.n	404182 <memcpy+0xe2>
  404170:	07d2      	lsls	r2, r2, #31
  404172:	bf1c      	itt	ne
  404174:	f811 3b01 	ldrbne.w	r3, [r1], #1
  404178:	f800 3b01 	strbne.w	r3, [r0], #1
  40417c:	d301      	bcc.n	404182 <memcpy+0xe2>
  40417e:	880b      	ldrh	r3, [r1, #0]
  404180:	8003      	strh	r3, [r0, #0]
  404182:	4660      	mov	r0, ip
  404184:	4770      	bx	lr
  404186:	bf00      	nop
  404188:	2a08      	cmp	r2, #8
  40418a:	d313      	bcc.n	4041b4 <memcpy+0x114>
  40418c:	078b      	lsls	r3, r1, #30
  40418e:	d08d      	beq.n	4040ac <memcpy+0xc>
  404190:	f010 0303 	ands.w	r3, r0, #3
  404194:	d08a      	beq.n	4040ac <memcpy+0xc>
  404196:	f1c3 0304 	rsb	r3, r3, #4
  40419a:	1ad2      	subs	r2, r2, r3
  40419c:	07db      	lsls	r3, r3, #31
  40419e:	bf1c      	itt	ne
  4041a0:	f811 3b01 	ldrbne.w	r3, [r1], #1
  4041a4:	f800 3b01 	strbne.w	r3, [r0], #1
  4041a8:	d380      	bcc.n	4040ac <memcpy+0xc>
  4041aa:	f831 3b02 	ldrh.w	r3, [r1], #2
  4041ae:	f820 3b02 	strh.w	r3, [r0], #2
  4041b2:	e77b      	b.n	4040ac <memcpy+0xc>
  4041b4:	3a04      	subs	r2, #4
  4041b6:	d3d9      	bcc.n	40416c <memcpy+0xcc>
  4041b8:	3a01      	subs	r2, #1
  4041ba:	f811 3b01 	ldrb.w	r3, [r1], #1
  4041be:	f800 3b01 	strb.w	r3, [r0], #1
  4041c2:	d2f9      	bcs.n	4041b8 <memcpy+0x118>
  4041c4:	780b      	ldrb	r3, [r1, #0]
  4041c6:	7003      	strb	r3, [r0, #0]
  4041c8:	784b      	ldrb	r3, [r1, #1]
  4041ca:	7043      	strb	r3, [r0, #1]
  4041cc:	788b      	ldrb	r3, [r1, #2]
  4041ce:	7083      	strb	r3, [r0, #2]
  4041d0:	4660      	mov	r0, ip
  4041d2:	4770      	bx	lr

004041d4 <memset>:
  4041d4:	b470      	push	{r4, r5, r6}
  4041d6:	0784      	lsls	r4, r0, #30
  4041d8:	d046      	beq.n	404268 <memset+0x94>
  4041da:	1e54      	subs	r4, r2, #1
  4041dc:	2a00      	cmp	r2, #0
  4041de:	d041      	beq.n	404264 <memset+0x90>
  4041e0:	b2cd      	uxtb	r5, r1
  4041e2:	4603      	mov	r3, r0
  4041e4:	e002      	b.n	4041ec <memset+0x18>
  4041e6:	1e62      	subs	r2, r4, #1
  4041e8:	b3e4      	cbz	r4, 404264 <memset+0x90>
  4041ea:	4614      	mov	r4, r2
  4041ec:	f803 5b01 	strb.w	r5, [r3], #1
  4041f0:	079a      	lsls	r2, r3, #30
  4041f2:	d1f8      	bne.n	4041e6 <memset+0x12>
  4041f4:	2c03      	cmp	r4, #3
  4041f6:	d92e      	bls.n	404256 <memset+0x82>
  4041f8:	b2cd      	uxtb	r5, r1
  4041fa:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  4041fe:	2c0f      	cmp	r4, #15
  404200:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  404204:	d919      	bls.n	40423a <memset+0x66>
  404206:	f103 0210 	add.w	r2, r3, #16
  40420a:	4626      	mov	r6, r4
  40420c:	3e10      	subs	r6, #16
  40420e:	2e0f      	cmp	r6, #15
  404210:	f842 5c10 	str.w	r5, [r2, #-16]
  404214:	f842 5c0c 	str.w	r5, [r2, #-12]
  404218:	f842 5c08 	str.w	r5, [r2, #-8]
  40421c:	f842 5c04 	str.w	r5, [r2, #-4]
  404220:	f102 0210 	add.w	r2, r2, #16
  404224:	d8f2      	bhi.n	40420c <memset+0x38>
  404226:	f1a4 0210 	sub.w	r2, r4, #16
  40422a:	f022 020f 	bic.w	r2, r2, #15
  40422e:	f004 040f 	and.w	r4, r4, #15
  404232:	3210      	adds	r2, #16
  404234:	2c03      	cmp	r4, #3
  404236:	4413      	add	r3, r2
  404238:	d90d      	bls.n	404256 <memset+0x82>
  40423a:	461e      	mov	r6, r3
  40423c:	4622      	mov	r2, r4
  40423e:	3a04      	subs	r2, #4
  404240:	2a03      	cmp	r2, #3
  404242:	f846 5b04 	str.w	r5, [r6], #4
  404246:	d8fa      	bhi.n	40423e <memset+0x6a>
  404248:	1f22      	subs	r2, r4, #4
  40424a:	f022 0203 	bic.w	r2, r2, #3
  40424e:	3204      	adds	r2, #4
  404250:	4413      	add	r3, r2
  404252:	f004 0403 	and.w	r4, r4, #3
  404256:	b12c      	cbz	r4, 404264 <memset+0x90>
  404258:	b2c9      	uxtb	r1, r1
  40425a:	441c      	add	r4, r3
  40425c:	f803 1b01 	strb.w	r1, [r3], #1
  404260:	42a3      	cmp	r3, r4
  404262:	d1fb      	bne.n	40425c <memset+0x88>
  404264:	bc70      	pop	{r4, r5, r6}
  404266:	4770      	bx	lr
  404268:	4614      	mov	r4, r2
  40426a:	4603      	mov	r3, r0
  40426c:	e7c2      	b.n	4041f4 <memset+0x20>
  40426e:	bf00      	nop

00404270 <setbuf>:
  404270:	2900      	cmp	r1, #0
  404272:	bf0c      	ite	eq
  404274:	2202      	moveq	r2, #2
  404276:	2200      	movne	r2, #0
  404278:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40427c:	f000 b800 	b.w	404280 <setvbuf>

00404280 <setvbuf>:
  404280:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  404284:	4c3a      	ldr	r4, [pc, #232]	; (404370 <setvbuf+0xf0>)
  404286:	6826      	ldr	r6, [r4, #0]
  404288:	460d      	mov	r5, r1
  40428a:	4604      	mov	r4, r0
  40428c:	4690      	mov	r8, r2
  40428e:	461f      	mov	r7, r3
  404290:	b116      	cbz	r6, 404298 <setvbuf+0x18>
  404292:	6bb3      	ldr	r3, [r6, #56]	; 0x38
  404294:	2b00      	cmp	r3, #0
  404296:	d03c      	beq.n	404312 <setvbuf+0x92>
  404298:	f1b8 0f02 	cmp.w	r8, #2
  40429c:	d82f      	bhi.n	4042fe <setvbuf+0x7e>
  40429e:	2f00      	cmp	r7, #0
  4042a0:	db2d      	blt.n	4042fe <setvbuf+0x7e>
  4042a2:	4621      	mov	r1, r4
  4042a4:	4630      	mov	r0, r6
  4042a6:	f002 fd67 	bl	406d78 <_fflush_r>
  4042aa:	89a1      	ldrh	r1, [r4, #12]
  4042ac:	2300      	movs	r3, #0
  4042ae:	6063      	str	r3, [r4, #4]
  4042b0:	61a3      	str	r3, [r4, #24]
  4042b2:	060b      	lsls	r3, r1, #24
  4042b4:	d427      	bmi.n	404306 <setvbuf+0x86>
  4042b6:	f021 0183 	bic.w	r1, r1, #131	; 0x83
  4042ba:	b289      	uxth	r1, r1
  4042bc:	f1b8 0f02 	cmp.w	r8, #2
  4042c0:	81a1      	strh	r1, [r4, #12]
  4042c2:	d02a      	beq.n	40431a <setvbuf+0x9a>
  4042c4:	2d00      	cmp	r5, #0
  4042c6:	d036      	beq.n	404336 <setvbuf+0xb6>
  4042c8:	f1b8 0f01 	cmp.w	r8, #1
  4042cc:	d011      	beq.n	4042f2 <setvbuf+0x72>
  4042ce:	b289      	uxth	r1, r1
  4042d0:	f001 0008 	and.w	r0, r1, #8
  4042d4:	4b27      	ldr	r3, [pc, #156]	; (404374 <setvbuf+0xf4>)
  4042d6:	63f3      	str	r3, [r6, #60]	; 0x3c
  4042d8:	b280      	uxth	r0, r0
  4042da:	6025      	str	r5, [r4, #0]
  4042dc:	6125      	str	r5, [r4, #16]
  4042de:	6167      	str	r7, [r4, #20]
  4042e0:	b178      	cbz	r0, 404302 <setvbuf+0x82>
  4042e2:	f011 0f03 	tst.w	r1, #3
  4042e6:	bf18      	it	ne
  4042e8:	2700      	movne	r7, #0
  4042ea:	60a7      	str	r7, [r4, #8]
  4042ec:	2000      	movs	r0, #0
  4042ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4042f2:	f041 0101 	orr.w	r1, r1, #1
  4042f6:	427b      	negs	r3, r7
  4042f8:	81a1      	strh	r1, [r4, #12]
  4042fa:	61a3      	str	r3, [r4, #24]
  4042fc:	e7e7      	b.n	4042ce <setvbuf+0x4e>
  4042fe:	f04f 30ff 	mov.w	r0, #4294967295
  404302:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404306:	6921      	ldr	r1, [r4, #16]
  404308:	4630      	mov	r0, r6
  40430a:	f002 fe37 	bl	406f7c <_free_r>
  40430e:	89a1      	ldrh	r1, [r4, #12]
  404310:	e7d1      	b.n	4042b6 <setvbuf+0x36>
  404312:	4630      	mov	r0, r6
  404314:	f002 fdc4 	bl	406ea0 <__sinit>
  404318:	e7be      	b.n	404298 <setvbuf+0x18>
  40431a:	2000      	movs	r0, #0
  40431c:	f104 0343 	add.w	r3, r4, #67	; 0x43
  404320:	f041 0102 	orr.w	r1, r1, #2
  404324:	2500      	movs	r5, #0
  404326:	2201      	movs	r2, #1
  404328:	81a1      	strh	r1, [r4, #12]
  40432a:	60a5      	str	r5, [r4, #8]
  40432c:	6023      	str	r3, [r4, #0]
  40432e:	6123      	str	r3, [r4, #16]
  404330:	6162      	str	r2, [r4, #20]
  404332:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404336:	2f00      	cmp	r7, #0
  404338:	bf08      	it	eq
  40433a:	f44f 6780 	moveq.w	r7, #1024	; 0x400
  40433e:	4638      	mov	r0, r7
  404340:	f002 ff22 	bl	407188 <malloc>
  404344:	4605      	mov	r5, r0
  404346:	b128      	cbz	r0, 404354 <setvbuf+0xd4>
  404348:	89a1      	ldrh	r1, [r4, #12]
  40434a:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  40434e:	b289      	uxth	r1, r1
  404350:	81a1      	strh	r1, [r4, #12]
  404352:	e7b9      	b.n	4042c8 <setvbuf+0x48>
  404354:	f44f 6080 	mov.w	r0, #1024	; 0x400
  404358:	f002 ff16 	bl	407188 <malloc>
  40435c:	4605      	mov	r5, r0
  40435e:	b918      	cbnz	r0, 404368 <setvbuf+0xe8>
  404360:	89a1      	ldrh	r1, [r4, #12]
  404362:	f04f 30ff 	mov.w	r0, #4294967295
  404366:	e7d9      	b.n	40431c <setvbuf+0x9c>
  404368:	f44f 6780 	mov.w	r7, #1024	; 0x400
  40436c:	e7ec      	b.n	404348 <setvbuf+0xc8>
  40436e:	bf00      	nop
  404370:	20000448 	.word	0x20000448
  404374:	00406da5 	.word	0x00406da5

00404378 <sprintf>:
  404378:	b40e      	push	{r1, r2, r3}
  40437a:	b5f0      	push	{r4, r5, r6, r7, lr}
  40437c:	b09c      	sub	sp, #112	; 0x70
  40437e:	ab21      	add	r3, sp, #132	; 0x84
  404380:	490f      	ldr	r1, [pc, #60]	; (4043c0 <sprintf+0x48>)
  404382:	f853 2b04 	ldr.w	r2, [r3], #4
  404386:	9301      	str	r3, [sp, #4]
  404388:	4605      	mov	r5, r0
  40438a:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
  40438e:	6808      	ldr	r0, [r1, #0]
  404390:	9502      	str	r5, [sp, #8]
  404392:	f44f 7702 	mov.w	r7, #520	; 0x208
  404396:	f64f 76ff 	movw	r6, #65535	; 0xffff
  40439a:	a902      	add	r1, sp, #8
  40439c:	9506      	str	r5, [sp, #24]
  40439e:	f8ad 7014 	strh.w	r7, [sp, #20]
  4043a2:	9404      	str	r4, [sp, #16]
  4043a4:	9407      	str	r4, [sp, #28]
  4043a6:	f8ad 6016 	strh.w	r6, [sp, #22]
  4043aa:	f000 f9ff 	bl	4047ac <_svfprintf_r>
  4043ae:	9b02      	ldr	r3, [sp, #8]
  4043b0:	2200      	movs	r2, #0
  4043b2:	701a      	strb	r2, [r3, #0]
  4043b4:	b01c      	add	sp, #112	; 0x70
  4043b6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  4043ba:	b003      	add	sp, #12
  4043bc:	4770      	bx	lr
  4043be:	bf00      	nop
  4043c0:	20000448 	.word	0x20000448

004043c4 <strcat>:
  4043c4:	0783      	lsls	r3, r0, #30
  4043c6:	b510      	push	{r4, lr}
  4043c8:	4604      	mov	r4, r0
  4043ca:	d110      	bne.n	4043ee <strcat+0x2a>
  4043cc:	6802      	ldr	r2, [r0, #0]
  4043ce:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
  4043d2:	ea23 0302 	bic.w	r3, r3, r2
  4043d6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  4043da:	d108      	bne.n	4043ee <strcat+0x2a>
  4043dc:	f850 2f04 	ldr.w	r2, [r0, #4]!
  4043e0:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
  4043e4:	ea23 0302 	bic.w	r3, r3, r2
  4043e8:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  4043ec:	d0f6      	beq.n	4043dc <strcat+0x18>
  4043ee:	7803      	ldrb	r3, [r0, #0]
  4043f0:	b11b      	cbz	r3, 4043fa <strcat+0x36>
  4043f2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  4043f6:	2b00      	cmp	r3, #0
  4043f8:	d1fb      	bne.n	4043f2 <strcat+0x2e>
  4043fa:	f000 f803 	bl	404404 <strcpy>
  4043fe:	4620      	mov	r0, r4
  404400:	bd10      	pop	{r4, pc}
  404402:	bf00      	nop

00404404 <strcpy>:
  404404:	ea80 0201 	eor.w	r2, r0, r1
  404408:	4684      	mov	ip, r0
  40440a:	f012 0f03 	tst.w	r2, #3
  40440e:	d14f      	bne.n	4044b0 <strcpy+0xac>
  404410:	f011 0f03 	tst.w	r1, #3
  404414:	d132      	bne.n	40447c <strcpy+0x78>
  404416:	f84d 4d04 	str.w	r4, [sp, #-4]!
  40441a:	f011 0f04 	tst.w	r1, #4
  40441e:	f851 3b04 	ldr.w	r3, [r1], #4
  404422:	d00b      	beq.n	40443c <strcpy+0x38>
  404424:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
  404428:	439a      	bics	r2, r3
  40442a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  40442e:	bf04      	itt	eq
  404430:	f84c 3b04 	streq.w	r3, [ip], #4
  404434:	f851 3b04 	ldreq.w	r3, [r1], #4
  404438:	d116      	bne.n	404468 <strcpy+0x64>
  40443a:	bf00      	nop
  40443c:	f851 4b04 	ldr.w	r4, [r1], #4
  404440:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
  404444:	439a      	bics	r2, r3
  404446:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  40444a:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
  40444e:	d10b      	bne.n	404468 <strcpy+0x64>
  404450:	f84c 3b04 	str.w	r3, [ip], #4
  404454:	43a2      	bics	r2, r4
  404456:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  40445a:	bf04      	itt	eq
  40445c:	f851 3b04 	ldreq.w	r3, [r1], #4
  404460:	f84c 4b04 	streq.w	r4, [ip], #4
  404464:	d0ea      	beq.n	40443c <strcpy+0x38>
  404466:	4623      	mov	r3, r4
  404468:	f80c 3b01 	strb.w	r3, [ip], #1
  40446c:	f013 0fff 	tst.w	r3, #255	; 0xff
  404470:	ea4f 2333 	mov.w	r3, r3, ror #8
  404474:	d1f8      	bne.n	404468 <strcpy+0x64>
  404476:	f85d 4b04 	ldr.w	r4, [sp], #4
  40447a:	4770      	bx	lr
  40447c:	f011 0f01 	tst.w	r1, #1
  404480:	d006      	beq.n	404490 <strcpy+0x8c>
  404482:	f811 2b01 	ldrb.w	r2, [r1], #1
  404486:	f80c 2b01 	strb.w	r2, [ip], #1
  40448a:	2a00      	cmp	r2, #0
  40448c:	bf08      	it	eq
  40448e:	4770      	bxeq	lr
  404490:	f011 0f02 	tst.w	r1, #2
  404494:	d0bf      	beq.n	404416 <strcpy+0x12>
  404496:	f831 2b02 	ldrh.w	r2, [r1], #2
  40449a:	f012 0fff 	tst.w	r2, #255	; 0xff
  40449e:	bf16      	itet	ne
  4044a0:	f82c 2b02 	strhne.w	r2, [ip], #2
  4044a4:	f88c 2000 	strbeq.w	r2, [ip]
  4044a8:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
  4044ac:	d1b3      	bne.n	404416 <strcpy+0x12>
  4044ae:	4770      	bx	lr
  4044b0:	f811 2b01 	ldrb.w	r2, [r1], #1
  4044b4:	f80c 2b01 	strb.w	r2, [ip], #1
  4044b8:	2a00      	cmp	r2, #0
  4044ba:	d1f9      	bne.n	4044b0 <strcpy+0xac>
  4044bc:	4770      	bx	lr
  4044be:	bf00      	nop

004044c0 <strlen>:
  4044c0:	f020 0103 	bic.w	r1, r0, #3
  4044c4:	f010 0003 	ands.w	r0, r0, #3
  4044c8:	f1c0 0000 	rsb	r0, r0, #0
  4044cc:	f851 3b04 	ldr.w	r3, [r1], #4
  4044d0:	f100 0c04 	add.w	ip, r0, #4
  4044d4:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
  4044d8:	f06f 0200 	mvn.w	r2, #0
  4044dc:	bf1c      	itt	ne
  4044de:	fa22 f20c 	lsrne.w	r2, r2, ip
  4044e2:	4313      	orrne	r3, r2
  4044e4:	f04f 0c01 	mov.w	ip, #1
  4044e8:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
  4044ec:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
  4044f0:	eba3 020c 	sub.w	r2, r3, ip
  4044f4:	ea22 0203 	bic.w	r2, r2, r3
  4044f8:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
  4044fc:	bf04      	itt	eq
  4044fe:	f851 3b04 	ldreq.w	r3, [r1], #4
  404502:	3004      	addeq	r0, #4
  404504:	d0f4      	beq.n	4044f0 <strlen+0x30>
  404506:	f1c2 0100 	rsb	r1, r2, #0
  40450a:	ea02 0201 	and.w	r2, r2, r1
  40450e:	fab2 f282 	clz	r2, r2
  404512:	f1c2 021f 	rsb	r2, r2, #31
  404516:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
  40451a:	4770      	bx	lr

0040451c <strncat>:
  40451c:	0783      	lsls	r3, r0, #30
  40451e:	b430      	push	{r4, r5}
  404520:	d125      	bne.n	40456e <strncat+0x52>
  404522:	6804      	ldr	r4, [r0, #0]
  404524:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
  404528:	ea23 0304 	bic.w	r3, r3, r4
  40452c:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  404530:	4603      	mov	r3, r0
  404532:	d108      	bne.n	404546 <strncat+0x2a>
  404534:	f853 5f04 	ldr.w	r5, [r3, #4]!
  404538:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
  40453c:	ea24 0405 	bic.w	r4, r4, r5
  404540:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  404544:	d0f6      	beq.n	404534 <strncat+0x18>
  404546:	781c      	ldrb	r4, [r3, #0]
  404548:	b11c      	cbz	r4, 404552 <strncat+0x36>
  40454a:	f813 4f01 	ldrb.w	r4, [r3, #1]!
  40454e:	2c00      	cmp	r4, #0
  404550:	d1fb      	bne.n	40454a <strncat+0x2e>
  404552:	189d      	adds	r5, r3, r2
  404554:	e005      	b.n	404562 <strncat+0x46>
  404556:	f811 4b01 	ldrb.w	r4, [r1], #1
  40455a:	f803 4b01 	strb.w	r4, [r3], #1
  40455e:	b124      	cbz	r4, 40456a <strncat+0x4e>
  404560:	b13a      	cbz	r2, 404572 <strncat+0x56>
  404562:	42ab      	cmp	r3, r5
  404564:	f102 32ff 	add.w	r2, r2, #4294967295
  404568:	d1f5      	bne.n	404556 <strncat+0x3a>
  40456a:	bc30      	pop	{r4, r5}
  40456c:	4770      	bx	lr
  40456e:	4603      	mov	r3, r0
  404570:	e7e9      	b.n	404546 <strncat+0x2a>
  404572:	701a      	strb	r2, [r3, #0]
  404574:	e7f5      	b.n	404562 <strncat+0x46>
  404576:	bf00      	nop

00404578 <strncmp>:
  404578:	2a00      	cmp	r2, #0
  40457a:	d03e      	beq.n	4045fa <strncmp+0x82>
  40457c:	ea40 0301 	orr.w	r3, r0, r1
  404580:	f013 0303 	ands.w	r3, r3, #3
  404584:	b4f0      	push	{r4, r5, r6, r7}
  404586:	d125      	bne.n	4045d4 <strncmp+0x5c>
  404588:	2a03      	cmp	r2, #3
  40458a:	d923      	bls.n	4045d4 <strncmp+0x5c>
  40458c:	6804      	ldr	r4, [r0, #0]
  40458e:	680d      	ldr	r5, [r1, #0]
  404590:	42ac      	cmp	r4, r5
  404592:	d11f      	bne.n	4045d4 <strncmp+0x5c>
  404594:	3a04      	subs	r2, #4
  404596:	d032      	beq.n	4045fe <strncmp+0x86>
  404598:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
  40459c:	ea25 0404 	bic.w	r4, r5, r4
  4045a0:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  4045a4:	d12e      	bne.n	404604 <strncmp+0x8c>
  4045a6:	1d07      	adds	r7, r0, #4
  4045a8:	1d0d      	adds	r5, r1, #4
  4045aa:	e00d      	b.n	4045c8 <strncmp+0x50>
  4045ac:	f857 3b04 	ldr.w	r3, [r7], #4
  4045b0:	680e      	ldr	r6, [r1, #0]
  4045b2:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
  4045b6:	42b3      	cmp	r3, r6
  4045b8:	ea24 0403 	bic.w	r4, r4, r3
  4045bc:	d10a      	bne.n	4045d4 <strncmp+0x5c>
  4045be:	3a04      	subs	r2, #4
  4045c0:	d01d      	beq.n	4045fe <strncmp+0x86>
  4045c2:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  4045c6:	d120      	bne.n	40460a <strncmp+0x92>
  4045c8:	2a03      	cmp	r2, #3
  4045ca:	4629      	mov	r1, r5
  4045cc:	4638      	mov	r0, r7
  4045ce:	f105 0504 	add.w	r5, r5, #4
  4045d2:	d8eb      	bhi.n	4045ac <strncmp+0x34>
  4045d4:	7803      	ldrb	r3, [r0, #0]
  4045d6:	780c      	ldrb	r4, [r1, #0]
  4045d8:	42a3      	cmp	r3, r4
  4045da:	f102 32ff 	add.w	r2, r2, #4294967295
  4045de:	d109      	bne.n	4045f4 <strncmp+0x7c>
  4045e0:	b16a      	cbz	r2, 4045fe <strncmp+0x86>
  4045e2:	b17b      	cbz	r3, 404604 <strncmp+0x8c>
  4045e4:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  4045e8:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  4045ec:	42a3      	cmp	r3, r4
  4045ee:	f102 32ff 	add.w	r2, r2, #4294967295
  4045f2:	d0f5      	beq.n	4045e0 <strncmp+0x68>
  4045f4:	1b18      	subs	r0, r3, r4
  4045f6:	bcf0      	pop	{r4, r5, r6, r7}
  4045f8:	4770      	bx	lr
  4045fa:	4610      	mov	r0, r2
  4045fc:	4770      	bx	lr
  4045fe:	4610      	mov	r0, r2
  404600:	bcf0      	pop	{r4, r5, r6, r7}
  404602:	4770      	bx	lr
  404604:	4618      	mov	r0, r3
  404606:	bcf0      	pop	{r4, r5, r6, r7}
  404608:	4770      	bx	lr
  40460a:	2000      	movs	r0, #0
  40460c:	e7f3      	b.n	4045f6 <strncmp+0x7e>
  40460e:	bf00      	nop

00404610 <strncpy>:
  404610:	ea40 0301 	orr.w	r3, r0, r1
  404614:	079b      	lsls	r3, r3, #30
  404616:	b470      	push	{r4, r5, r6}
  404618:	d12b      	bne.n	404672 <strncpy+0x62>
  40461a:	2a03      	cmp	r2, #3
  40461c:	d929      	bls.n	404672 <strncpy+0x62>
  40461e:	460c      	mov	r4, r1
  404620:	4603      	mov	r3, r0
  404622:	4621      	mov	r1, r4
  404624:	f854 6b04 	ldr.w	r6, [r4], #4
  404628:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
  40462c:	ea25 0506 	bic.w	r5, r5, r6
  404630:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
  404634:	d105      	bne.n	404642 <strncpy+0x32>
  404636:	3a04      	subs	r2, #4
  404638:	2a03      	cmp	r2, #3
  40463a:	f843 6b04 	str.w	r6, [r3], #4
  40463e:	4621      	mov	r1, r4
  404640:	d8ef      	bhi.n	404622 <strncpy+0x12>
  404642:	b1a2      	cbz	r2, 40466e <strncpy+0x5e>
  404644:	780c      	ldrb	r4, [r1, #0]
  404646:	701c      	strb	r4, [r3, #0]
  404648:	3a01      	subs	r2, #1
  40464a:	3301      	adds	r3, #1
  40464c:	3101      	adds	r1, #1
  40464e:	b13c      	cbz	r4, 404660 <strncpy+0x50>
  404650:	b16a      	cbz	r2, 40466e <strncpy+0x5e>
  404652:	f811 4b01 	ldrb.w	r4, [r1], #1
  404656:	f803 4b01 	strb.w	r4, [r3], #1
  40465a:	3a01      	subs	r2, #1
  40465c:	2c00      	cmp	r4, #0
  40465e:	d1f7      	bne.n	404650 <strncpy+0x40>
  404660:	b12a      	cbz	r2, 40466e <strncpy+0x5e>
  404662:	441a      	add	r2, r3
  404664:	2100      	movs	r1, #0
  404666:	f803 1b01 	strb.w	r1, [r3], #1
  40466a:	4293      	cmp	r3, r2
  40466c:	d1fb      	bne.n	404666 <strncpy+0x56>
  40466e:	bc70      	pop	{r4, r5, r6}
  404670:	4770      	bx	lr
  404672:	4603      	mov	r3, r0
  404674:	e7e5      	b.n	404642 <strncpy+0x32>
  404676:	bf00      	nop

00404678 <_strtol_r>:
  404678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40467c:	4c44      	ldr	r4, [pc, #272]	; (404790 <_strtol_r+0x118>)
  40467e:	4683      	mov	fp, r0
  404680:	460e      	mov	r6, r1
  404682:	f8d4 e000 	ldr.w	lr, [r4]
  404686:	e000      	b.n	40468a <_strtol_r+0x12>
  404688:	4626      	mov	r6, r4
  40468a:	4634      	mov	r4, r6
  40468c:	f814 5b01 	ldrb.w	r5, [r4], #1
  404690:	eb0e 0005 	add.w	r0, lr, r5
  404694:	7840      	ldrb	r0, [r0, #1]
  404696:	f000 0008 	and.w	r0, r0, #8
  40469a:	f000 08ff 	and.w	r8, r0, #255	; 0xff
  40469e:	2800      	cmp	r0, #0
  4046a0:	d1f2      	bne.n	404688 <_strtol_r+0x10>
  4046a2:	2d2d      	cmp	r5, #45	; 0x2d
  4046a4:	d04b      	beq.n	40473e <_strtol_r+0xc6>
  4046a6:	2d2b      	cmp	r5, #43	; 0x2b
  4046a8:	bf04      	itt	eq
  4046aa:	7875      	ldrbeq	r5, [r6, #1]
  4046ac:	1cb4      	addeq	r4, r6, #2
  4046ae:	b11b      	cbz	r3, 4046b8 <_strtol_r+0x40>
  4046b0:	2b10      	cmp	r3, #16
  4046b2:	d060      	beq.n	404776 <_strtol_r+0xfe>
  4046b4:	469a      	mov	sl, r3
  4046b6:	e003      	b.n	4046c0 <_strtol_r+0x48>
  4046b8:	2d30      	cmp	r5, #48	; 0x30
  4046ba:	d054      	beq.n	404766 <_strtol_r+0xee>
  4046bc:	230a      	movs	r3, #10
  4046be:	469a      	mov	sl, r3
  4046c0:	f1b8 0f00 	cmp.w	r8, #0
  4046c4:	bf14      	ite	ne
  4046c6:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  4046ca:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  4046ce:	2700      	movs	r7, #0
  4046d0:	fbb0 f9fa 	udiv	r9, r0, sl
  4046d4:	46bc      	mov	ip, r7
  4046d6:	fb0a 0019 	mls	r0, sl, r9, r0
  4046da:	e00c      	b.n	4046f6 <_strtol_r+0x7e>
  4046dc:	3d30      	subs	r5, #48	; 0x30
  4046de:	42ab      	cmp	r3, r5
  4046e0:	dd19      	ble.n	404716 <_strtol_r+0x9e>
  4046e2:	1c7e      	adds	r6, r7, #1
  4046e4:	d005      	beq.n	4046f2 <_strtol_r+0x7a>
  4046e6:	45cc      	cmp	ip, r9
  4046e8:	d824      	bhi.n	404734 <_strtol_r+0xbc>
  4046ea:	d021      	beq.n	404730 <_strtol_r+0xb8>
  4046ec:	fb0a 5c0c 	mla	ip, sl, ip, r5
  4046f0:	2701      	movs	r7, #1
  4046f2:	f814 5b01 	ldrb.w	r5, [r4], #1
  4046f6:	eb0e 0605 	add.w	r6, lr, r5
  4046fa:	7876      	ldrb	r6, [r6, #1]
  4046fc:	f016 0f04 	tst.w	r6, #4
  404700:	d1ec      	bne.n	4046dc <_strtol_r+0x64>
  404702:	f016 0603 	ands.w	r6, r6, #3
  404706:	d006      	beq.n	404716 <_strtol_r+0x9e>
  404708:	2e01      	cmp	r6, #1
  40470a:	bf0c      	ite	eq
  40470c:	2637      	moveq	r6, #55	; 0x37
  40470e:	2657      	movne	r6, #87	; 0x57
  404710:	1bad      	subs	r5, r5, r6
  404712:	42ab      	cmp	r3, r5
  404714:	dce5      	bgt.n	4046e2 <_strtol_r+0x6a>
  404716:	1c7b      	adds	r3, r7, #1
  404718:	d016      	beq.n	404748 <_strtol_r+0xd0>
  40471a:	f1c8 0000 	rsb	r0, r8, #0
  40471e:	ea8c 0000 	eor.w	r0, ip, r0
  404722:	4440      	add	r0, r8
  404724:	b14a      	cbz	r2, 40473a <_strtol_r+0xc2>
  404726:	b107      	cbz	r7, 40472a <_strtol_r+0xb2>
  404728:	1e61      	subs	r1, r4, #1
  40472a:	6011      	str	r1, [r2, #0]
  40472c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404730:	4285      	cmp	r5, r0
  404732:	dddb      	ble.n	4046ec <_strtol_r+0x74>
  404734:	f04f 37ff 	mov.w	r7, #4294967295
  404738:	e7db      	b.n	4046f2 <_strtol_r+0x7a>
  40473a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40473e:	1cb4      	adds	r4, r6, #2
  404740:	7875      	ldrb	r5, [r6, #1]
  404742:	f04f 0801 	mov.w	r8, #1
  404746:	e7b2      	b.n	4046ae <_strtol_r+0x36>
  404748:	f1b8 0f00 	cmp.w	r8, #0
  40474c:	f04f 0322 	mov.w	r3, #34	; 0x22
  404750:	bf14      	ite	ne
  404752:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  404756:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  40475a:	f8cb 3000 	str.w	r3, [fp]
  40475e:	2a00      	cmp	r2, #0
  404760:	d1e2      	bne.n	404728 <_strtol_r+0xb0>
  404762:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404766:	7823      	ldrb	r3, [r4, #0]
  404768:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  40476c:	2b58      	cmp	r3, #88	; 0x58
  40476e:	d009      	beq.n	404784 <_strtol_r+0x10c>
  404770:	2308      	movs	r3, #8
  404772:	469a      	mov	sl, r3
  404774:	e7a4      	b.n	4046c0 <_strtol_r+0x48>
  404776:	2d30      	cmp	r5, #48	; 0x30
  404778:	d19c      	bne.n	4046b4 <_strtol_r+0x3c>
  40477a:	7820      	ldrb	r0, [r4, #0]
  40477c:	f000 00df 	and.w	r0, r0, #223	; 0xdf
  404780:	2858      	cmp	r0, #88	; 0x58
  404782:	d197      	bne.n	4046b4 <_strtol_r+0x3c>
  404784:	f04f 0a10 	mov.w	sl, #16
  404788:	7865      	ldrb	r5, [r4, #1]
  40478a:	4653      	mov	r3, sl
  40478c:	3402      	adds	r4, #2
  40478e:	e797      	b.n	4046c0 <_strtol_r+0x48>
  404790:	2000044c 	.word	0x2000044c

00404794 <strtol>:
  404794:	b430      	push	{r4, r5}
  404796:	4c04      	ldr	r4, [pc, #16]	; (4047a8 <strtol+0x14>)
  404798:	460d      	mov	r5, r1
  40479a:	4613      	mov	r3, r2
  40479c:	4601      	mov	r1, r0
  40479e:	462a      	mov	r2, r5
  4047a0:	6820      	ldr	r0, [r4, #0]
  4047a2:	bc30      	pop	{r4, r5}
  4047a4:	f7ff bf68 	b.w	404678 <_strtol_r>
  4047a8:	20000448 	.word	0x20000448

004047ac <_svfprintf_r>:
  4047ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4047b0:	b0c1      	sub	sp, #260	; 0x104
  4047b2:	4689      	mov	r9, r1
  4047b4:	920a      	str	r2, [sp, #40]	; 0x28
  4047b6:	930e      	str	r3, [sp, #56]	; 0x38
  4047b8:	9008      	str	r0, [sp, #32]
  4047ba:	f002 fce1 	bl	407180 <_localeconv_r>
  4047be:	6803      	ldr	r3, [r0, #0]
  4047c0:	9317      	str	r3, [sp, #92]	; 0x5c
  4047c2:	4618      	mov	r0, r3
  4047c4:	f7ff fe7c 	bl	4044c0 <strlen>
  4047c8:	f8b9 300c 	ldrh.w	r3, [r9, #12]
  4047cc:	9018      	str	r0, [sp, #96]	; 0x60
  4047ce:	061a      	lsls	r2, r3, #24
  4047d0:	d504      	bpl.n	4047dc <_svfprintf_r+0x30>
  4047d2:	f8d9 3010 	ldr.w	r3, [r9, #16]
  4047d6:	2b00      	cmp	r3, #0
  4047d8:	f001 808c 	beq.w	4058f4 <_svfprintf_r+0x1148>
  4047dc:	2300      	movs	r3, #0
  4047de:	af30      	add	r7, sp, #192	; 0xc0
  4047e0:	9313      	str	r3, [sp, #76]	; 0x4c
  4047e2:	9325      	str	r3, [sp, #148]	; 0x94
  4047e4:	9324      	str	r3, [sp, #144]	; 0x90
  4047e6:	9316      	str	r3, [sp, #88]	; 0x58
  4047e8:	9319      	str	r3, [sp, #100]	; 0x64
  4047ea:	930b      	str	r3, [sp, #44]	; 0x2c
  4047ec:	9723      	str	r7, [sp, #140]	; 0x8c
  4047ee:	9314      	str	r3, [sp, #80]	; 0x50
  4047f0:	9315      	str	r3, [sp, #84]	; 0x54
  4047f2:	463c      	mov	r4, r7
  4047f4:	464e      	mov	r6, r9
  4047f6:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  4047f8:	782b      	ldrb	r3, [r5, #0]
  4047fa:	2b00      	cmp	r3, #0
  4047fc:	f000 80a9 	beq.w	404952 <_svfprintf_r+0x1a6>
  404800:	2b25      	cmp	r3, #37	; 0x25
  404802:	d102      	bne.n	40480a <_svfprintf_r+0x5e>
  404804:	e0a5      	b.n	404952 <_svfprintf_r+0x1a6>
  404806:	2b25      	cmp	r3, #37	; 0x25
  404808:	d003      	beq.n	404812 <_svfprintf_r+0x66>
  40480a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  40480e:	2b00      	cmp	r3, #0
  404810:	d1f9      	bne.n	404806 <_svfprintf_r+0x5a>
  404812:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  404814:	1aeb      	subs	r3, r5, r3
  404816:	b173      	cbz	r3, 404836 <_svfprintf_r+0x8a>
  404818:	9a24      	ldr	r2, [sp, #144]	; 0x90
  40481a:	9925      	ldr	r1, [sp, #148]	; 0x94
  40481c:	980a      	ldr	r0, [sp, #40]	; 0x28
  40481e:	6020      	str	r0, [r4, #0]
  404820:	3201      	adds	r2, #1
  404822:	4419      	add	r1, r3
  404824:	2a07      	cmp	r2, #7
  404826:	6063      	str	r3, [r4, #4]
  404828:	9125      	str	r1, [sp, #148]	; 0x94
  40482a:	9224      	str	r2, [sp, #144]	; 0x90
  40482c:	dc72      	bgt.n	404914 <_svfprintf_r+0x168>
  40482e:	3408      	adds	r4, #8
  404830:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  404832:	441a      	add	r2, r3
  404834:	920b      	str	r2, [sp, #44]	; 0x2c
  404836:	782b      	ldrb	r3, [r5, #0]
  404838:	2b00      	cmp	r3, #0
  40483a:	f000 87b5 	beq.w	4057a8 <_svfprintf_r+0xffc>
  40483e:	2300      	movs	r3, #0
  404840:	1c69      	adds	r1, r5, #1
  404842:	786d      	ldrb	r5, [r5, #1]
  404844:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  404848:	461a      	mov	r2, r3
  40484a:	930c      	str	r3, [sp, #48]	; 0x30
  40484c:	9307      	str	r3, [sp, #28]
  40484e:	f04f 3aff 	mov.w	sl, #4294967295
  404852:	1c4b      	adds	r3, r1, #1
  404854:	f1a5 0120 	sub.w	r1, r5, #32
  404858:	2958      	cmp	r1, #88	; 0x58
  40485a:	f200 83d9 	bhi.w	405010 <_svfprintf_r+0x864>
  40485e:	e8df f011 	tbh	[pc, r1, lsl #1]
  404862:	0270      	.short	0x0270
  404864:	03d703d7 	.word	0x03d703d7
  404868:	03d70374 	.word	0x03d70374
  40486c:	03d703d7 	.word	0x03d703d7
  404870:	03d703d7 	.word	0x03d703d7
  404874:	02f003d7 	.word	0x02f003d7
  404878:	03d7020d 	.word	0x03d7020d
  40487c:	021101f4 	.word	0x021101f4
  404880:	037b03d7 	.word	0x037b03d7
  404884:	02ba02ba 	.word	0x02ba02ba
  404888:	02ba02ba 	.word	0x02ba02ba
  40488c:	02ba02ba 	.word	0x02ba02ba
  404890:	02ba02ba 	.word	0x02ba02ba
  404894:	03d702ba 	.word	0x03d702ba
  404898:	03d703d7 	.word	0x03d703d7
  40489c:	03d703d7 	.word	0x03d703d7
  4048a0:	03d703d7 	.word	0x03d703d7
  4048a4:	03d703d7 	.word	0x03d703d7
  4048a8:	02c903d7 	.word	0x02c903d7
  4048ac:	03d7038b 	.word	0x03d7038b
  4048b0:	03d7038b 	.word	0x03d7038b
  4048b4:	03d703d7 	.word	0x03d703d7
  4048b8:	036d03d7 	.word	0x036d03d7
  4048bc:	03d703d7 	.word	0x03d703d7
  4048c0:	03d70305 	.word	0x03d70305
  4048c4:	03d703d7 	.word	0x03d703d7
  4048c8:	03d703d7 	.word	0x03d703d7
  4048cc:	03d70323 	.word	0x03d70323
  4048d0:	033d03d7 	.word	0x033d03d7
  4048d4:	03d703d7 	.word	0x03d703d7
  4048d8:	03d703d7 	.word	0x03d703d7
  4048dc:	03d703d7 	.word	0x03d703d7
  4048e0:	03d703d7 	.word	0x03d703d7
  4048e4:	03d703d7 	.word	0x03d703d7
  4048e8:	022c0358 	.word	0x022c0358
  4048ec:	038b038b 	.word	0x038b038b
  4048f0:	02fe038b 	.word	0x02fe038b
  4048f4:	03d7022c 	.word	0x03d7022c
  4048f8:	02e603d7 	.word	0x02e603d7
  4048fc:	027e03d7 	.word	0x027e03d7
  404900:	03c001fb 	.word	0x03c001fb
  404904:	03d70277 	.word	0x03d70277
  404908:	03d70292 	.word	0x03d70292
  40490c:	03d7007a 	.word	0x03d7007a
  404910:	024a03d7 	.word	0x024a03d7
  404914:	9808      	ldr	r0, [sp, #32]
  404916:	9307      	str	r3, [sp, #28]
  404918:	4631      	mov	r1, r6
  40491a:	aa23      	add	r2, sp, #140	; 0x8c
  40491c:	f003 fcea 	bl	4082f4 <__ssprint_r>
  404920:	b950      	cbnz	r0, 404938 <_svfprintf_r+0x18c>
  404922:	463c      	mov	r4, r7
  404924:	9b07      	ldr	r3, [sp, #28]
  404926:	e783      	b.n	404830 <_svfprintf_r+0x84>
  404928:	9808      	ldr	r0, [sp, #32]
  40492a:	4631      	mov	r1, r6
  40492c:	aa23      	add	r2, sp, #140	; 0x8c
  40492e:	f003 fce1 	bl	4082f4 <__ssprint_r>
  404932:	2800      	cmp	r0, #0
  404934:	f000 8185 	beq.w	404c42 <_svfprintf_r+0x496>
  404938:	46b1      	mov	r9, r6
  40493a:	f8b9 300c 	ldrh.w	r3, [r9, #12]
  40493e:	f013 0f40 	tst.w	r3, #64	; 0x40
  404942:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  404944:	bf18      	it	ne
  404946:	f04f 33ff 	movne.w	r3, #4294967295
  40494a:	4618      	mov	r0, r3
  40494c:	b041      	add	sp, #260	; 0x104
  40494e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404952:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  404954:	e76f      	b.n	404836 <_svfprintf_r+0x8a>
  404956:	930a      	str	r3, [sp, #40]	; 0x28
  404958:	9b07      	ldr	r3, [sp, #28]
  40495a:	0698      	lsls	r0, r3, #26
  40495c:	f140 82ad 	bpl.w	404eba <_svfprintf_r+0x70e>
  404960:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  404962:	f103 0907 	add.w	r9, r3, #7
  404966:	f029 0307 	bic.w	r3, r9, #7
  40496a:	f103 0208 	add.w	r2, r3, #8
  40496e:	e9d3 8900 	ldrd	r8, r9, [r3]
  404972:	920e      	str	r2, [sp, #56]	; 0x38
  404974:	2301      	movs	r3, #1
  404976:	f04f 0c00 	mov.w	ip, #0
  40497a:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
  40497e:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
  404982:	f1ba 0f00 	cmp.w	sl, #0
  404986:	db03      	blt.n	404990 <_svfprintf_r+0x1e4>
  404988:	9a07      	ldr	r2, [sp, #28]
  40498a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  40498e:	9207      	str	r2, [sp, #28]
  404990:	ea58 0209 	orrs.w	r2, r8, r9
  404994:	f040 834c 	bne.w	405030 <_svfprintf_r+0x884>
  404998:	f1ba 0f00 	cmp.w	sl, #0
  40499c:	f000 8451 	beq.w	405242 <_svfprintf_r+0xa96>
  4049a0:	2b01      	cmp	r3, #1
  4049a2:	f000 834f 	beq.w	405044 <_svfprintf_r+0x898>
  4049a6:	2b02      	cmp	r3, #2
  4049a8:	f000 8490 	beq.w	4052cc <_svfprintf_r+0xb20>
  4049ac:	4639      	mov	r1, r7
  4049ae:	ea4f 02d8 	mov.w	r2, r8, lsr #3
  4049b2:	ea42 7249 	orr.w	r2, r2, r9, lsl #29
  4049b6:	ea4f 00d9 	mov.w	r0, r9, lsr #3
  4049ba:	f008 0307 	and.w	r3, r8, #7
  4049be:	4681      	mov	r9, r0
  4049c0:	4690      	mov	r8, r2
  4049c2:	3330      	adds	r3, #48	; 0x30
  4049c4:	ea58 0209 	orrs.w	r2, r8, r9
  4049c8:	f801 3d01 	strb.w	r3, [r1, #-1]!
  4049cc:	d1ef      	bne.n	4049ae <_svfprintf_r+0x202>
  4049ce:	9a07      	ldr	r2, [sp, #28]
  4049d0:	9110      	str	r1, [sp, #64]	; 0x40
  4049d2:	07d2      	lsls	r2, r2, #31
  4049d4:	f100 8544 	bmi.w	405460 <_svfprintf_r+0xcb4>
  4049d8:	1a7b      	subs	r3, r7, r1
  4049da:	930d      	str	r3, [sp, #52]	; 0x34
  4049dc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  4049de:	4592      	cmp	sl, r2
  4049e0:	4653      	mov	r3, sl
  4049e2:	bfb8      	it	lt
  4049e4:	4613      	movlt	r3, r2
  4049e6:	9309      	str	r3, [sp, #36]	; 0x24
  4049e8:	2300      	movs	r3, #0
  4049ea:	9312      	str	r3, [sp, #72]	; 0x48
  4049ec:	f1bc 0f00 	cmp.w	ip, #0
  4049f0:	d002      	beq.n	4049f8 <_svfprintf_r+0x24c>
  4049f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4049f4:	3301      	adds	r3, #1
  4049f6:	9309      	str	r3, [sp, #36]	; 0x24
  4049f8:	9b07      	ldr	r3, [sp, #28]
  4049fa:	f013 0302 	ands.w	r3, r3, #2
  4049fe:	930f      	str	r3, [sp, #60]	; 0x3c
  404a00:	d002      	beq.n	404a08 <_svfprintf_r+0x25c>
  404a02:	9b09      	ldr	r3, [sp, #36]	; 0x24
  404a04:	3302      	adds	r3, #2
  404a06:	9309      	str	r3, [sp, #36]	; 0x24
  404a08:	9b07      	ldr	r3, [sp, #28]
  404a0a:	f013 0984 	ands.w	r9, r3, #132	; 0x84
  404a0e:	f040 830c 	bne.w	40502a <_svfprintf_r+0x87e>
  404a12:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  404a14:	9a09      	ldr	r2, [sp, #36]	; 0x24
  404a16:	ebc2 0803 	rsb	r8, r2, r3
  404a1a:	f1b8 0f00 	cmp.w	r8, #0
  404a1e:	f340 8304 	ble.w	40502a <_svfprintf_r+0x87e>
  404a22:	f1b8 0f10 	cmp.w	r8, #16
  404a26:	9925      	ldr	r1, [sp, #148]	; 0x94
  404a28:	9a24      	ldr	r2, [sp, #144]	; 0x90
  404a2a:	f8df a544 	ldr.w	sl, [pc, #1348]	; 404f70 <_svfprintf_r+0x7c4>
  404a2e:	dd29      	ble.n	404a84 <_svfprintf_r+0x2d8>
  404a30:	4653      	mov	r3, sl
  404a32:	f04f 0b10 	mov.w	fp, #16
  404a36:	46c2      	mov	sl, r8
  404a38:	46a8      	mov	r8, r5
  404a3a:	461d      	mov	r5, r3
  404a3c:	e006      	b.n	404a4c <_svfprintf_r+0x2a0>
  404a3e:	f1aa 0a10 	sub.w	sl, sl, #16
  404a42:	f1ba 0f10 	cmp.w	sl, #16
  404a46:	f104 0408 	add.w	r4, r4, #8
  404a4a:	dd17      	ble.n	404a7c <_svfprintf_r+0x2d0>
  404a4c:	3201      	adds	r2, #1
  404a4e:	3110      	adds	r1, #16
  404a50:	2a07      	cmp	r2, #7
  404a52:	9125      	str	r1, [sp, #148]	; 0x94
  404a54:	9224      	str	r2, [sp, #144]	; 0x90
  404a56:	e884 0820 	stmia.w	r4, {r5, fp}
  404a5a:	ddf0      	ble.n	404a3e <_svfprintf_r+0x292>
  404a5c:	9808      	ldr	r0, [sp, #32]
  404a5e:	4631      	mov	r1, r6
  404a60:	aa23      	add	r2, sp, #140	; 0x8c
  404a62:	f003 fc47 	bl	4082f4 <__ssprint_r>
  404a66:	2800      	cmp	r0, #0
  404a68:	f47f af66 	bne.w	404938 <_svfprintf_r+0x18c>
  404a6c:	f1aa 0a10 	sub.w	sl, sl, #16
  404a70:	f1ba 0f10 	cmp.w	sl, #16
  404a74:	9925      	ldr	r1, [sp, #148]	; 0x94
  404a76:	9a24      	ldr	r2, [sp, #144]	; 0x90
  404a78:	463c      	mov	r4, r7
  404a7a:	dce7      	bgt.n	404a4c <_svfprintf_r+0x2a0>
  404a7c:	462b      	mov	r3, r5
  404a7e:	4645      	mov	r5, r8
  404a80:	46d0      	mov	r8, sl
  404a82:	469a      	mov	sl, r3
  404a84:	3201      	adds	r2, #1
  404a86:	eb08 0b01 	add.w	fp, r8, r1
  404a8a:	2a07      	cmp	r2, #7
  404a8c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  404a90:	9224      	str	r2, [sp, #144]	; 0x90
  404a92:	f8c4 a000 	str.w	sl, [r4]
  404a96:	f8c4 8004 	str.w	r8, [r4, #4]
  404a9a:	f300 847b 	bgt.w	405394 <_svfprintf_r+0xbe8>
  404a9e:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  404aa2:	3408      	adds	r4, #8
  404aa4:	f1bc 0f00 	cmp.w	ip, #0
  404aa8:	d00f      	beq.n	404aca <_svfprintf_r+0x31e>
  404aaa:	9b24      	ldr	r3, [sp, #144]	; 0x90
  404aac:	3301      	adds	r3, #1
  404aae:	f10b 0b01 	add.w	fp, fp, #1
  404ab2:	f10d 016f 	add.w	r1, sp, #111	; 0x6f
  404ab6:	2201      	movs	r2, #1
  404ab8:	2b07      	cmp	r3, #7
  404aba:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  404abe:	9324      	str	r3, [sp, #144]	; 0x90
  404ac0:	e884 0006 	stmia.w	r4, {r1, r2}
  404ac4:	f300 83da 	bgt.w	40527c <_svfprintf_r+0xad0>
  404ac8:	3408      	adds	r4, #8
  404aca:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  404acc:	b173      	cbz	r3, 404aec <_svfprintf_r+0x340>
  404ace:	9b24      	ldr	r3, [sp, #144]	; 0x90
  404ad0:	3301      	adds	r3, #1
  404ad2:	f10b 0b02 	add.w	fp, fp, #2
  404ad6:	a91c      	add	r1, sp, #112	; 0x70
  404ad8:	2202      	movs	r2, #2
  404ada:	2b07      	cmp	r3, #7
  404adc:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  404ae0:	9324      	str	r3, [sp, #144]	; 0x90
  404ae2:	e884 0006 	stmia.w	r4, {r1, r2}
  404ae6:	f300 83d5 	bgt.w	405294 <_svfprintf_r+0xae8>
  404aea:	3408      	adds	r4, #8
  404aec:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
  404af0:	f000 8311 	beq.w	405116 <_svfprintf_r+0x96a>
  404af4:	9b11      	ldr	r3, [sp, #68]	; 0x44
  404af6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  404af8:	ebc2 0a03 	rsb	sl, r2, r3
  404afc:	f1ba 0f00 	cmp.w	sl, #0
  404b00:	dd3c      	ble.n	404b7c <_svfprintf_r+0x3d0>
  404b02:	f1ba 0f10 	cmp.w	sl, #16
  404b06:	9a24      	ldr	r2, [sp, #144]	; 0x90
  404b08:	f8df 9468 	ldr.w	r9, [pc, #1128]	; 404f74 <_svfprintf_r+0x7c8>
  404b0c:	dd2b      	ble.n	404b66 <_svfprintf_r+0x3ba>
  404b0e:	4649      	mov	r1, r9
  404b10:	465b      	mov	r3, fp
  404b12:	46a9      	mov	r9, r5
  404b14:	f04f 0810 	mov.w	r8, #16
  404b18:	f8dd b020 	ldr.w	fp, [sp, #32]
  404b1c:	460d      	mov	r5, r1
  404b1e:	e006      	b.n	404b2e <_svfprintf_r+0x382>
  404b20:	f1aa 0a10 	sub.w	sl, sl, #16
  404b24:	f1ba 0f10 	cmp.w	sl, #16
  404b28:	f104 0408 	add.w	r4, r4, #8
  404b2c:	dd17      	ble.n	404b5e <_svfprintf_r+0x3b2>
  404b2e:	3201      	adds	r2, #1
  404b30:	3310      	adds	r3, #16
  404b32:	2a07      	cmp	r2, #7
  404b34:	9325      	str	r3, [sp, #148]	; 0x94
  404b36:	9224      	str	r2, [sp, #144]	; 0x90
  404b38:	e884 0120 	stmia.w	r4, {r5, r8}
  404b3c:	ddf0      	ble.n	404b20 <_svfprintf_r+0x374>
  404b3e:	4658      	mov	r0, fp
  404b40:	4631      	mov	r1, r6
  404b42:	aa23      	add	r2, sp, #140	; 0x8c
  404b44:	f003 fbd6 	bl	4082f4 <__ssprint_r>
  404b48:	2800      	cmp	r0, #0
  404b4a:	f47f aef5 	bne.w	404938 <_svfprintf_r+0x18c>
  404b4e:	f1aa 0a10 	sub.w	sl, sl, #16
  404b52:	f1ba 0f10 	cmp.w	sl, #16
  404b56:	9b25      	ldr	r3, [sp, #148]	; 0x94
  404b58:	9a24      	ldr	r2, [sp, #144]	; 0x90
  404b5a:	463c      	mov	r4, r7
  404b5c:	dce7      	bgt.n	404b2e <_svfprintf_r+0x382>
  404b5e:	469b      	mov	fp, r3
  404b60:	462b      	mov	r3, r5
  404b62:	464d      	mov	r5, r9
  404b64:	4699      	mov	r9, r3
  404b66:	3201      	adds	r2, #1
  404b68:	44d3      	add	fp, sl
  404b6a:	2a07      	cmp	r2, #7
  404b6c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  404b70:	9224      	str	r2, [sp, #144]	; 0x90
  404b72:	e884 0600 	stmia.w	r4, {r9, sl}
  404b76:	f300 8375 	bgt.w	405264 <_svfprintf_r+0xab8>
  404b7a:	3408      	adds	r4, #8
  404b7c:	9b07      	ldr	r3, [sp, #28]
  404b7e:	05d9      	lsls	r1, r3, #23
  404b80:	f100 826c 	bmi.w	40505c <_svfprintf_r+0x8b0>
  404b84:	9b24      	ldr	r3, [sp, #144]	; 0x90
  404b86:	990d      	ldr	r1, [sp, #52]	; 0x34
  404b88:	9a10      	ldr	r2, [sp, #64]	; 0x40
  404b8a:	6022      	str	r2, [r4, #0]
  404b8c:	3301      	adds	r3, #1
  404b8e:	448b      	add	fp, r1
  404b90:	2b07      	cmp	r3, #7
  404b92:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  404b96:	6061      	str	r1, [r4, #4]
  404b98:	9324      	str	r3, [sp, #144]	; 0x90
  404b9a:	f300 8346 	bgt.w	40522a <_svfprintf_r+0xa7e>
  404b9e:	3408      	adds	r4, #8
  404ba0:	9b07      	ldr	r3, [sp, #28]
  404ba2:	075a      	lsls	r2, r3, #29
  404ba4:	d541      	bpl.n	404c2a <_svfprintf_r+0x47e>
  404ba6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  404ba8:	9a09      	ldr	r2, [sp, #36]	; 0x24
  404baa:	1a9d      	subs	r5, r3, r2
  404bac:	2d00      	cmp	r5, #0
  404bae:	dd3c      	ble.n	404c2a <_svfprintf_r+0x47e>
  404bb0:	2d10      	cmp	r5, #16
  404bb2:	9b24      	ldr	r3, [sp, #144]	; 0x90
  404bb4:	f8df a3b8 	ldr.w	sl, [pc, #952]	; 404f70 <_svfprintf_r+0x7c4>
  404bb8:	dd23      	ble.n	404c02 <_svfprintf_r+0x456>
  404bba:	f04f 0810 	mov.w	r8, #16
  404bbe:	465a      	mov	r2, fp
  404bc0:	f8dd 9020 	ldr.w	r9, [sp, #32]
  404bc4:	e004      	b.n	404bd0 <_svfprintf_r+0x424>
  404bc6:	3d10      	subs	r5, #16
  404bc8:	2d10      	cmp	r5, #16
  404bca:	f104 0408 	add.w	r4, r4, #8
  404bce:	dd17      	ble.n	404c00 <_svfprintf_r+0x454>
  404bd0:	3301      	adds	r3, #1
  404bd2:	3210      	adds	r2, #16
  404bd4:	2b07      	cmp	r3, #7
  404bd6:	9225      	str	r2, [sp, #148]	; 0x94
  404bd8:	9324      	str	r3, [sp, #144]	; 0x90
  404bda:	f8c4 a000 	str.w	sl, [r4]
  404bde:	f8c4 8004 	str.w	r8, [r4, #4]
  404be2:	ddf0      	ble.n	404bc6 <_svfprintf_r+0x41a>
  404be4:	4648      	mov	r0, r9
  404be6:	4631      	mov	r1, r6
  404be8:	aa23      	add	r2, sp, #140	; 0x8c
  404bea:	f003 fb83 	bl	4082f4 <__ssprint_r>
  404bee:	2800      	cmp	r0, #0
  404bf0:	f47f aea2 	bne.w	404938 <_svfprintf_r+0x18c>
  404bf4:	3d10      	subs	r5, #16
  404bf6:	2d10      	cmp	r5, #16
  404bf8:	9a25      	ldr	r2, [sp, #148]	; 0x94
  404bfa:	9b24      	ldr	r3, [sp, #144]	; 0x90
  404bfc:	463c      	mov	r4, r7
  404bfe:	dce7      	bgt.n	404bd0 <_svfprintf_r+0x424>
  404c00:	4693      	mov	fp, r2
  404c02:	3301      	adds	r3, #1
  404c04:	44ab      	add	fp, r5
  404c06:	2b07      	cmp	r3, #7
  404c08:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  404c0c:	9324      	str	r3, [sp, #144]	; 0x90
  404c0e:	f8c4 a000 	str.w	sl, [r4]
  404c12:	6065      	str	r5, [r4, #4]
  404c14:	dd09      	ble.n	404c2a <_svfprintf_r+0x47e>
  404c16:	9808      	ldr	r0, [sp, #32]
  404c18:	4631      	mov	r1, r6
  404c1a:	aa23      	add	r2, sp, #140	; 0x8c
  404c1c:	f003 fb6a 	bl	4082f4 <__ssprint_r>
  404c20:	2800      	cmp	r0, #0
  404c22:	f47f ae89 	bne.w	404938 <_svfprintf_r+0x18c>
  404c26:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  404c2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  404c2c:	9a09      	ldr	r2, [sp, #36]	; 0x24
  404c2e:	990c      	ldr	r1, [sp, #48]	; 0x30
  404c30:	428a      	cmp	r2, r1
  404c32:	bfac      	ite	ge
  404c34:	189b      	addge	r3, r3, r2
  404c36:	185b      	addlt	r3, r3, r1
  404c38:	930b      	str	r3, [sp, #44]	; 0x2c
  404c3a:	f1bb 0f00 	cmp.w	fp, #0
  404c3e:	f47f ae73 	bne.w	404928 <_svfprintf_r+0x17c>
  404c42:	2300      	movs	r3, #0
  404c44:	9324      	str	r3, [sp, #144]	; 0x90
  404c46:	463c      	mov	r4, r7
  404c48:	e5d5      	b.n	4047f6 <_svfprintf_r+0x4a>
  404c4a:	4619      	mov	r1, r3
  404c4c:	9807      	ldr	r0, [sp, #28]
  404c4e:	781d      	ldrb	r5, [r3, #0]
  404c50:	f040 0004 	orr.w	r0, r0, #4
  404c54:	9007      	str	r0, [sp, #28]
  404c56:	e5fc      	b.n	404852 <_svfprintf_r+0xa6>
  404c58:	930a      	str	r3, [sp, #40]	; 0x28
  404c5a:	9b07      	ldr	r3, [sp, #28]
  404c5c:	f013 0320 	ands.w	r3, r3, #32
  404c60:	f000 810e 	beq.w	404e80 <_svfprintf_r+0x6d4>
  404c64:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  404c66:	f103 0907 	add.w	r9, r3, #7
  404c6a:	f029 0307 	bic.w	r3, r9, #7
  404c6e:	f103 0208 	add.w	r2, r3, #8
  404c72:	e9d3 8900 	ldrd	r8, r9, [r3]
  404c76:	920e      	str	r2, [sp, #56]	; 0x38
  404c78:	2300      	movs	r3, #0
  404c7a:	e67c      	b.n	404976 <_svfprintf_r+0x1ca>
  404c7c:	781d      	ldrb	r5, [r3, #0]
  404c7e:	4619      	mov	r1, r3
  404c80:	222b      	movs	r2, #43	; 0x2b
  404c82:	e5e6      	b.n	404852 <_svfprintf_r+0xa6>
  404c84:	781d      	ldrb	r5, [r3, #0]
  404c86:	2d2a      	cmp	r5, #42	; 0x2a
  404c88:	f103 0101 	add.w	r1, r3, #1
  404c8c:	f000 87ad 	beq.w	405bea <_svfprintf_r+0x143e>
  404c90:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
  404c94:	2809      	cmp	r0, #9
  404c96:	460b      	mov	r3, r1
  404c98:	f04f 0a00 	mov.w	sl, #0
  404c9c:	f63f adda 	bhi.w	404854 <_svfprintf_r+0xa8>
  404ca0:	f813 5b01 	ldrb.w	r5, [r3], #1
  404ca4:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
  404ca8:	eb00 0a4a 	add.w	sl, r0, sl, lsl #1
  404cac:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
  404cb0:	2809      	cmp	r0, #9
  404cb2:	d9f5      	bls.n	404ca0 <_svfprintf_r+0x4f4>
  404cb4:	ea4a 7aea 	orr.w	sl, sl, sl, asr #31
  404cb8:	e5cc      	b.n	404854 <_svfprintf_r+0xa8>
  404cba:	930a      	str	r3, [sp, #40]	; 0x28
  404cbc:	9b07      	ldr	r3, [sp, #28]
  404cbe:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  404cc2:	069b      	lsls	r3, r3, #26
  404cc4:	f140 80a1 	bpl.w	404e0a <_svfprintf_r+0x65e>
  404cc8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  404cca:	f103 0907 	add.w	r9, r3, #7
  404cce:	f029 0907 	bic.w	r9, r9, #7
  404cd2:	e9d9 2300 	ldrd	r2, r3, [r9]
  404cd6:	f109 0108 	add.w	r1, r9, #8
  404cda:	910e      	str	r1, [sp, #56]	; 0x38
  404cdc:	4690      	mov	r8, r2
  404cde:	4699      	mov	r9, r3
  404ce0:	2a00      	cmp	r2, #0
  404ce2:	f173 0300 	sbcs.w	r3, r3, #0
  404ce6:	f2c0 840b 	blt.w	405500 <_svfprintf_r+0xd54>
  404cea:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  404cee:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
  404cf2:	2301      	movs	r3, #1
  404cf4:	e645      	b.n	404982 <_svfprintf_r+0x1d6>
  404cf6:	930a      	str	r3, [sp, #40]	; 0x28
  404cf8:	4b9b      	ldr	r3, [pc, #620]	; (404f68 <_svfprintf_r+0x7bc>)
  404cfa:	9316      	str	r3, [sp, #88]	; 0x58
  404cfc:	9b07      	ldr	r3, [sp, #28]
  404cfe:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  404d02:	069b      	lsls	r3, r3, #26
  404d04:	f140 80f3 	bpl.w	404eee <_svfprintf_r+0x742>
  404d08:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  404d0a:	f103 0907 	add.w	r9, r3, #7
  404d0e:	f029 0307 	bic.w	r3, r9, #7
  404d12:	e9d3 8900 	ldrd	r8, r9, [r3]
  404d16:	f103 0208 	add.w	r2, r3, #8
  404d1a:	920e      	str	r2, [sp, #56]	; 0x38
  404d1c:	9b07      	ldr	r3, [sp, #28]
  404d1e:	07d9      	lsls	r1, r3, #31
  404d20:	f140 80f5 	bpl.w	404f0e <_svfprintf_r+0x762>
  404d24:	ea58 0309 	orrs.w	r3, r8, r9
  404d28:	f000 80f1 	beq.w	404f0e <_svfprintf_r+0x762>
  404d2c:	9a07      	ldr	r2, [sp, #28]
  404d2e:	f88d 5071 	strb.w	r5, [sp, #113]	; 0x71
  404d32:	2330      	movs	r3, #48	; 0x30
  404d34:	f042 0202 	orr.w	r2, r2, #2
  404d38:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
  404d3c:	9207      	str	r2, [sp, #28]
  404d3e:	2302      	movs	r3, #2
  404d40:	e619      	b.n	404976 <_svfprintf_r+0x1ca>
  404d42:	781d      	ldrb	r5, [r3, #0]
  404d44:	4619      	mov	r1, r3
  404d46:	2a00      	cmp	r2, #0
  404d48:	f47f ad83 	bne.w	404852 <_svfprintf_r+0xa6>
  404d4c:	2220      	movs	r2, #32
  404d4e:	e580      	b.n	404852 <_svfprintf_r+0xa6>
  404d50:	9907      	ldr	r1, [sp, #28]
  404d52:	f041 0120 	orr.w	r1, r1, #32
  404d56:	9107      	str	r1, [sp, #28]
  404d58:	781d      	ldrb	r5, [r3, #0]
  404d5a:	4619      	mov	r1, r3
  404d5c:	e579      	b.n	404852 <_svfprintf_r+0xa6>
  404d5e:	930a      	str	r3, [sp, #40]	; 0x28
  404d60:	9b07      	ldr	r3, [sp, #28]
  404d62:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  404d66:	069a      	lsls	r2, r3, #26
  404d68:	f140 84a1 	bpl.w	4056ae <_svfprintf_r+0xf02>
  404d6c:	990b      	ldr	r1, [sp, #44]	; 0x2c
  404d6e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  404d70:	ea4f 79e1 	mov.w	r9, r1, asr #31
  404d74:	6813      	ldr	r3, [r2, #0]
  404d76:	4608      	mov	r0, r1
  404d78:	4688      	mov	r8, r1
  404d7a:	3204      	adds	r2, #4
  404d7c:	4649      	mov	r1, r9
  404d7e:	920e      	str	r2, [sp, #56]	; 0x38
  404d80:	e9c3 0100 	strd	r0, r1, [r3]
  404d84:	e537      	b.n	4047f6 <_svfprintf_r+0x4a>
  404d86:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  404d88:	930a      	str	r3, [sp, #40]	; 0x28
  404d8a:	6813      	ldr	r3, [r2, #0]
  404d8c:	9310      	str	r3, [sp, #64]	; 0x40
  404d8e:	f04f 0b00 	mov.w	fp, #0
  404d92:	f88d b06f 	strb.w	fp, [sp, #111]	; 0x6f
  404d96:	f102 0904 	add.w	r9, r2, #4
  404d9a:	2b00      	cmp	r3, #0
  404d9c:	f000 863b 	beq.w	405a16 <_svfprintf_r+0x126a>
  404da0:	f1ba 0f00 	cmp.w	sl, #0
  404da4:	9810      	ldr	r0, [sp, #64]	; 0x40
  404da6:	f2c0 85e9 	blt.w	40597c <_svfprintf_r+0x11d0>
  404daa:	4659      	mov	r1, fp
  404dac:	4652      	mov	r2, sl
  404dae:	f002 fc85 	bl	4076bc <memchr>
  404db2:	2800      	cmp	r0, #0
  404db4:	f000 866c 	beq.w	405a90 <_svfprintf_r+0x12e4>
  404db8:	9b10      	ldr	r3, [sp, #64]	; 0x40
  404dba:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
  404dbe:	1ac3      	subs	r3, r0, r3
  404dc0:	930d      	str	r3, [sp, #52]	; 0x34
  404dc2:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
  404dc6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  404dca:	9309      	str	r3, [sp, #36]	; 0x24
  404dcc:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
  404dd0:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  404dd4:	e60a      	b.n	4049ec <_svfprintf_r+0x240>
  404dd6:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
  404dda:	2100      	movs	r1, #0
  404ddc:	f813 5b01 	ldrb.w	r5, [r3], #1
  404de0:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  404de4:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  404de8:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
  404dec:	2809      	cmp	r0, #9
  404dee:	d9f5      	bls.n	404ddc <_svfprintf_r+0x630>
  404df0:	910c      	str	r1, [sp, #48]	; 0x30
  404df2:	e52f      	b.n	404854 <_svfprintf_r+0xa8>
  404df4:	930a      	str	r3, [sp, #40]	; 0x28
  404df6:	9b07      	ldr	r3, [sp, #28]
  404df8:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  404dfc:	f043 0310 	orr.w	r3, r3, #16
  404e00:	9307      	str	r3, [sp, #28]
  404e02:	9b07      	ldr	r3, [sp, #28]
  404e04:	069b      	lsls	r3, r3, #26
  404e06:	f53f af5f 	bmi.w	404cc8 <_svfprintf_r+0x51c>
  404e0a:	9b07      	ldr	r3, [sp, #28]
  404e0c:	06d8      	lsls	r0, r3, #27
  404e0e:	f100 8368 	bmi.w	4054e2 <_svfprintf_r+0xd36>
  404e12:	9b07      	ldr	r3, [sp, #28]
  404e14:	0659      	lsls	r1, r3, #25
  404e16:	f140 8364 	bpl.w	4054e2 <_svfprintf_r+0xd36>
  404e1a:	990e      	ldr	r1, [sp, #56]	; 0x38
  404e1c:	f9b1 8000 	ldrsh.w	r8, [r1]
  404e20:	3104      	adds	r1, #4
  404e22:	ea4f 79e8 	mov.w	r9, r8, asr #31
  404e26:	4642      	mov	r2, r8
  404e28:	464b      	mov	r3, r9
  404e2a:	910e      	str	r1, [sp, #56]	; 0x38
  404e2c:	e758      	b.n	404ce0 <_svfprintf_r+0x534>
  404e2e:	781d      	ldrb	r5, [r3, #0]
  404e30:	9907      	ldr	r1, [sp, #28]
  404e32:	2d6c      	cmp	r5, #108	; 0x6c
  404e34:	f000 84cb 	beq.w	4057ce <_svfprintf_r+0x1022>
  404e38:	f041 0110 	orr.w	r1, r1, #16
  404e3c:	9107      	str	r1, [sp, #28]
  404e3e:	4619      	mov	r1, r3
  404e40:	e507      	b.n	404852 <_svfprintf_r+0xa6>
  404e42:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  404e44:	6829      	ldr	r1, [r5, #0]
  404e46:	910c      	str	r1, [sp, #48]	; 0x30
  404e48:	4608      	mov	r0, r1
  404e4a:	2800      	cmp	r0, #0
  404e4c:	4629      	mov	r1, r5
  404e4e:	f101 0104 	add.w	r1, r1, #4
  404e52:	f2c0 84b5 	blt.w	4057c0 <_svfprintf_r+0x1014>
  404e56:	910e      	str	r1, [sp, #56]	; 0x38
  404e58:	781d      	ldrb	r5, [r3, #0]
  404e5a:	4619      	mov	r1, r3
  404e5c:	e4f9      	b.n	404852 <_svfprintf_r+0xa6>
  404e5e:	9907      	ldr	r1, [sp, #28]
  404e60:	f041 0140 	orr.w	r1, r1, #64	; 0x40
  404e64:	9107      	str	r1, [sp, #28]
  404e66:	781d      	ldrb	r5, [r3, #0]
  404e68:	4619      	mov	r1, r3
  404e6a:	e4f2      	b.n	404852 <_svfprintf_r+0xa6>
  404e6c:	930a      	str	r3, [sp, #40]	; 0x28
  404e6e:	9b07      	ldr	r3, [sp, #28]
  404e70:	f043 0310 	orr.w	r3, r3, #16
  404e74:	9307      	str	r3, [sp, #28]
  404e76:	9b07      	ldr	r3, [sp, #28]
  404e78:	f013 0320 	ands.w	r3, r3, #32
  404e7c:	f47f aef2 	bne.w	404c64 <_svfprintf_r+0x4b8>
  404e80:	9a07      	ldr	r2, [sp, #28]
  404e82:	f012 0210 	ands.w	r2, r2, #16
  404e86:	f040 8319 	bne.w	4054bc <_svfprintf_r+0xd10>
  404e8a:	9b07      	ldr	r3, [sp, #28]
  404e8c:	f013 0340 	ands.w	r3, r3, #64	; 0x40
  404e90:	f000 8314 	beq.w	4054bc <_svfprintf_r+0xd10>
  404e94:	990e      	ldr	r1, [sp, #56]	; 0x38
  404e96:	4613      	mov	r3, r2
  404e98:	460a      	mov	r2, r1
  404e9a:	3204      	adds	r2, #4
  404e9c:	f8b1 8000 	ldrh.w	r8, [r1]
  404ea0:	920e      	str	r2, [sp, #56]	; 0x38
  404ea2:	f04f 0900 	mov.w	r9, #0
  404ea6:	e566      	b.n	404976 <_svfprintf_r+0x1ca>
  404ea8:	930a      	str	r3, [sp, #40]	; 0x28
  404eaa:	9b07      	ldr	r3, [sp, #28]
  404eac:	f043 0310 	orr.w	r3, r3, #16
  404eb0:	9307      	str	r3, [sp, #28]
  404eb2:	9b07      	ldr	r3, [sp, #28]
  404eb4:	0698      	lsls	r0, r3, #26
  404eb6:	f53f ad53 	bmi.w	404960 <_svfprintf_r+0x1b4>
  404eba:	9b07      	ldr	r3, [sp, #28]
  404ebc:	06d9      	lsls	r1, r3, #27
  404ebe:	f100 8306 	bmi.w	4054ce <_svfprintf_r+0xd22>
  404ec2:	9b07      	ldr	r3, [sp, #28]
  404ec4:	065a      	lsls	r2, r3, #25
  404ec6:	f140 8302 	bpl.w	4054ce <_svfprintf_r+0xd22>
  404eca:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  404ecc:	f8b2 8000 	ldrh.w	r8, [r2]
  404ed0:	3204      	adds	r2, #4
  404ed2:	f04f 0900 	mov.w	r9, #0
  404ed6:	2301      	movs	r3, #1
  404ed8:	920e      	str	r2, [sp, #56]	; 0x38
  404eda:	e54c      	b.n	404976 <_svfprintf_r+0x1ca>
  404edc:	930a      	str	r3, [sp, #40]	; 0x28
  404ede:	4b23      	ldr	r3, [pc, #140]	; (404f6c <_svfprintf_r+0x7c0>)
  404ee0:	9316      	str	r3, [sp, #88]	; 0x58
  404ee2:	9b07      	ldr	r3, [sp, #28]
  404ee4:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  404ee8:	069b      	lsls	r3, r3, #26
  404eea:	f53f af0d 	bmi.w	404d08 <_svfprintf_r+0x55c>
  404eee:	9b07      	ldr	r3, [sp, #28]
  404ef0:	06d8      	lsls	r0, r3, #27
  404ef2:	f140 83cd 	bpl.w	405690 <_svfprintf_r+0xee4>
  404ef6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  404ef8:	4613      	mov	r3, r2
  404efa:	681b      	ldr	r3, [r3, #0]
  404efc:	4698      	mov	r8, r3
  404efe:	9b07      	ldr	r3, [sp, #28]
  404f00:	3204      	adds	r2, #4
  404f02:	07d9      	lsls	r1, r3, #31
  404f04:	920e      	str	r2, [sp, #56]	; 0x38
  404f06:	f04f 0900 	mov.w	r9, #0
  404f0a:	f53f af0b 	bmi.w	404d24 <_svfprintf_r+0x578>
  404f0e:	2302      	movs	r3, #2
  404f10:	e531      	b.n	404976 <_svfprintf_r+0x1ca>
  404f12:	990e      	ldr	r1, [sp, #56]	; 0x38
  404f14:	930a      	str	r3, [sp, #40]	; 0x28
  404f16:	680a      	ldr	r2, [r1, #0]
  404f18:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
  404f1c:	2300      	movs	r3, #0
  404f1e:	2201      	movs	r2, #1
  404f20:	3104      	adds	r1, #4
  404f22:	469c      	mov	ip, r3
  404f24:	9209      	str	r2, [sp, #36]	; 0x24
  404f26:	910e      	str	r1, [sp, #56]	; 0x38
  404f28:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  404f2c:	ab26      	add	r3, sp, #152	; 0x98
  404f2e:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
  404f32:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
  404f36:	920d      	str	r2, [sp, #52]	; 0x34
  404f38:	9310      	str	r3, [sp, #64]	; 0x40
  404f3a:	e55d      	b.n	4049f8 <_svfprintf_r+0x24c>
  404f3c:	9907      	ldr	r1, [sp, #28]
  404f3e:	f041 0108 	orr.w	r1, r1, #8
  404f42:	9107      	str	r1, [sp, #28]
  404f44:	781d      	ldrb	r5, [r3, #0]
  404f46:	4619      	mov	r1, r3
  404f48:	e483      	b.n	404852 <_svfprintf_r+0xa6>
  404f4a:	9907      	ldr	r1, [sp, #28]
  404f4c:	f041 0101 	orr.w	r1, r1, #1
  404f50:	9107      	str	r1, [sp, #28]
  404f52:	781d      	ldrb	r5, [r3, #0]
  404f54:	4619      	mov	r1, r3
  404f56:	e47c      	b.n	404852 <_svfprintf_r+0xa6>
  404f58:	9907      	ldr	r1, [sp, #28]
  404f5a:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  404f5e:	9107      	str	r1, [sp, #28]
  404f60:	781d      	ldrb	r5, [r3, #0]
  404f62:	4619      	mov	r1, r3
  404f64:	e475      	b.n	404852 <_svfprintf_r+0xa6>
  404f66:	bf00      	nop
  404f68:	00409ff8 	.word	0x00409ff8
  404f6c:	00409fe4 	.word	0x00409fe4
  404f70:	00409fc4 	.word	0x00409fc4
  404f74:	00409fb4 	.word	0x00409fb4
  404f78:	930a      	str	r3, [sp, #40]	; 0x28
  404f7a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  404f7c:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  404f80:	f103 0907 	add.w	r9, r3, #7
  404f84:	f029 0307 	bic.w	r3, r9, #7
  404f88:	f103 0208 	add.w	r2, r3, #8
  404f8c:	920e      	str	r2, [sp, #56]	; 0x38
  404f8e:	681a      	ldr	r2, [r3, #0]
  404f90:	9214      	str	r2, [sp, #80]	; 0x50
  404f92:	685b      	ldr	r3, [r3, #4]
  404f94:	9315      	str	r3, [sp, #84]	; 0x54
  404f96:	9915      	ldr	r1, [sp, #84]	; 0x54
  404f98:	9814      	ldr	r0, [sp, #80]	; 0x50
  404f9a:	f003 f92b 	bl	4081f4 <__fpclassifyd>
  404f9e:	2801      	cmp	r0, #1
  404fa0:	46d3      	mov	fp, sl
  404fa2:	9814      	ldr	r0, [sp, #80]	; 0x50
  404fa4:	9915      	ldr	r1, [sp, #84]	; 0x54
  404fa6:	f040 8359 	bne.w	40565c <_svfprintf_r+0xeb0>
  404faa:	2200      	movs	r2, #0
  404fac:	2300      	movs	r3, #0
  404fae:	f003 ff5f 	bl	408e70 <__aeabi_dcmplt>
  404fb2:	2800      	cmp	r0, #0
  404fb4:	f040 8564 	bne.w	405a80 <_svfprintf_r+0x12d4>
  404fb8:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  404fbc:	9b07      	ldr	r3, [sp, #28]
  404fbe:	4abe      	ldr	r2, [pc, #760]	; (4052b8 <_svfprintf_r+0xb0c>)
  404fc0:	f8df e300 	ldr.w	lr, [pc, #768]	; 4052c4 <_svfprintf_r+0xb18>
  404fc4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  404fc8:	9307      	str	r3, [sp, #28]
  404fca:	4613      	mov	r3, r2
  404fcc:	2103      	movs	r1, #3
  404fce:	2000      	movs	r0, #0
  404fd0:	2d47      	cmp	r5, #71	; 0x47
  404fd2:	bfd8      	it	le
  404fd4:	4673      	movle	r3, lr
  404fd6:	9109      	str	r1, [sp, #36]	; 0x24
  404fd8:	9011      	str	r0, [sp, #68]	; 0x44
  404fda:	9310      	str	r3, [sp, #64]	; 0x40
  404fdc:	910d      	str	r1, [sp, #52]	; 0x34
  404fde:	9012      	str	r0, [sp, #72]	; 0x48
  404fe0:	e504      	b.n	4049ec <_svfprintf_r+0x240>
  404fe2:	980e      	ldr	r0, [sp, #56]	; 0x38
  404fe4:	9907      	ldr	r1, [sp, #28]
  404fe6:	930a      	str	r3, [sp, #40]	; 0x28
  404fe8:	2230      	movs	r2, #48	; 0x30
  404fea:	6803      	ldr	r3, [r0, #0]
  404fec:	f88d 2070 	strb.w	r2, [sp, #112]	; 0x70
  404ff0:	4602      	mov	r2, r0
  404ff2:	2578      	movs	r5, #120	; 0x78
  404ff4:	f041 0102 	orr.w	r1, r1, #2
  404ff8:	3204      	adds	r2, #4
  404ffa:	4698      	mov	r8, r3
  404ffc:	4baf      	ldr	r3, [pc, #700]	; (4052bc <_svfprintf_r+0xb10>)
  404ffe:	9316      	str	r3, [sp, #88]	; 0x58
  405000:	9107      	str	r1, [sp, #28]
  405002:	920e      	str	r2, [sp, #56]	; 0x38
  405004:	f04f 0900 	mov.w	r9, #0
  405008:	f88d 5071 	strb.w	r5, [sp, #113]	; 0x71
  40500c:	2302      	movs	r3, #2
  40500e:	e4b2      	b.n	404976 <_svfprintf_r+0x1ca>
  405010:	930a      	str	r3, [sp, #40]	; 0x28
  405012:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  405016:	2d00      	cmp	r5, #0
  405018:	f000 83c6 	beq.w	4057a8 <_svfprintf_r+0xffc>
  40501c:	2300      	movs	r3, #0
  40501e:	2201      	movs	r2, #1
  405020:	469c      	mov	ip, r3
  405022:	9209      	str	r2, [sp, #36]	; 0x24
  405024:	f88d 5098 	strb.w	r5, [sp, #152]	; 0x98
  405028:	e77e      	b.n	404f28 <_svfprintf_r+0x77c>
  40502a:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40502e:	e539      	b.n	404aa4 <_svfprintf_r+0x2f8>
  405030:	2b01      	cmp	r3, #1
  405032:	f47f acb8 	bne.w	4049a6 <_svfprintf_r+0x1fa>
  405036:	f1b9 0f00 	cmp.w	r9, #0
  40503a:	bf08      	it	eq
  40503c:	f1b8 0f0a 	cmpeq.w	r8, #10
  405040:	f080 821c 	bcs.w	40547c <_svfprintf_r+0xcd0>
  405044:	f50d 7b80 	add.w	fp, sp, #256	; 0x100
  405048:	f108 0830 	add.w	r8, r8, #48	; 0x30
  40504c:	f80b 8d41 	strb.w	r8, [fp, #-65]!
  405050:	ebcb 0307 	rsb	r3, fp, r7
  405054:	930d      	str	r3, [sp, #52]	; 0x34
  405056:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
  40505a:	e4bf      	b.n	4049dc <_svfprintf_r+0x230>
  40505c:	2d65      	cmp	r5, #101	; 0x65
  40505e:	f340 80a0 	ble.w	4051a2 <_svfprintf_r+0x9f6>
  405062:	9814      	ldr	r0, [sp, #80]	; 0x50
  405064:	9915      	ldr	r1, [sp, #84]	; 0x54
  405066:	2200      	movs	r2, #0
  405068:	2300      	movs	r3, #0
  40506a:	f003 fef7 	bl	408e5c <__aeabi_dcmpeq>
  40506e:	2800      	cmp	r0, #0
  405070:	f000 8145 	beq.w	4052fe <_svfprintf_r+0xb52>
  405074:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405076:	4a92      	ldr	r2, [pc, #584]	; (4052c0 <_svfprintf_r+0xb14>)
  405078:	6022      	str	r2, [r4, #0]
  40507a:	3301      	adds	r3, #1
  40507c:	f10b 0b01 	add.w	fp, fp, #1
  405080:	2201      	movs	r2, #1
  405082:	2b07      	cmp	r3, #7
  405084:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405088:	9324      	str	r3, [sp, #144]	; 0x90
  40508a:	6062      	str	r2, [r4, #4]
  40508c:	f300 8334 	bgt.w	4056f8 <_svfprintf_r+0xf4c>
  405090:	3408      	adds	r4, #8
  405092:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  405094:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  405096:	4293      	cmp	r3, r2
  405098:	db03      	blt.n	4050a2 <_svfprintf_r+0x8f6>
  40509a:	9b07      	ldr	r3, [sp, #28]
  40509c:	07da      	lsls	r2, r3, #31
  40509e:	f57f ad7f 	bpl.w	404ba0 <_svfprintf_r+0x3f4>
  4050a2:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4050a4:	9918      	ldr	r1, [sp, #96]	; 0x60
  4050a6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  4050a8:	6022      	str	r2, [r4, #0]
  4050aa:	3301      	adds	r3, #1
  4050ac:	448b      	add	fp, r1
  4050ae:	2b07      	cmp	r3, #7
  4050b0:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4050b4:	6061      	str	r1, [r4, #4]
  4050b6:	9324      	str	r3, [sp, #144]	; 0x90
  4050b8:	f300 8390 	bgt.w	4057dc <_svfprintf_r+0x1030>
  4050bc:	3408      	adds	r4, #8
  4050be:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4050c0:	1e5d      	subs	r5, r3, #1
  4050c2:	2d00      	cmp	r5, #0
  4050c4:	f77f ad6c 	ble.w	404ba0 <_svfprintf_r+0x3f4>
  4050c8:	2d10      	cmp	r5, #16
  4050ca:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4050cc:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 4052c8 <_svfprintf_r+0xb1c>
  4050d0:	f340 81ba 	ble.w	405448 <_svfprintf_r+0xc9c>
  4050d4:	f04f 0810 	mov.w	r8, #16
  4050d8:	465a      	mov	r2, fp
  4050da:	f8dd a020 	ldr.w	sl, [sp, #32]
  4050de:	e004      	b.n	4050ea <_svfprintf_r+0x93e>
  4050e0:	3408      	adds	r4, #8
  4050e2:	3d10      	subs	r5, #16
  4050e4:	2d10      	cmp	r5, #16
  4050e6:	f340 81ae 	ble.w	405446 <_svfprintf_r+0xc9a>
  4050ea:	3301      	adds	r3, #1
  4050ec:	3210      	adds	r2, #16
  4050ee:	2b07      	cmp	r3, #7
  4050f0:	9225      	str	r2, [sp, #148]	; 0x94
  4050f2:	9324      	str	r3, [sp, #144]	; 0x90
  4050f4:	f8c4 9000 	str.w	r9, [r4]
  4050f8:	f8c4 8004 	str.w	r8, [r4, #4]
  4050fc:	ddf0      	ble.n	4050e0 <_svfprintf_r+0x934>
  4050fe:	4650      	mov	r0, sl
  405100:	4631      	mov	r1, r6
  405102:	aa23      	add	r2, sp, #140	; 0x8c
  405104:	f003 f8f6 	bl	4082f4 <__ssprint_r>
  405108:	2800      	cmp	r0, #0
  40510a:	f47f ac15 	bne.w	404938 <_svfprintf_r+0x18c>
  40510e:	9a25      	ldr	r2, [sp, #148]	; 0x94
  405110:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405112:	463c      	mov	r4, r7
  405114:	e7e5      	b.n	4050e2 <_svfprintf_r+0x936>
  405116:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  405118:	9a09      	ldr	r2, [sp, #36]	; 0x24
  40511a:	ebc2 0a03 	rsb	sl, r2, r3
  40511e:	f1ba 0f00 	cmp.w	sl, #0
  405122:	f77f ace7 	ble.w	404af4 <_svfprintf_r+0x348>
  405126:	f1ba 0f10 	cmp.w	sl, #16
  40512a:	9a24      	ldr	r2, [sp, #144]	; 0x90
  40512c:	f8df 9198 	ldr.w	r9, [pc, #408]	; 4052c8 <_svfprintf_r+0xb1c>
  405130:	dd2b      	ble.n	40518a <_svfprintf_r+0x9de>
  405132:	4649      	mov	r1, r9
  405134:	465b      	mov	r3, fp
  405136:	46a9      	mov	r9, r5
  405138:	f04f 0810 	mov.w	r8, #16
  40513c:	f8dd b020 	ldr.w	fp, [sp, #32]
  405140:	460d      	mov	r5, r1
  405142:	e006      	b.n	405152 <_svfprintf_r+0x9a6>
  405144:	f1aa 0a10 	sub.w	sl, sl, #16
  405148:	f1ba 0f10 	cmp.w	sl, #16
  40514c:	f104 0408 	add.w	r4, r4, #8
  405150:	dd17      	ble.n	405182 <_svfprintf_r+0x9d6>
  405152:	3201      	adds	r2, #1
  405154:	3310      	adds	r3, #16
  405156:	2a07      	cmp	r2, #7
  405158:	9325      	str	r3, [sp, #148]	; 0x94
  40515a:	9224      	str	r2, [sp, #144]	; 0x90
  40515c:	e884 0120 	stmia.w	r4, {r5, r8}
  405160:	ddf0      	ble.n	405144 <_svfprintf_r+0x998>
  405162:	4658      	mov	r0, fp
  405164:	4631      	mov	r1, r6
  405166:	aa23      	add	r2, sp, #140	; 0x8c
  405168:	f003 f8c4 	bl	4082f4 <__ssprint_r>
  40516c:	2800      	cmp	r0, #0
  40516e:	f47f abe3 	bne.w	404938 <_svfprintf_r+0x18c>
  405172:	f1aa 0a10 	sub.w	sl, sl, #16
  405176:	f1ba 0f10 	cmp.w	sl, #16
  40517a:	9b25      	ldr	r3, [sp, #148]	; 0x94
  40517c:	9a24      	ldr	r2, [sp, #144]	; 0x90
  40517e:	463c      	mov	r4, r7
  405180:	dce7      	bgt.n	405152 <_svfprintf_r+0x9a6>
  405182:	469b      	mov	fp, r3
  405184:	462b      	mov	r3, r5
  405186:	464d      	mov	r5, r9
  405188:	4699      	mov	r9, r3
  40518a:	3201      	adds	r2, #1
  40518c:	44d3      	add	fp, sl
  40518e:	2a07      	cmp	r2, #7
  405190:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405194:	9224      	str	r2, [sp, #144]	; 0x90
  405196:	e884 0600 	stmia.w	r4, {r9, sl}
  40519a:	f300 8252 	bgt.w	405642 <_svfprintf_r+0xe96>
  40519e:	3408      	adds	r4, #8
  4051a0:	e4a8      	b.n	404af4 <_svfprintf_r+0x348>
  4051a2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4051a4:	9d24      	ldr	r5, [sp, #144]	; 0x90
  4051a6:	2b01      	cmp	r3, #1
  4051a8:	f340 8220 	ble.w	4055ec <_svfprintf_r+0xe40>
  4051ac:	9b10      	ldr	r3, [sp, #64]	; 0x40
  4051ae:	6023      	str	r3, [r4, #0]
  4051b0:	3501      	adds	r5, #1
  4051b2:	f10b 0301 	add.w	r3, fp, #1
  4051b6:	2201      	movs	r2, #1
  4051b8:	2d07      	cmp	r5, #7
  4051ba:	9325      	str	r3, [sp, #148]	; 0x94
  4051bc:	9524      	str	r5, [sp, #144]	; 0x90
  4051be:	6062      	str	r2, [r4, #4]
  4051c0:	f300 8226 	bgt.w	405610 <_svfprintf_r+0xe64>
  4051c4:	3408      	adds	r4, #8
  4051c6:	9918      	ldr	r1, [sp, #96]	; 0x60
  4051c8:	6061      	str	r1, [r4, #4]
  4051ca:	3501      	adds	r5, #1
  4051cc:	eb03 0b01 	add.w	fp, r3, r1
  4051d0:	2d07      	cmp	r5, #7
  4051d2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  4051d4:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4051d8:	9524      	str	r5, [sp, #144]	; 0x90
  4051da:	6023      	str	r3, [r4, #0]
  4051dc:	f300 8224 	bgt.w	405628 <_svfprintf_r+0xe7c>
  4051e0:	3408      	adds	r4, #8
  4051e2:	2300      	movs	r3, #0
  4051e4:	9814      	ldr	r0, [sp, #80]	; 0x50
  4051e6:	9915      	ldr	r1, [sp, #84]	; 0x54
  4051e8:	2200      	movs	r2, #0
  4051ea:	f003 fe37 	bl	408e5c <__aeabi_dcmpeq>
  4051ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4051f0:	2800      	cmp	r0, #0
  4051f2:	f040 80de 	bne.w	4053b2 <_svfprintf_r+0xc06>
  4051f6:	9a10      	ldr	r2, [sp, #64]	; 0x40
  4051f8:	3b01      	subs	r3, #1
  4051fa:	3501      	adds	r5, #1
  4051fc:	3201      	adds	r2, #1
  4051fe:	449b      	add	fp, r3
  405200:	2d07      	cmp	r5, #7
  405202:	9524      	str	r5, [sp, #144]	; 0x90
  405204:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405208:	6022      	str	r2, [r4, #0]
  40520a:	6063      	str	r3, [r4, #4]
  40520c:	f300 810e 	bgt.w	40542c <_svfprintf_r+0xc80>
  405210:	3408      	adds	r4, #8
  405212:	9a19      	ldr	r2, [sp, #100]	; 0x64
  405214:	6062      	str	r2, [r4, #4]
  405216:	3501      	adds	r5, #1
  405218:	4493      	add	fp, r2
  40521a:	ab1f      	add	r3, sp, #124	; 0x7c
  40521c:	2d07      	cmp	r5, #7
  40521e:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405222:	9524      	str	r5, [sp, #144]	; 0x90
  405224:	6023      	str	r3, [r4, #0]
  405226:	f77f acba 	ble.w	404b9e <_svfprintf_r+0x3f2>
  40522a:	9808      	ldr	r0, [sp, #32]
  40522c:	4631      	mov	r1, r6
  40522e:	aa23      	add	r2, sp, #140	; 0x8c
  405230:	f003 f860 	bl	4082f4 <__ssprint_r>
  405234:	2800      	cmp	r0, #0
  405236:	f47f ab7f 	bne.w	404938 <_svfprintf_r+0x18c>
  40523a:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40523e:	463c      	mov	r4, r7
  405240:	e4ae      	b.n	404ba0 <_svfprintf_r+0x3f4>
  405242:	2b00      	cmp	r3, #0
  405244:	d132      	bne.n	4052ac <_svfprintf_r+0xb00>
  405246:	9b07      	ldr	r3, [sp, #28]
  405248:	07d8      	lsls	r0, r3, #31
  40524a:	d52f      	bpl.n	4052ac <_svfprintf_r+0xb00>
  40524c:	f50d 7b80 	add.w	fp, sp, #256	; 0x100
  405250:	2330      	movs	r3, #48	; 0x30
  405252:	f80b 3d41 	strb.w	r3, [fp, #-65]!
  405256:	ebcb 0307 	rsb	r3, fp, r7
  40525a:	930d      	str	r3, [sp, #52]	; 0x34
  40525c:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
  405260:	f7ff bbbc 	b.w	4049dc <_svfprintf_r+0x230>
  405264:	9808      	ldr	r0, [sp, #32]
  405266:	4631      	mov	r1, r6
  405268:	aa23      	add	r2, sp, #140	; 0x8c
  40526a:	f003 f843 	bl	4082f4 <__ssprint_r>
  40526e:	2800      	cmp	r0, #0
  405270:	f47f ab62 	bne.w	404938 <_svfprintf_r+0x18c>
  405274:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405278:	463c      	mov	r4, r7
  40527a:	e47f      	b.n	404b7c <_svfprintf_r+0x3d0>
  40527c:	9808      	ldr	r0, [sp, #32]
  40527e:	4631      	mov	r1, r6
  405280:	aa23      	add	r2, sp, #140	; 0x8c
  405282:	f003 f837 	bl	4082f4 <__ssprint_r>
  405286:	2800      	cmp	r0, #0
  405288:	f47f ab56 	bne.w	404938 <_svfprintf_r+0x18c>
  40528c:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405290:	463c      	mov	r4, r7
  405292:	e41a      	b.n	404aca <_svfprintf_r+0x31e>
  405294:	9808      	ldr	r0, [sp, #32]
  405296:	4631      	mov	r1, r6
  405298:	aa23      	add	r2, sp, #140	; 0x8c
  40529a:	f003 f82b 	bl	4082f4 <__ssprint_r>
  40529e:	2800      	cmp	r0, #0
  4052a0:	f47f ab4a 	bne.w	404938 <_svfprintf_r+0x18c>
  4052a4:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  4052a8:	463c      	mov	r4, r7
  4052aa:	e41f      	b.n	404aec <_svfprintf_r+0x340>
  4052ac:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
  4052b0:	9710      	str	r7, [sp, #64]	; 0x40
  4052b2:	f7ff bb93 	b.w	4049dc <_svfprintf_r+0x230>
  4052b6:	bf00      	nop
  4052b8:	00409fd8 	.word	0x00409fd8
  4052bc:	00409ff8 	.word	0x00409ff8
  4052c0:	0040a014 	.word	0x0040a014
  4052c4:	00409fd4 	.word	0x00409fd4
  4052c8:	00409fb4 	.word	0x00409fb4
  4052cc:	9816      	ldr	r0, [sp, #88]	; 0x58
  4052ce:	46bb      	mov	fp, r7
  4052d0:	ea4f 1318 	mov.w	r3, r8, lsr #4
  4052d4:	f008 010f 	and.w	r1, r8, #15
  4052d8:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
  4052dc:	ea4f 1219 	mov.w	r2, r9, lsr #4
  4052e0:	4698      	mov	r8, r3
  4052e2:	4691      	mov	r9, r2
  4052e4:	5c43      	ldrb	r3, [r0, r1]
  4052e6:	f80b 3d01 	strb.w	r3, [fp, #-1]!
  4052ea:	ea58 0309 	orrs.w	r3, r8, r9
  4052ee:	d1ef      	bne.n	4052d0 <_svfprintf_r+0xb24>
  4052f0:	465b      	mov	r3, fp
  4052f2:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
  4052f6:	1afb      	subs	r3, r7, r3
  4052f8:	930d      	str	r3, [sp, #52]	; 0x34
  4052fa:	f7ff bb6f 	b.w	4049dc <_svfprintf_r+0x230>
  4052fe:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  405300:	2d00      	cmp	r5, #0
  405302:	f340 8205 	ble.w	405710 <_svfprintf_r+0xf64>
  405306:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  405308:	9912      	ldr	r1, [sp, #72]	; 0x48
  40530a:	428a      	cmp	r2, r1
  40530c:	4613      	mov	r3, r2
  40530e:	bfa8      	it	ge
  405310:	460b      	movge	r3, r1
  405312:	461d      	mov	r5, r3
  405314:	9910      	ldr	r1, [sp, #64]	; 0x40
  405316:	2d00      	cmp	r5, #0
  405318:	eb01 0a02 	add.w	sl, r1, r2
  40531c:	dd0b      	ble.n	405336 <_svfprintf_r+0xb8a>
  40531e:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405320:	6021      	str	r1, [r4, #0]
  405322:	3301      	adds	r3, #1
  405324:	44ab      	add	fp, r5
  405326:	2b07      	cmp	r3, #7
  405328:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  40532c:	6065      	str	r5, [r4, #4]
  40532e:	9324      	str	r3, [sp, #144]	; 0x90
  405330:	f300 834d 	bgt.w	4059ce <_svfprintf_r+0x1222>
  405334:	3408      	adds	r4, #8
  405336:	9b12      	ldr	r3, [sp, #72]	; 0x48
  405338:	2d00      	cmp	r5, #0
  40533a:	bfa8      	it	ge
  40533c:	1b5b      	subge	r3, r3, r5
  40533e:	2b00      	cmp	r3, #0
  405340:	461d      	mov	r5, r3
  405342:	f340 80f5 	ble.w	405530 <_svfprintf_r+0xd84>
  405346:	2d10      	cmp	r5, #16
  405348:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40534a:	f8df 95f4 	ldr.w	r9, [pc, #1524]	; 405940 <_svfprintf_r+0x1194>
  40534e:	f340 81c6 	ble.w	4056de <_svfprintf_r+0xf32>
  405352:	465a      	mov	r2, fp
  405354:	f04f 0810 	mov.w	r8, #16
  405358:	f8dd b020 	ldr.w	fp, [sp, #32]
  40535c:	e004      	b.n	405368 <_svfprintf_r+0xbbc>
  40535e:	3408      	adds	r4, #8
  405360:	3d10      	subs	r5, #16
  405362:	2d10      	cmp	r5, #16
  405364:	f340 81ba 	ble.w	4056dc <_svfprintf_r+0xf30>
  405368:	3301      	adds	r3, #1
  40536a:	3210      	adds	r2, #16
  40536c:	2b07      	cmp	r3, #7
  40536e:	9225      	str	r2, [sp, #148]	; 0x94
  405370:	9324      	str	r3, [sp, #144]	; 0x90
  405372:	f8c4 9000 	str.w	r9, [r4]
  405376:	f8c4 8004 	str.w	r8, [r4, #4]
  40537a:	ddf0      	ble.n	40535e <_svfprintf_r+0xbb2>
  40537c:	4658      	mov	r0, fp
  40537e:	4631      	mov	r1, r6
  405380:	aa23      	add	r2, sp, #140	; 0x8c
  405382:	f002 ffb7 	bl	4082f4 <__ssprint_r>
  405386:	2800      	cmp	r0, #0
  405388:	f47f aad6 	bne.w	404938 <_svfprintf_r+0x18c>
  40538c:	9a25      	ldr	r2, [sp, #148]	; 0x94
  40538e:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405390:	463c      	mov	r4, r7
  405392:	e7e5      	b.n	405360 <_svfprintf_r+0xbb4>
  405394:	9808      	ldr	r0, [sp, #32]
  405396:	4631      	mov	r1, r6
  405398:	aa23      	add	r2, sp, #140	; 0x8c
  40539a:	f002 ffab 	bl	4082f4 <__ssprint_r>
  40539e:	2800      	cmp	r0, #0
  4053a0:	f47f aaca 	bne.w	404938 <_svfprintf_r+0x18c>
  4053a4:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  4053a8:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  4053ac:	463c      	mov	r4, r7
  4053ae:	f7ff bb79 	b.w	404aa4 <_svfprintf_r+0x2f8>
  4053b2:	f103 38ff 	add.w	r8, r3, #4294967295
  4053b6:	f1b8 0f00 	cmp.w	r8, #0
  4053ba:	f77f af2a 	ble.w	405212 <_svfprintf_r+0xa66>
  4053be:	f1b8 0f10 	cmp.w	r8, #16
  4053c2:	f8df 957c 	ldr.w	r9, [pc, #1404]	; 405940 <_svfprintf_r+0x1194>
  4053c6:	dd25      	ble.n	405414 <_svfprintf_r+0xc68>
  4053c8:	465b      	mov	r3, fp
  4053ca:	f04f 0a10 	mov.w	sl, #16
  4053ce:	f8dd b020 	ldr.w	fp, [sp, #32]
  4053d2:	e006      	b.n	4053e2 <_svfprintf_r+0xc36>
  4053d4:	f1a8 0810 	sub.w	r8, r8, #16
  4053d8:	f1b8 0f10 	cmp.w	r8, #16
  4053dc:	f104 0408 	add.w	r4, r4, #8
  4053e0:	dd17      	ble.n	405412 <_svfprintf_r+0xc66>
  4053e2:	3501      	adds	r5, #1
  4053e4:	3310      	adds	r3, #16
  4053e6:	2d07      	cmp	r5, #7
  4053e8:	9325      	str	r3, [sp, #148]	; 0x94
  4053ea:	9524      	str	r5, [sp, #144]	; 0x90
  4053ec:	e884 0600 	stmia.w	r4, {r9, sl}
  4053f0:	ddf0      	ble.n	4053d4 <_svfprintf_r+0xc28>
  4053f2:	4658      	mov	r0, fp
  4053f4:	4631      	mov	r1, r6
  4053f6:	aa23      	add	r2, sp, #140	; 0x8c
  4053f8:	f002 ff7c 	bl	4082f4 <__ssprint_r>
  4053fc:	2800      	cmp	r0, #0
  4053fe:	f47f aa9b 	bne.w	404938 <_svfprintf_r+0x18c>
  405402:	f1a8 0810 	sub.w	r8, r8, #16
  405406:	f1b8 0f10 	cmp.w	r8, #16
  40540a:	9b25      	ldr	r3, [sp, #148]	; 0x94
  40540c:	9d24      	ldr	r5, [sp, #144]	; 0x90
  40540e:	463c      	mov	r4, r7
  405410:	dce7      	bgt.n	4053e2 <_svfprintf_r+0xc36>
  405412:	469b      	mov	fp, r3
  405414:	3501      	adds	r5, #1
  405416:	44c3      	add	fp, r8
  405418:	2d07      	cmp	r5, #7
  40541a:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  40541e:	9524      	str	r5, [sp, #144]	; 0x90
  405420:	f8c4 9000 	str.w	r9, [r4]
  405424:	f8c4 8004 	str.w	r8, [r4, #4]
  405428:	f77f aef2 	ble.w	405210 <_svfprintf_r+0xa64>
  40542c:	9808      	ldr	r0, [sp, #32]
  40542e:	4631      	mov	r1, r6
  405430:	aa23      	add	r2, sp, #140	; 0x8c
  405432:	f002 ff5f 	bl	4082f4 <__ssprint_r>
  405436:	2800      	cmp	r0, #0
  405438:	f47f aa7e 	bne.w	404938 <_svfprintf_r+0x18c>
  40543c:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405440:	9d24      	ldr	r5, [sp, #144]	; 0x90
  405442:	463c      	mov	r4, r7
  405444:	e6e5      	b.n	405212 <_svfprintf_r+0xa66>
  405446:	4693      	mov	fp, r2
  405448:	3301      	adds	r3, #1
  40544a:	44ab      	add	fp, r5
  40544c:	2b07      	cmp	r3, #7
  40544e:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405452:	9324      	str	r3, [sp, #144]	; 0x90
  405454:	f8c4 9000 	str.w	r9, [r4]
  405458:	6065      	str	r5, [r4, #4]
  40545a:	f77f aba0 	ble.w	404b9e <_svfprintf_r+0x3f2>
  40545e:	e6e4      	b.n	40522a <_svfprintf_r+0xa7e>
  405460:	2b30      	cmp	r3, #48	; 0x30
  405462:	9b10      	ldr	r3, [sp, #64]	; 0x40
  405464:	f43f af47 	beq.w	4052f6 <_svfprintf_r+0xb4a>
  405468:	3b01      	subs	r3, #1
  40546a:	461a      	mov	r2, r3
  40546c:	9310      	str	r3, [sp, #64]	; 0x40
  40546e:	1aba      	subs	r2, r7, r2
  405470:	2330      	movs	r3, #48	; 0x30
  405472:	920d      	str	r2, [sp, #52]	; 0x34
  405474:	f801 3c01 	strb.w	r3, [r1, #-1]
  405478:	f7ff bab0 	b.w	4049dc <_svfprintf_r+0x230>
  40547c:	46bb      	mov	fp, r7
  40547e:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  405482:	4640      	mov	r0, r8
  405484:	4649      	mov	r1, r9
  405486:	220a      	movs	r2, #10
  405488:	2300      	movs	r3, #0
  40548a:	f003 fd41 	bl	408f10 <__aeabi_uldivmod>
  40548e:	3230      	adds	r2, #48	; 0x30
  405490:	4640      	mov	r0, r8
  405492:	4649      	mov	r1, r9
  405494:	f80b 2d01 	strb.w	r2, [fp, #-1]!
  405498:	2300      	movs	r3, #0
  40549a:	220a      	movs	r2, #10
  40549c:	f003 fd38 	bl	408f10 <__aeabi_uldivmod>
  4054a0:	4680      	mov	r8, r0
  4054a2:	4689      	mov	r9, r1
  4054a4:	ea58 0309 	orrs.w	r3, r8, r9
  4054a8:	d1eb      	bne.n	405482 <_svfprintf_r+0xcd6>
  4054aa:	465b      	mov	r3, fp
  4054ac:	1afb      	subs	r3, r7, r3
  4054ae:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  4054b2:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
  4054b6:	930d      	str	r3, [sp, #52]	; 0x34
  4054b8:	f7ff ba90 	b.w	4049dc <_svfprintf_r+0x230>
  4054bc:	990e      	ldr	r1, [sp, #56]	; 0x38
  4054be:	680a      	ldr	r2, [r1, #0]
  4054c0:	3104      	adds	r1, #4
  4054c2:	910e      	str	r1, [sp, #56]	; 0x38
  4054c4:	4690      	mov	r8, r2
  4054c6:	f04f 0900 	mov.w	r9, #0
  4054ca:	f7ff ba54 	b.w	404976 <_svfprintf_r+0x1ca>
  4054ce:	990e      	ldr	r1, [sp, #56]	; 0x38
  4054d0:	680a      	ldr	r2, [r1, #0]
  4054d2:	3104      	adds	r1, #4
  4054d4:	2301      	movs	r3, #1
  4054d6:	910e      	str	r1, [sp, #56]	; 0x38
  4054d8:	4690      	mov	r8, r2
  4054da:	f04f 0900 	mov.w	r9, #0
  4054de:	f7ff ba4a 	b.w	404976 <_svfprintf_r+0x1ca>
  4054e2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4054e4:	6813      	ldr	r3, [r2, #0]
  4054e6:	4698      	mov	r8, r3
  4054e8:	ea4f 79e3 	mov.w	r9, r3, asr #31
  4054ec:	4613      	mov	r3, r2
  4054ee:	3304      	adds	r3, #4
  4054f0:	4642      	mov	r2, r8
  4054f2:	930e      	str	r3, [sp, #56]	; 0x38
  4054f4:	2a00      	cmp	r2, #0
  4054f6:	464b      	mov	r3, r9
  4054f8:	f173 0300 	sbcs.w	r3, r3, #0
  4054fc:	f6bf abf5 	bge.w	404cea <_svfprintf_r+0x53e>
  405500:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
  405504:	f1d8 0800 	rsbs	r8, r8, #0
  405508:	eb69 0949 	sbc.w	r9, r9, r9, lsl #1
  40550c:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
  405510:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
  405514:	2301      	movs	r3, #1
  405516:	f7ff ba34 	b.w	404982 <_svfprintf_r+0x1d6>
  40551a:	9808      	ldr	r0, [sp, #32]
  40551c:	4631      	mov	r1, r6
  40551e:	aa23      	add	r2, sp, #140	; 0x8c
  405520:	f002 fee8 	bl	4082f4 <__ssprint_r>
  405524:	2800      	cmp	r0, #0
  405526:	f47f aa07 	bne.w	404938 <_svfprintf_r+0x18c>
  40552a:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40552e:	463c      	mov	r4, r7
  405530:	9a10      	ldr	r2, [sp, #64]	; 0x40
  405532:	9912      	ldr	r1, [sp, #72]	; 0x48
  405534:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  405536:	440a      	add	r2, r1
  405538:	4690      	mov	r8, r2
  40553a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  40553c:	4293      	cmp	r3, r2
  40553e:	db46      	blt.n	4055ce <_svfprintf_r+0xe22>
  405540:	9a07      	ldr	r2, [sp, #28]
  405542:	07d0      	lsls	r0, r2, #31
  405544:	d443      	bmi.n	4055ce <_svfprintf_r+0xe22>
  405546:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  405548:	ebc8 050a 	rsb	r5, r8, sl
  40554c:	1ad3      	subs	r3, r2, r3
  40554e:	429d      	cmp	r5, r3
  405550:	bfa8      	it	ge
  405552:	461d      	movge	r5, r3
  405554:	2d00      	cmp	r5, #0
  405556:	dd0c      	ble.n	405572 <_svfprintf_r+0xdc6>
  405558:	9a24      	ldr	r2, [sp, #144]	; 0x90
  40555a:	f8c4 8000 	str.w	r8, [r4]
  40555e:	3201      	adds	r2, #1
  405560:	44ab      	add	fp, r5
  405562:	2a07      	cmp	r2, #7
  405564:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405568:	6065      	str	r5, [r4, #4]
  40556a:	9224      	str	r2, [sp, #144]	; 0x90
  40556c:	f300 8267 	bgt.w	405a3e <_svfprintf_r+0x1292>
  405570:	3408      	adds	r4, #8
  405572:	2d00      	cmp	r5, #0
  405574:	bfac      	ite	ge
  405576:	1b5d      	subge	r5, r3, r5
  405578:	461d      	movlt	r5, r3
  40557a:	2d00      	cmp	r5, #0
  40557c:	f77f ab10 	ble.w	404ba0 <_svfprintf_r+0x3f4>
  405580:	2d10      	cmp	r5, #16
  405582:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405584:	f8df 93b8 	ldr.w	r9, [pc, #952]	; 405940 <_svfprintf_r+0x1194>
  405588:	f77f af5e 	ble.w	405448 <_svfprintf_r+0xc9c>
  40558c:	f04f 0810 	mov.w	r8, #16
  405590:	465a      	mov	r2, fp
  405592:	f8dd a020 	ldr.w	sl, [sp, #32]
  405596:	e004      	b.n	4055a2 <_svfprintf_r+0xdf6>
  405598:	3408      	adds	r4, #8
  40559a:	3d10      	subs	r5, #16
  40559c:	2d10      	cmp	r5, #16
  40559e:	f77f af52 	ble.w	405446 <_svfprintf_r+0xc9a>
  4055a2:	3301      	adds	r3, #1
  4055a4:	3210      	adds	r2, #16
  4055a6:	2b07      	cmp	r3, #7
  4055a8:	9225      	str	r2, [sp, #148]	; 0x94
  4055aa:	9324      	str	r3, [sp, #144]	; 0x90
  4055ac:	f8c4 9000 	str.w	r9, [r4]
  4055b0:	f8c4 8004 	str.w	r8, [r4, #4]
  4055b4:	ddf0      	ble.n	405598 <_svfprintf_r+0xdec>
  4055b6:	4650      	mov	r0, sl
  4055b8:	4631      	mov	r1, r6
  4055ba:	aa23      	add	r2, sp, #140	; 0x8c
  4055bc:	f002 fe9a 	bl	4082f4 <__ssprint_r>
  4055c0:	2800      	cmp	r0, #0
  4055c2:	f47f a9b9 	bne.w	404938 <_svfprintf_r+0x18c>
  4055c6:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4055c8:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4055ca:	463c      	mov	r4, r7
  4055cc:	e7e5      	b.n	40559a <_svfprintf_r+0xdee>
  4055ce:	9a24      	ldr	r2, [sp, #144]	; 0x90
  4055d0:	9818      	ldr	r0, [sp, #96]	; 0x60
  4055d2:	9917      	ldr	r1, [sp, #92]	; 0x5c
  4055d4:	6021      	str	r1, [r4, #0]
  4055d6:	3201      	adds	r2, #1
  4055d8:	4483      	add	fp, r0
  4055da:	2a07      	cmp	r2, #7
  4055dc:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4055e0:	6060      	str	r0, [r4, #4]
  4055e2:	9224      	str	r2, [sp, #144]	; 0x90
  4055e4:	f300 820a 	bgt.w	4059fc <_svfprintf_r+0x1250>
  4055e8:	3408      	adds	r4, #8
  4055ea:	e7ac      	b.n	405546 <_svfprintf_r+0xd9a>
  4055ec:	9b07      	ldr	r3, [sp, #28]
  4055ee:	07d9      	lsls	r1, r3, #31
  4055f0:	f53f addc 	bmi.w	4051ac <_svfprintf_r+0xa00>
  4055f4:	9b10      	ldr	r3, [sp, #64]	; 0x40
  4055f6:	6023      	str	r3, [r4, #0]
  4055f8:	3501      	adds	r5, #1
  4055fa:	f10b 0b01 	add.w	fp, fp, #1
  4055fe:	2301      	movs	r3, #1
  405600:	2d07      	cmp	r5, #7
  405602:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405606:	9524      	str	r5, [sp, #144]	; 0x90
  405608:	6063      	str	r3, [r4, #4]
  40560a:	f77f ae01 	ble.w	405210 <_svfprintf_r+0xa64>
  40560e:	e70d      	b.n	40542c <_svfprintf_r+0xc80>
  405610:	9808      	ldr	r0, [sp, #32]
  405612:	4631      	mov	r1, r6
  405614:	aa23      	add	r2, sp, #140	; 0x8c
  405616:	f002 fe6d 	bl	4082f4 <__ssprint_r>
  40561a:	2800      	cmp	r0, #0
  40561c:	f47f a98c 	bne.w	404938 <_svfprintf_r+0x18c>
  405620:	9b25      	ldr	r3, [sp, #148]	; 0x94
  405622:	9d24      	ldr	r5, [sp, #144]	; 0x90
  405624:	463c      	mov	r4, r7
  405626:	e5ce      	b.n	4051c6 <_svfprintf_r+0xa1a>
  405628:	9808      	ldr	r0, [sp, #32]
  40562a:	4631      	mov	r1, r6
  40562c:	aa23      	add	r2, sp, #140	; 0x8c
  40562e:	f002 fe61 	bl	4082f4 <__ssprint_r>
  405632:	2800      	cmp	r0, #0
  405634:	f47f a980 	bne.w	404938 <_svfprintf_r+0x18c>
  405638:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40563c:	9d24      	ldr	r5, [sp, #144]	; 0x90
  40563e:	463c      	mov	r4, r7
  405640:	e5cf      	b.n	4051e2 <_svfprintf_r+0xa36>
  405642:	9808      	ldr	r0, [sp, #32]
  405644:	4631      	mov	r1, r6
  405646:	aa23      	add	r2, sp, #140	; 0x8c
  405648:	f002 fe54 	bl	4082f4 <__ssprint_r>
  40564c:	2800      	cmp	r0, #0
  40564e:	f47f a973 	bne.w	404938 <_svfprintf_r+0x18c>
  405652:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405656:	463c      	mov	r4, r7
  405658:	f7ff ba4c 	b.w	404af4 <_svfprintf_r+0x348>
  40565c:	f002 fdca 	bl	4081f4 <__fpclassifyd>
  405660:	2800      	cmp	r0, #0
  405662:	f040 80c7 	bne.w	4057f4 <_svfprintf_r+0x1048>
  405666:	4686      	mov	lr, r0
  405668:	4ab2      	ldr	r2, [pc, #712]	; (405934 <_svfprintf_r+0x1188>)
  40566a:	4bb3      	ldr	r3, [pc, #716]	; (405938 <_svfprintf_r+0x118c>)
  40566c:	9011      	str	r0, [sp, #68]	; 0x44
  40566e:	9807      	ldr	r0, [sp, #28]
  405670:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  405674:	f8cd e048 	str.w	lr, [sp, #72]	; 0x48
  405678:	2103      	movs	r1, #3
  40567a:	f020 0080 	bic.w	r0, r0, #128	; 0x80
  40567e:	2d47      	cmp	r5, #71	; 0x47
  405680:	bfd8      	it	le
  405682:	461a      	movle	r2, r3
  405684:	9109      	str	r1, [sp, #36]	; 0x24
  405686:	9007      	str	r0, [sp, #28]
  405688:	9210      	str	r2, [sp, #64]	; 0x40
  40568a:	910d      	str	r1, [sp, #52]	; 0x34
  40568c:	f7ff b9ae 	b.w	4049ec <_svfprintf_r+0x240>
  405690:	9b07      	ldr	r3, [sp, #28]
  405692:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  405694:	f013 0f40 	tst.w	r3, #64	; 0x40
  405698:	4613      	mov	r3, r2
  40569a:	f43f ac2e 	beq.w	404efa <_svfprintf_r+0x74e>
  40569e:	3304      	adds	r3, #4
  4056a0:	f8b2 8000 	ldrh.w	r8, [r2]
  4056a4:	930e      	str	r3, [sp, #56]	; 0x38
  4056a6:	f04f 0900 	mov.w	r9, #0
  4056aa:	f7ff bb37 	b.w	404d1c <_svfprintf_r+0x570>
  4056ae:	9b07      	ldr	r3, [sp, #28]
  4056b0:	06db      	lsls	r3, r3, #27
  4056b2:	d40b      	bmi.n	4056cc <_svfprintf_r+0xf20>
  4056b4:	9b07      	ldr	r3, [sp, #28]
  4056b6:	065d      	lsls	r5, r3, #25
  4056b8:	d508      	bpl.n	4056cc <_svfprintf_r+0xf20>
  4056ba:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4056bc:	6813      	ldr	r3, [r2, #0]
  4056be:	3204      	adds	r2, #4
  4056c0:	920e      	str	r2, [sp, #56]	; 0x38
  4056c2:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
  4056c6:	801a      	strh	r2, [r3, #0]
  4056c8:	f7ff b895 	b.w	4047f6 <_svfprintf_r+0x4a>
  4056cc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4056ce:	6813      	ldr	r3, [r2, #0]
  4056d0:	3204      	adds	r2, #4
  4056d2:	920e      	str	r2, [sp, #56]	; 0x38
  4056d4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  4056d6:	601a      	str	r2, [r3, #0]
  4056d8:	f7ff b88d 	b.w	4047f6 <_svfprintf_r+0x4a>
  4056dc:	4693      	mov	fp, r2
  4056de:	3301      	adds	r3, #1
  4056e0:	44ab      	add	fp, r5
  4056e2:	2b07      	cmp	r3, #7
  4056e4:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4056e8:	9324      	str	r3, [sp, #144]	; 0x90
  4056ea:	f8c4 9000 	str.w	r9, [r4]
  4056ee:	6065      	str	r5, [r4, #4]
  4056f0:	f73f af13 	bgt.w	40551a <_svfprintf_r+0xd6e>
  4056f4:	3408      	adds	r4, #8
  4056f6:	e71b      	b.n	405530 <_svfprintf_r+0xd84>
  4056f8:	9808      	ldr	r0, [sp, #32]
  4056fa:	4631      	mov	r1, r6
  4056fc:	aa23      	add	r2, sp, #140	; 0x8c
  4056fe:	f002 fdf9 	bl	4082f4 <__ssprint_r>
  405702:	2800      	cmp	r0, #0
  405704:	f47f a918 	bne.w	404938 <_svfprintf_r+0x18c>
  405708:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40570c:	463c      	mov	r4, r7
  40570e:	e4c0      	b.n	405092 <_svfprintf_r+0x8e6>
  405710:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405712:	4a8a      	ldr	r2, [pc, #552]	; (40593c <_svfprintf_r+0x1190>)
  405714:	6022      	str	r2, [r4, #0]
  405716:	3301      	adds	r3, #1
  405718:	f10b 0b01 	add.w	fp, fp, #1
  40571c:	2201      	movs	r2, #1
  40571e:	2b07      	cmp	r3, #7
  405720:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405724:	9324      	str	r3, [sp, #144]	; 0x90
  405726:	6062      	str	r2, [r4, #4]
  405728:	f300 80f4 	bgt.w	405914 <_svfprintf_r+0x1168>
  40572c:	3408      	adds	r4, #8
  40572e:	b92d      	cbnz	r5, 40573c <_svfprintf_r+0xf90>
  405730:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  405732:	b91b      	cbnz	r3, 40573c <_svfprintf_r+0xf90>
  405734:	9b07      	ldr	r3, [sp, #28]
  405736:	07db      	lsls	r3, r3, #31
  405738:	f57f aa32 	bpl.w	404ba0 <_svfprintf_r+0x3f4>
  40573c:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40573e:	9818      	ldr	r0, [sp, #96]	; 0x60
  405740:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  405742:	6022      	str	r2, [r4, #0]
  405744:	3301      	adds	r3, #1
  405746:	eb0b 0100 	add.w	r1, fp, r0
  40574a:	2b07      	cmp	r3, #7
  40574c:	9125      	str	r1, [sp, #148]	; 0x94
  40574e:	6060      	str	r0, [r4, #4]
  405750:	9324      	str	r3, [sp, #144]	; 0x90
  405752:	f300 81f3 	bgt.w	405b3c <_svfprintf_r+0x1390>
  405756:	f104 0208 	add.w	r2, r4, #8
  40575a:	426d      	negs	r5, r5
  40575c:	2d00      	cmp	r5, #0
  40575e:	f340 80fc 	ble.w	40595a <_svfprintf_r+0x11ae>
  405762:	2d10      	cmp	r5, #16
  405764:	f8df 91d8 	ldr.w	r9, [pc, #472]	; 405940 <_svfprintf_r+0x1194>
  405768:	f340 813d 	ble.w	4059e6 <_svfprintf_r+0x123a>
  40576c:	2410      	movs	r4, #16
  40576e:	f8dd 8020 	ldr.w	r8, [sp, #32]
  405772:	e004      	b.n	40577e <_svfprintf_r+0xfd2>
  405774:	3208      	adds	r2, #8
  405776:	3d10      	subs	r5, #16
  405778:	2d10      	cmp	r5, #16
  40577a:	f340 8134 	ble.w	4059e6 <_svfprintf_r+0x123a>
  40577e:	3301      	adds	r3, #1
  405780:	3110      	adds	r1, #16
  405782:	2b07      	cmp	r3, #7
  405784:	9125      	str	r1, [sp, #148]	; 0x94
  405786:	9324      	str	r3, [sp, #144]	; 0x90
  405788:	f8c2 9000 	str.w	r9, [r2]
  40578c:	6054      	str	r4, [r2, #4]
  40578e:	ddf1      	ble.n	405774 <_svfprintf_r+0xfc8>
  405790:	4640      	mov	r0, r8
  405792:	4631      	mov	r1, r6
  405794:	aa23      	add	r2, sp, #140	; 0x8c
  405796:	f002 fdad 	bl	4082f4 <__ssprint_r>
  40579a:	2800      	cmp	r0, #0
  40579c:	f47f a8cc 	bne.w	404938 <_svfprintf_r+0x18c>
  4057a0:	9925      	ldr	r1, [sp, #148]	; 0x94
  4057a2:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4057a4:	463a      	mov	r2, r7
  4057a6:	e7e6      	b.n	405776 <_svfprintf_r+0xfca>
  4057a8:	9b25      	ldr	r3, [sp, #148]	; 0x94
  4057aa:	46b1      	mov	r9, r6
  4057ac:	2b00      	cmp	r3, #0
  4057ae:	f43f a8c4 	beq.w	40493a <_svfprintf_r+0x18e>
  4057b2:	9808      	ldr	r0, [sp, #32]
  4057b4:	4631      	mov	r1, r6
  4057b6:	aa23      	add	r2, sp, #140	; 0x8c
  4057b8:	f002 fd9c 	bl	4082f4 <__ssprint_r>
  4057bc:	f7ff b8bd 	b.w	40493a <_svfprintf_r+0x18e>
  4057c0:	980c      	ldr	r0, [sp, #48]	; 0x30
  4057c2:	910e      	str	r1, [sp, #56]	; 0x38
  4057c4:	4240      	negs	r0, r0
  4057c6:	900c      	str	r0, [sp, #48]	; 0x30
  4057c8:	4619      	mov	r1, r3
  4057ca:	f7ff ba3f 	b.w	404c4c <_svfprintf_r+0x4a0>
  4057ce:	f041 0120 	orr.w	r1, r1, #32
  4057d2:	9107      	str	r1, [sp, #28]
  4057d4:	785d      	ldrb	r5, [r3, #1]
  4057d6:	1c59      	adds	r1, r3, #1
  4057d8:	f7ff b83b 	b.w	404852 <_svfprintf_r+0xa6>
  4057dc:	9808      	ldr	r0, [sp, #32]
  4057de:	4631      	mov	r1, r6
  4057e0:	aa23      	add	r2, sp, #140	; 0x8c
  4057e2:	f002 fd87 	bl	4082f4 <__ssprint_r>
  4057e6:	2800      	cmp	r0, #0
  4057e8:	f47f a8a6 	bne.w	404938 <_svfprintf_r+0x18c>
  4057ec:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  4057f0:	463c      	mov	r4, r7
  4057f2:	e464      	b.n	4050be <_svfprintf_r+0x912>
  4057f4:	f025 0320 	bic.w	r3, r5, #32
  4057f8:	f1ba 3fff 	cmp.w	sl, #4294967295
  4057fc:	930d      	str	r3, [sp, #52]	; 0x34
  4057fe:	f000 8096 	beq.w	40592e <_svfprintf_r+0x1182>
  405802:	2b47      	cmp	r3, #71	; 0x47
  405804:	d105      	bne.n	405812 <_svfprintf_r+0x1066>
  405806:	f1ba 0f00 	cmp.w	sl, #0
  40580a:	bf14      	ite	ne
  40580c:	46d3      	movne	fp, sl
  40580e:	f04f 0b01 	moveq.w	fp, #1
  405812:	9b07      	ldr	r3, [sp, #28]
  405814:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  405818:	9311      	str	r3, [sp, #68]	; 0x44
  40581a:	9b15      	ldr	r3, [sp, #84]	; 0x54
  40581c:	f1b3 0a00 	subs.w	sl, r3, #0
  405820:	9b14      	ldr	r3, [sp, #80]	; 0x50
  405822:	9309      	str	r3, [sp, #36]	; 0x24
  405824:	bfbb      	ittet	lt
  405826:	4653      	movlt	r3, sl
  405828:	f103 4a00 	addlt.w	sl, r3, #2147483648	; 0x80000000
  40582c:	2300      	movge	r3, #0
  40582e:	232d      	movlt	r3, #45	; 0x2d
  405830:	2d66      	cmp	r5, #102	; 0x66
  405832:	930f      	str	r3, [sp, #60]	; 0x3c
  405834:	f000 80ac 	beq.w	405990 <_svfprintf_r+0x11e4>
  405838:	2d46      	cmp	r5, #70	; 0x46
  40583a:	f000 80a9 	beq.w	405990 <_svfprintf_r+0x11e4>
  40583e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  405840:	9a09      	ldr	r2, [sp, #36]	; 0x24
  405842:	2b45      	cmp	r3, #69	; 0x45
  405844:	bf0c      	ite	eq
  405846:	f10b 0901 	addeq.w	r9, fp, #1
  40584a:	46d9      	movne	r9, fp
  40584c:	2002      	movs	r0, #2
  40584e:	a91d      	add	r1, sp, #116	; 0x74
  405850:	e88d 0201 	stmia.w	sp, {r0, r9}
  405854:	9102      	str	r1, [sp, #8]
  405856:	a81e      	add	r0, sp, #120	; 0x78
  405858:	a921      	add	r1, sp, #132	; 0x84
  40585a:	9003      	str	r0, [sp, #12]
  40585c:	4653      	mov	r3, sl
  40585e:	9104      	str	r1, [sp, #16]
  405860:	9808      	ldr	r0, [sp, #32]
  405862:	f000 fa95 	bl	405d90 <_dtoa_r>
  405866:	2d67      	cmp	r5, #103	; 0x67
  405868:	9010      	str	r0, [sp, #64]	; 0x40
  40586a:	d002      	beq.n	405872 <_svfprintf_r+0x10c6>
  40586c:	2d47      	cmp	r5, #71	; 0x47
  40586e:	f040 809f 	bne.w	4059b0 <_svfprintf_r+0x1204>
  405872:	9b07      	ldr	r3, [sp, #28]
  405874:	07db      	lsls	r3, r3, #31
  405876:	f140 8189 	bpl.w	405b8c <_svfprintf_r+0x13e0>
  40587a:	9b10      	ldr	r3, [sp, #64]	; 0x40
  40587c:	eb03 0809 	add.w	r8, r3, r9
  405880:	9809      	ldr	r0, [sp, #36]	; 0x24
  405882:	4651      	mov	r1, sl
  405884:	2200      	movs	r2, #0
  405886:	2300      	movs	r3, #0
  405888:	f003 fae8 	bl	408e5c <__aeabi_dcmpeq>
  40588c:	2800      	cmp	r0, #0
  40588e:	f040 80fd 	bne.w	405a8c <_svfprintf_r+0x12e0>
  405892:	9b21      	ldr	r3, [sp, #132]	; 0x84
  405894:	4598      	cmp	r8, r3
  405896:	d906      	bls.n	4058a6 <_svfprintf_r+0x10fa>
  405898:	2130      	movs	r1, #48	; 0x30
  40589a:	1c5a      	adds	r2, r3, #1
  40589c:	9221      	str	r2, [sp, #132]	; 0x84
  40589e:	7019      	strb	r1, [r3, #0]
  4058a0:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4058a2:	4598      	cmp	r8, r3
  4058a4:	d8f9      	bhi.n	40589a <_svfprintf_r+0x10ee>
  4058a6:	9a10      	ldr	r2, [sp, #64]	; 0x40
  4058a8:	1a9b      	subs	r3, r3, r2
  4058aa:	9313      	str	r3, [sp, #76]	; 0x4c
  4058ac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4058ae:	2b47      	cmp	r3, #71	; 0x47
  4058b0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  4058b2:	f000 80de 	beq.w	405a72 <_svfprintf_r+0x12c6>
  4058b6:	2d65      	cmp	r5, #101	; 0x65
  4058b8:	f340 80f8 	ble.w	405aac <_svfprintf_r+0x1300>
  4058bc:	2d66      	cmp	r5, #102	; 0x66
  4058be:	9312      	str	r3, [sp, #72]	; 0x48
  4058c0:	f000 8157 	beq.w	405b72 <_svfprintf_r+0x13c6>
  4058c4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4058c6:	9a12      	ldr	r2, [sp, #72]	; 0x48
  4058c8:	4293      	cmp	r3, r2
  4058ca:	f300 8144 	bgt.w	405b56 <_svfprintf_r+0x13aa>
  4058ce:	9b07      	ldr	r3, [sp, #28]
  4058d0:	07d9      	lsls	r1, r3, #31
  4058d2:	f100 8173 	bmi.w	405bbc <_svfprintf_r+0x1410>
  4058d6:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  4058da:	920d      	str	r2, [sp, #52]	; 0x34
  4058dc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  4058de:	2a00      	cmp	r2, #0
  4058e0:	f040 80bc 	bne.w	405a5c <_svfprintf_r+0x12b0>
  4058e4:	9309      	str	r3, [sp, #36]	; 0x24
  4058e6:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4058e8:	9307      	str	r3, [sp, #28]
  4058ea:	9211      	str	r2, [sp, #68]	; 0x44
  4058ec:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  4058f0:	f7ff b87c 	b.w	4049ec <_svfprintf_r+0x240>
  4058f4:	9808      	ldr	r0, [sp, #32]
  4058f6:	2140      	movs	r1, #64	; 0x40
  4058f8:	f001 fc4e 	bl	407198 <_malloc_r>
  4058fc:	f8c9 0000 	str.w	r0, [r9]
  405900:	f8c9 0010 	str.w	r0, [r9, #16]
  405904:	2800      	cmp	r0, #0
  405906:	f000 818c 	beq.w	405c22 <_svfprintf_r+0x1476>
  40590a:	2340      	movs	r3, #64	; 0x40
  40590c:	f8c9 3014 	str.w	r3, [r9, #20]
  405910:	f7fe bf64 	b.w	4047dc <_svfprintf_r+0x30>
  405914:	9808      	ldr	r0, [sp, #32]
  405916:	4631      	mov	r1, r6
  405918:	aa23      	add	r2, sp, #140	; 0x8c
  40591a:	f002 fceb 	bl	4082f4 <__ssprint_r>
  40591e:	2800      	cmp	r0, #0
  405920:	f47f a80a 	bne.w	404938 <_svfprintf_r+0x18c>
  405924:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  405926:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40592a:	463c      	mov	r4, r7
  40592c:	e6ff      	b.n	40572e <_svfprintf_r+0xf82>
  40592e:	f04f 0b06 	mov.w	fp, #6
  405932:	e76e      	b.n	405812 <_svfprintf_r+0x1066>
  405934:	00409fe0 	.word	0x00409fe0
  405938:	00409fdc 	.word	0x00409fdc
  40593c:	0040a014 	.word	0x0040a014
  405940:	00409fb4 	.word	0x00409fb4
  405944:	9808      	ldr	r0, [sp, #32]
  405946:	4631      	mov	r1, r6
  405948:	aa23      	add	r2, sp, #140	; 0x8c
  40594a:	f002 fcd3 	bl	4082f4 <__ssprint_r>
  40594e:	2800      	cmp	r0, #0
  405950:	f47e aff2 	bne.w	404938 <_svfprintf_r+0x18c>
  405954:	9925      	ldr	r1, [sp, #148]	; 0x94
  405956:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405958:	463a      	mov	r2, r7
  40595a:	9c13      	ldr	r4, [sp, #76]	; 0x4c
  40595c:	6054      	str	r4, [r2, #4]
  40595e:	3301      	adds	r3, #1
  405960:	eb01 0b04 	add.w	fp, r1, r4
  405964:	2b07      	cmp	r3, #7
  405966:	9910      	ldr	r1, [sp, #64]	; 0x40
  405968:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  40596c:	9324      	str	r3, [sp, #144]	; 0x90
  40596e:	6011      	str	r1, [r2, #0]
  405970:	f73f ac5b 	bgt.w	40522a <_svfprintf_r+0xa7e>
  405974:	f102 0408 	add.w	r4, r2, #8
  405978:	f7ff b912 	b.w	404ba0 <_svfprintf_r+0x3f4>
  40597c:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
  405980:	f7fe fd9e 	bl	4044c0 <strlen>
  405984:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
  405988:	900d      	str	r0, [sp, #52]	; 0x34
  40598a:	4603      	mov	r3, r0
  40598c:	f7ff ba1b 	b.w	404dc6 <_svfprintf_r+0x61a>
  405990:	2003      	movs	r0, #3
  405992:	a91d      	add	r1, sp, #116	; 0x74
  405994:	e88d 0801 	stmia.w	sp, {r0, fp}
  405998:	9102      	str	r1, [sp, #8]
  40599a:	a81e      	add	r0, sp, #120	; 0x78
  40599c:	a921      	add	r1, sp, #132	; 0x84
  40599e:	9003      	str	r0, [sp, #12]
  4059a0:	9a09      	ldr	r2, [sp, #36]	; 0x24
  4059a2:	9104      	str	r1, [sp, #16]
  4059a4:	4653      	mov	r3, sl
  4059a6:	9808      	ldr	r0, [sp, #32]
  4059a8:	f000 f9f2 	bl	405d90 <_dtoa_r>
  4059ac:	46d9      	mov	r9, fp
  4059ae:	9010      	str	r0, [sp, #64]	; 0x40
  4059b0:	9b10      	ldr	r3, [sp, #64]	; 0x40
  4059b2:	eb03 0809 	add.w	r8, r3, r9
  4059b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4059b8:	2b46      	cmp	r3, #70	; 0x46
  4059ba:	f47f af61 	bne.w	405880 <_svfprintf_r+0x10d4>
  4059be:	9b10      	ldr	r3, [sp, #64]	; 0x40
  4059c0:	781b      	ldrb	r3, [r3, #0]
  4059c2:	2b30      	cmp	r3, #48	; 0x30
  4059c4:	f000 80e4 	beq.w	405b90 <_svfprintf_r+0x13e4>
  4059c8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  4059ca:	4498      	add	r8, r3
  4059cc:	e758      	b.n	405880 <_svfprintf_r+0x10d4>
  4059ce:	9808      	ldr	r0, [sp, #32]
  4059d0:	4631      	mov	r1, r6
  4059d2:	aa23      	add	r2, sp, #140	; 0x8c
  4059d4:	f002 fc8e 	bl	4082f4 <__ssprint_r>
  4059d8:	2800      	cmp	r0, #0
  4059da:	f47e afad 	bne.w	404938 <_svfprintf_r+0x18c>
  4059de:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  4059e2:	463c      	mov	r4, r7
  4059e4:	e4a7      	b.n	405336 <_svfprintf_r+0xb8a>
  4059e6:	3301      	adds	r3, #1
  4059e8:	4429      	add	r1, r5
  4059ea:	2b07      	cmp	r3, #7
  4059ec:	9125      	str	r1, [sp, #148]	; 0x94
  4059ee:	9324      	str	r3, [sp, #144]	; 0x90
  4059f0:	f8c2 9000 	str.w	r9, [r2]
  4059f4:	6055      	str	r5, [r2, #4]
  4059f6:	dca5      	bgt.n	405944 <_svfprintf_r+0x1198>
  4059f8:	3208      	adds	r2, #8
  4059fa:	e7ae      	b.n	40595a <_svfprintf_r+0x11ae>
  4059fc:	9808      	ldr	r0, [sp, #32]
  4059fe:	4631      	mov	r1, r6
  405a00:	aa23      	add	r2, sp, #140	; 0x8c
  405a02:	f002 fc77 	bl	4082f4 <__ssprint_r>
  405a06:	2800      	cmp	r0, #0
  405a08:	f47e af96 	bne.w	404938 <_svfprintf_r+0x18c>
  405a0c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  405a0e:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405a12:	463c      	mov	r4, r7
  405a14:	e597      	b.n	405546 <_svfprintf_r+0xd9a>
  405a16:	4653      	mov	r3, sl
  405a18:	2b06      	cmp	r3, #6
  405a1a:	bf28      	it	cs
  405a1c:	2306      	movcs	r3, #6
  405a1e:	930d      	str	r3, [sp, #52]	; 0x34
  405a20:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  405a24:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  405a28:	9309      	str	r3, [sp, #36]	; 0x24
  405a2a:	4b83      	ldr	r3, [pc, #524]	; (405c38 <_svfprintf_r+0x148c>)
  405a2c:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
  405a30:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
  405a34:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
  405a38:	9310      	str	r3, [sp, #64]	; 0x40
  405a3a:	f7fe bfd7 	b.w	4049ec <_svfprintf_r+0x240>
  405a3e:	9808      	ldr	r0, [sp, #32]
  405a40:	4631      	mov	r1, r6
  405a42:	aa23      	add	r2, sp, #140	; 0x8c
  405a44:	f002 fc56 	bl	4082f4 <__ssprint_r>
  405a48:	2800      	cmp	r0, #0
  405a4a:	f47e af75 	bne.w	404938 <_svfprintf_r+0x18c>
  405a4e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  405a50:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  405a52:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405a56:	1ad3      	subs	r3, r2, r3
  405a58:	463c      	mov	r4, r7
  405a5a:	e58a      	b.n	405572 <_svfprintf_r+0xdc6>
  405a5c:	9309      	str	r3, [sp, #36]	; 0x24
  405a5e:	9b11      	ldr	r3, [sp, #68]	; 0x44
  405a60:	9307      	str	r3, [sp, #28]
  405a62:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
  405a66:	2300      	movs	r3, #0
  405a68:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
  405a6c:	9311      	str	r3, [sp, #68]	; 0x44
  405a6e:	f7fe bfc0 	b.w	4049f2 <_svfprintf_r+0x246>
  405a72:	1cda      	adds	r2, r3, #3
  405a74:	db19      	blt.n	405aaa <_svfprintf_r+0x12fe>
  405a76:	459b      	cmp	fp, r3
  405a78:	db17      	blt.n	405aaa <_svfprintf_r+0x12fe>
  405a7a:	9312      	str	r3, [sp, #72]	; 0x48
  405a7c:	2567      	movs	r5, #103	; 0x67
  405a7e:	e721      	b.n	4058c4 <_svfprintf_r+0x1118>
  405a80:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
  405a84:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
  405a88:	f7ff ba98 	b.w	404fbc <_svfprintf_r+0x810>
  405a8c:	4643      	mov	r3, r8
  405a8e:	e70a      	b.n	4058a6 <_svfprintf_r+0x10fa>
  405a90:	ea2a 73ea 	bic.w	r3, sl, sl, asr #31
  405a94:	9011      	str	r0, [sp, #68]	; 0x44
  405a96:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
  405a9a:	9012      	str	r0, [sp, #72]	; 0x48
  405a9c:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  405aa0:	9309      	str	r3, [sp, #36]	; 0x24
  405aa2:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
  405aa6:	f7fe bfa1 	b.w	4049ec <_svfprintf_r+0x240>
  405aaa:	3d02      	subs	r5, #2
  405aac:	3b01      	subs	r3, #1
  405aae:	2b00      	cmp	r3, #0
  405ab0:	931d      	str	r3, [sp, #116]	; 0x74
  405ab2:	bfba      	itte	lt
  405ab4:	425b      	neglt	r3, r3
  405ab6:	222d      	movlt	r2, #45	; 0x2d
  405ab8:	222b      	movge	r2, #43	; 0x2b
  405aba:	2b09      	cmp	r3, #9
  405abc:	f88d 507c 	strb.w	r5, [sp, #124]	; 0x7c
  405ac0:	f88d 207d 	strb.w	r2, [sp, #125]	; 0x7d
  405ac4:	dd72      	ble.n	405bac <_svfprintf_r+0x1400>
  405ac6:	f10d 0e8b 	add.w	lr, sp, #139	; 0x8b
  405aca:	4670      	mov	r0, lr
  405acc:	4a5b      	ldr	r2, [pc, #364]	; (405c3c <_svfprintf_r+0x1490>)
  405ace:	fb82 2103 	smull	r2, r1, r2, r3
  405ad2:	17da      	asrs	r2, r3, #31
  405ad4:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
  405ad8:	eb02 0182 	add.w	r1, r2, r2, lsl #2
  405adc:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
  405ae0:	f103 0130 	add.w	r1, r3, #48	; 0x30
  405ae4:	2a09      	cmp	r2, #9
  405ae6:	4613      	mov	r3, r2
  405ae8:	f800 1d01 	strb.w	r1, [r0, #-1]!
  405aec:	dcee      	bgt.n	405acc <_svfprintf_r+0x1320>
  405aee:	4602      	mov	r2, r0
  405af0:	3330      	adds	r3, #48	; 0x30
  405af2:	b2d9      	uxtb	r1, r3
  405af4:	f802 1d01 	strb.w	r1, [r2, #-1]!
  405af8:	4596      	cmp	lr, r2
  405afa:	f240 8099 	bls.w	405c30 <_svfprintf_r+0x1484>
  405afe:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
  405b02:	4603      	mov	r3, r0
  405b04:	e001      	b.n	405b0a <_svfprintf_r+0x135e>
  405b06:	f813 1b01 	ldrb.w	r1, [r3], #1
  405b0a:	f802 1b01 	strb.w	r1, [r2], #1
  405b0e:	4573      	cmp	r3, lr
  405b10:	d1f9      	bne.n	405b06 <_svfprintf_r+0x135a>
  405b12:	ab23      	add	r3, sp, #140	; 0x8c
  405b14:	1a1b      	subs	r3, r3, r0
  405b16:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
  405b1a:	4413      	add	r3, r2
  405b1c:	aa1f      	add	r2, sp, #124	; 0x7c
  405b1e:	1a9b      	subs	r3, r3, r2
  405b20:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  405b22:	9319      	str	r3, [sp, #100]	; 0x64
  405b24:	2a01      	cmp	r2, #1
  405b26:	4413      	add	r3, r2
  405b28:	930d      	str	r3, [sp, #52]	; 0x34
  405b2a:	dd6b      	ble.n	405c04 <_svfprintf_r+0x1458>
  405b2c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  405b2e:	2200      	movs	r2, #0
  405b30:	3301      	adds	r3, #1
  405b32:	930d      	str	r3, [sp, #52]	; 0x34
  405b34:	9212      	str	r2, [sp, #72]	; 0x48
  405b36:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  405b3a:	e6cf      	b.n	4058dc <_svfprintf_r+0x1130>
  405b3c:	9808      	ldr	r0, [sp, #32]
  405b3e:	4631      	mov	r1, r6
  405b40:	aa23      	add	r2, sp, #140	; 0x8c
  405b42:	f002 fbd7 	bl	4082f4 <__ssprint_r>
  405b46:	2800      	cmp	r0, #0
  405b48:	f47e aef6 	bne.w	404938 <_svfprintf_r+0x18c>
  405b4c:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  405b4e:	9925      	ldr	r1, [sp, #148]	; 0x94
  405b50:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405b52:	463a      	mov	r2, r7
  405b54:	e601      	b.n	40575a <_svfprintf_r+0xfae>
  405b56:	9b12      	ldr	r3, [sp, #72]	; 0x48
  405b58:	2b00      	cmp	r3, #0
  405b5a:	bfd8      	it	le
  405b5c:	f1c3 0802 	rsble	r8, r3, #2
  405b60:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  405b62:	bfc8      	it	gt
  405b64:	f04f 0801 	movgt.w	r8, #1
  405b68:	4443      	add	r3, r8
  405b6a:	930d      	str	r3, [sp, #52]	; 0x34
  405b6c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  405b70:	e6b4      	b.n	4058dc <_svfprintf_r+0x1130>
  405b72:	2b00      	cmp	r3, #0
  405b74:	dd30      	ble.n	405bd8 <_svfprintf_r+0x142c>
  405b76:	f1bb 0f00 	cmp.w	fp, #0
  405b7a:	d125      	bne.n	405bc8 <_svfprintf_r+0x141c>
  405b7c:	9b07      	ldr	r3, [sp, #28]
  405b7e:	07db      	lsls	r3, r3, #31
  405b80:	d422      	bmi.n	405bc8 <_svfprintf_r+0x141c>
  405b82:	9a12      	ldr	r2, [sp, #72]	; 0x48
  405b84:	920d      	str	r2, [sp, #52]	; 0x34
  405b86:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  405b8a:	e6a7      	b.n	4058dc <_svfprintf_r+0x1130>
  405b8c:	9b21      	ldr	r3, [sp, #132]	; 0x84
  405b8e:	e68a      	b.n	4058a6 <_svfprintf_r+0x10fa>
  405b90:	9809      	ldr	r0, [sp, #36]	; 0x24
  405b92:	4651      	mov	r1, sl
  405b94:	2200      	movs	r2, #0
  405b96:	2300      	movs	r3, #0
  405b98:	f003 f960 	bl	408e5c <__aeabi_dcmpeq>
  405b9c:	2800      	cmp	r0, #0
  405b9e:	f47f af13 	bne.w	4059c8 <_svfprintf_r+0x121c>
  405ba2:	f1c9 0301 	rsb	r3, r9, #1
  405ba6:	931d      	str	r3, [sp, #116]	; 0x74
  405ba8:	4498      	add	r8, r3
  405baa:	e669      	b.n	405880 <_svfprintf_r+0x10d4>
  405bac:	3330      	adds	r3, #48	; 0x30
  405bae:	2230      	movs	r2, #48	; 0x30
  405bb0:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
  405bb4:	f88d 207e 	strb.w	r2, [sp, #126]	; 0x7e
  405bb8:	ab20      	add	r3, sp, #128	; 0x80
  405bba:	e7af      	b.n	405b1c <_svfprintf_r+0x1370>
  405bbc:	9b12      	ldr	r3, [sp, #72]	; 0x48
  405bbe:	3301      	adds	r3, #1
  405bc0:	930d      	str	r3, [sp, #52]	; 0x34
  405bc2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  405bc6:	e689      	b.n	4058dc <_svfprintf_r+0x1130>
  405bc8:	9b12      	ldr	r3, [sp, #72]	; 0x48
  405bca:	f10b 0801 	add.w	r8, fp, #1
  405bce:	4443      	add	r3, r8
  405bd0:	930d      	str	r3, [sp, #52]	; 0x34
  405bd2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  405bd6:	e681      	b.n	4058dc <_svfprintf_r+0x1130>
  405bd8:	f1bb 0f00 	cmp.w	fp, #0
  405bdc:	d11b      	bne.n	405c16 <_svfprintf_r+0x146a>
  405bde:	9b07      	ldr	r3, [sp, #28]
  405be0:	07d8      	lsls	r0, r3, #31
  405be2:	d418      	bmi.n	405c16 <_svfprintf_r+0x146a>
  405be4:	2301      	movs	r3, #1
  405be6:	930d      	str	r3, [sp, #52]	; 0x34
  405be8:	e678      	b.n	4058dc <_svfprintf_r+0x1130>
  405bea:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  405bec:	f8d5 a000 	ldr.w	sl, [r5]
  405bf0:	4628      	mov	r0, r5
  405bf2:	3004      	adds	r0, #4
  405bf4:	f1ba 0f00 	cmp.w	sl, #0
  405bf8:	785d      	ldrb	r5, [r3, #1]
  405bfa:	900e      	str	r0, [sp, #56]	; 0x38
  405bfc:	f6be ae29 	bge.w	404852 <_svfprintf_r+0xa6>
  405c00:	f7fe be25 	b.w	40484e <_svfprintf_r+0xa2>
  405c04:	9b07      	ldr	r3, [sp, #28]
  405c06:	f013 0301 	ands.w	r3, r3, #1
  405c0a:	d18f      	bne.n	405b2c <_svfprintf_r+0x1380>
  405c0c:	9312      	str	r3, [sp, #72]	; 0x48
  405c0e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  405c10:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  405c14:	e662      	b.n	4058dc <_svfprintf_r+0x1130>
  405c16:	f10b 0302 	add.w	r3, fp, #2
  405c1a:	930d      	str	r3, [sp, #52]	; 0x34
  405c1c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  405c20:	e65c      	b.n	4058dc <_svfprintf_r+0x1130>
  405c22:	9a08      	ldr	r2, [sp, #32]
  405c24:	230c      	movs	r3, #12
  405c26:	6013      	str	r3, [r2, #0]
  405c28:	f04f 30ff 	mov.w	r0, #4294967295
  405c2c:	f7fe be8e 	b.w	40494c <_svfprintf_r+0x1a0>
  405c30:	f10d 037e 	add.w	r3, sp, #126	; 0x7e
  405c34:	e772      	b.n	405b1c <_svfprintf_r+0x1370>
  405c36:	bf00      	nop
  405c38:	0040a00c 	.word	0x0040a00c
  405c3c:	66666667 	.word	0x66666667

00405c40 <register_fini>:
  405c40:	4b02      	ldr	r3, [pc, #8]	; (405c4c <register_fini+0xc>)
  405c42:	b113      	cbz	r3, 405c4a <register_fini+0xa>
  405c44:	4802      	ldr	r0, [pc, #8]	; (405c50 <register_fini+0x10>)
  405c46:	f000 b805 	b.w	405c54 <atexit>
  405c4a:	4770      	bx	lr
  405c4c:	00000000 	.word	0x00000000
  405c50:	00406eb5 	.word	0x00406eb5

00405c54 <atexit>:
  405c54:	4601      	mov	r1, r0
  405c56:	2000      	movs	r0, #0
  405c58:	4602      	mov	r2, r0
  405c5a:	4603      	mov	r3, r0
  405c5c:	f002 bbe0 	b.w	408420 <__register_exitproc>

00405c60 <quorem>:
  405c60:	6902      	ldr	r2, [r0, #16]
  405c62:	690b      	ldr	r3, [r1, #16]
  405c64:	4293      	cmp	r3, r2
  405c66:	f300 808f 	bgt.w	405d88 <quorem+0x128>
  405c6a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405c6e:	f103 38ff 	add.w	r8, r3, #4294967295
  405c72:	f101 0714 	add.w	r7, r1, #20
  405c76:	f100 0b14 	add.w	fp, r0, #20
  405c7a:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
  405c7e:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
  405c82:	ea4f 0488 	mov.w	r4, r8, lsl #2
  405c86:	b083      	sub	sp, #12
  405c88:	3201      	adds	r2, #1
  405c8a:	fbb3 f9f2 	udiv	r9, r3, r2
  405c8e:	eb0b 0304 	add.w	r3, fp, r4
  405c92:	9400      	str	r4, [sp, #0]
  405c94:	eb07 0a04 	add.w	sl, r7, r4
  405c98:	9301      	str	r3, [sp, #4]
  405c9a:	f1b9 0f00 	cmp.w	r9, #0
  405c9e:	d03b      	beq.n	405d18 <quorem+0xb8>
  405ca0:	2600      	movs	r6, #0
  405ca2:	4632      	mov	r2, r6
  405ca4:	46bc      	mov	ip, r7
  405ca6:	46de      	mov	lr, fp
  405ca8:	4634      	mov	r4, r6
  405caa:	f85c 6b04 	ldr.w	r6, [ip], #4
  405cae:	f8de 5000 	ldr.w	r5, [lr]
  405cb2:	b2b3      	uxth	r3, r6
  405cb4:	0c36      	lsrs	r6, r6, #16
  405cb6:	fb03 4409 	mla	r4, r3, r9, r4
  405cba:	fb06 f609 	mul.w	r6, r6, r9
  405cbe:	eb06 4614 	add.w	r6, r6, r4, lsr #16
  405cc2:	b2a3      	uxth	r3, r4
  405cc4:	1ad3      	subs	r3, r2, r3
  405cc6:	b2b4      	uxth	r4, r6
  405cc8:	fa13 f385 	uxtah	r3, r3, r5
  405ccc:	ebc4 4415 	rsb	r4, r4, r5, lsr #16
  405cd0:	eb04 4423 	add.w	r4, r4, r3, asr #16
  405cd4:	b29b      	uxth	r3, r3
  405cd6:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  405cda:	45e2      	cmp	sl, ip
  405cdc:	ea4f 4224 	mov.w	r2, r4, asr #16
  405ce0:	f84e 3b04 	str.w	r3, [lr], #4
  405ce4:	ea4f 4416 	mov.w	r4, r6, lsr #16
  405ce8:	d2df      	bcs.n	405caa <quorem+0x4a>
  405cea:	9b00      	ldr	r3, [sp, #0]
  405cec:	f85b 3003 	ldr.w	r3, [fp, r3]
  405cf0:	b993      	cbnz	r3, 405d18 <quorem+0xb8>
  405cf2:	9c01      	ldr	r4, [sp, #4]
  405cf4:	1f23      	subs	r3, r4, #4
  405cf6:	459b      	cmp	fp, r3
  405cf8:	d20c      	bcs.n	405d14 <quorem+0xb4>
  405cfa:	f854 3c04 	ldr.w	r3, [r4, #-4]
  405cfe:	b94b      	cbnz	r3, 405d14 <quorem+0xb4>
  405d00:	f1a4 0308 	sub.w	r3, r4, #8
  405d04:	e002      	b.n	405d0c <quorem+0xac>
  405d06:	681a      	ldr	r2, [r3, #0]
  405d08:	3b04      	subs	r3, #4
  405d0a:	b91a      	cbnz	r2, 405d14 <quorem+0xb4>
  405d0c:	459b      	cmp	fp, r3
  405d0e:	f108 38ff 	add.w	r8, r8, #4294967295
  405d12:	d3f8      	bcc.n	405d06 <quorem+0xa6>
  405d14:	f8c0 8010 	str.w	r8, [r0, #16]
  405d18:	4604      	mov	r4, r0
  405d1a:	f001 ff8b 	bl	407c34 <__mcmp>
  405d1e:	2800      	cmp	r0, #0
  405d20:	db2e      	blt.n	405d80 <quorem+0x120>
  405d22:	f109 0901 	add.w	r9, r9, #1
  405d26:	465d      	mov	r5, fp
  405d28:	2300      	movs	r3, #0
  405d2a:	f857 1b04 	ldr.w	r1, [r7], #4
  405d2e:	6828      	ldr	r0, [r5, #0]
  405d30:	b28a      	uxth	r2, r1
  405d32:	1a9a      	subs	r2, r3, r2
  405d34:	0c09      	lsrs	r1, r1, #16
  405d36:	fa12 f280 	uxtah	r2, r2, r0
  405d3a:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
  405d3e:	eb03 4322 	add.w	r3, r3, r2, asr #16
  405d42:	b291      	uxth	r1, r2
  405d44:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  405d48:	45ba      	cmp	sl, r7
  405d4a:	f845 1b04 	str.w	r1, [r5], #4
  405d4e:	ea4f 4323 	mov.w	r3, r3, asr #16
  405d52:	d2ea      	bcs.n	405d2a <quorem+0xca>
  405d54:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
  405d58:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
  405d5c:	b982      	cbnz	r2, 405d80 <quorem+0x120>
  405d5e:	1f1a      	subs	r2, r3, #4
  405d60:	4593      	cmp	fp, r2
  405d62:	d20b      	bcs.n	405d7c <quorem+0x11c>
  405d64:	f853 2c04 	ldr.w	r2, [r3, #-4]
  405d68:	b942      	cbnz	r2, 405d7c <quorem+0x11c>
  405d6a:	3b08      	subs	r3, #8
  405d6c:	e002      	b.n	405d74 <quorem+0x114>
  405d6e:	681a      	ldr	r2, [r3, #0]
  405d70:	3b04      	subs	r3, #4
  405d72:	b91a      	cbnz	r2, 405d7c <quorem+0x11c>
  405d74:	459b      	cmp	fp, r3
  405d76:	f108 38ff 	add.w	r8, r8, #4294967295
  405d7a:	d3f8      	bcc.n	405d6e <quorem+0x10e>
  405d7c:	f8c4 8010 	str.w	r8, [r4, #16]
  405d80:	4648      	mov	r0, r9
  405d82:	b003      	add	sp, #12
  405d84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405d88:	2000      	movs	r0, #0
  405d8a:	4770      	bx	lr
  405d8c:	0000      	movs	r0, r0
	...

00405d90 <_dtoa_r>:
  405d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405d94:	6c01      	ldr	r1, [r0, #64]	; 0x40
  405d96:	b097      	sub	sp, #92	; 0x5c
  405d98:	4604      	mov	r4, r0
  405d9a:	9d23      	ldr	r5, [sp, #140]	; 0x8c
  405d9c:	e9cd 2302 	strd	r2, r3, [sp, #8]
  405da0:	b141      	cbz	r1, 405db4 <_dtoa_r+0x24>
  405da2:	6c42      	ldr	r2, [r0, #68]	; 0x44
  405da4:	604a      	str	r2, [r1, #4]
  405da6:	2301      	movs	r3, #1
  405da8:	4093      	lsls	r3, r2
  405daa:	608b      	str	r3, [r1, #8]
  405dac:	f001 fd5e 	bl	40786c <_Bfree>
  405db0:	2300      	movs	r3, #0
  405db2:	6423      	str	r3, [r4, #64]	; 0x40
  405db4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  405db8:	2b00      	cmp	r3, #0
  405dba:	4699      	mov	r9, r3
  405dbc:	db36      	blt.n	405e2c <_dtoa_r+0x9c>
  405dbe:	2300      	movs	r3, #0
  405dc0:	602b      	str	r3, [r5, #0]
  405dc2:	4ba5      	ldr	r3, [pc, #660]	; (406058 <_dtoa_r+0x2c8>)
  405dc4:	461a      	mov	r2, r3
  405dc6:	ea09 0303 	and.w	r3, r9, r3
  405dca:	4293      	cmp	r3, r2
  405dcc:	d017      	beq.n	405dfe <_dtoa_r+0x6e>
  405dce:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  405dd2:	2200      	movs	r2, #0
  405dd4:	4630      	mov	r0, r6
  405dd6:	4639      	mov	r1, r7
  405dd8:	2300      	movs	r3, #0
  405dda:	f003 f83f 	bl	408e5c <__aeabi_dcmpeq>
  405dde:	4680      	mov	r8, r0
  405de0:	2800      	cmp	r0, #0
  405de2:	d02b      	beq.n	405e3c <_dtoa_r+0xac>
  405de4:	9a22      	ldr	r2, [sp, #136]	; 0x88
  405de6:	2301      	movs	r3, #1
  405de8:	6013      	str	r3, [r2, #0]
  405dea:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405dec:	2b00      	cmp	r3, #0
  405dee:	f000 80cb 	beq.w	405f88 <_dtoa_r+0x1f8>
  405df2:	489a      	ldr	r0, [pc, #616]	; (40605c <_dtoa_r+0x2cc>)
  405df4:	6018      	str	r0, [r3, #0]
  405df6:	3801      	subs	r0, #1
  405df8:	b017      	add	sp, #92	; 0x5c
  405dfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405dfe:	9a22      	ldr	r2, [sp, #136]	; 0x88
  405e00:	f242 730f 	movw	r3, #9999	; 0x270f
  405e04:	6013      	str	r3, [r2, #0]
  405e06:	9b02      	ldr	r3, [sp, #8]
  405e08:	2b00      	cmp	r3, #0
  405e0a:	f000 80a6 	beq.w	405f5a <_dtoa_r+0x1ca>
  405e0e:	4894      	ldr	r0, [pc, #592]	; (406060 <_dtoa_r+0x2d0>)
  405e10:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405e12:	2b00      	cmp	r3, #0
  405e14:	d0f0      	beq.n	405df8 <_dtoa_r+0x68>
  405e16:	78c3      	ldrb	r3, [r0, #3]
  405e18:	2b00      	cmp	r3, #0
  405e1a:	f000 80b7 	beq.w	405f8c <_dtoa_r+0x1fc>
  405e1e:	f100 0308 	add.w	r3, r0, #8
  405e22:	9a24      	ldr	r2, [sp, #144]	; 0x90
  405e24:	6013      	str	r3, [r2, #0]
  405e26:	b017      	add	sp, #92	; 0x5c
  405e28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405e2c:	9a03      	ldr	r2, [sp, #12]
  405e2e:	2301      	movs	r3, #1
  405e30:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
  405e34:	602b      	str	r3, [r5, #0]
  405e36:	f8cd 900c 	str.w	r9, [sp, #12]
  405e3a:	e7c2      	b.n	405dc2 <_dtoa_r+0x32>
  405e3c:	aa15      	add	r2, sp, #84	; 0x54
  405e3e:	ab14      	add	r3, sp, #80	; 0x50
  405e40:	e88d 000c 	stmia.w	sp, {r2, r3}
  405e44:	4620      	mov	r0, r4
  405e46:	4632      	mov	r2, r6
  405e48:	463b      	mov	r3, r7
  405e4a:	f001 ff81 	bl	407d50 <__d2b>
  405e4e:	ea5f 5519 	movs.w	r5, r9, lsr #20
  405e52:	4683      	mov	fp, r0
  405e54:	f040 808a 	bne.w	405f6c <_dtoa_r+0x1dc>
  405e58:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  405e5c:	9d15      	ldr	r5, [sp, #84]	; 0x54
  405e5e:	f46f 6382 	mvn.w	r3, #1040	; 0x410
  405e62:	4445      	add	r5, r8
  405e64:	429d      	cmp	r5, r3
  405e66:	f2c0 8297 	blt.w	406398 <_dtoa_r+0x608>
  405e6a:	4a7e      	ldr	r2, [pc, #504]	; (406064 <_dtoa_r+0x2d4>)
  405e6c:	1b52      	subs	r2, r2, r5
  405e6e:	fa09 f902 	lsl.w	r9, r9, r2
  405e72:	9a02      	ldr	r2, [sp, #8]
  405e74:	f205 4312 	addw	r3, r5, #1042	; 0x412
  405e78:	fa22 f003 	lsr.w	r0, r2, r3
  405e7c:	ea49 0000 	orr.w	r0, r9, r0
  405e80:	f002 fd0e 	bl	4088a0 <__aeabi_ui2d>
  405e84:	2301      	movs	r3, #1
  405e86:	3d01      	subs	r5, #1
  405e88:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
  405e8c:	930d      	str	r3, [sp, #52]	; 0x34
  405e8e:	2200      	movs	r2, #0
  405e90:	4b75      	ldr	r3, [pc, #468]	; (406068 <_dtoa_r+0x2d8>)
  405e92:	f002 fbc7 	bl	408624 <__aeabi_dsub>
  405e96:	a36a      	add	r3, pc, #424	; (adr r3, 406040 <_dtoa_r+0x2b0>)
  405e98:	e9d3 2300 	ldrd	r2, r3, [r3]
  405e9c:	f002 fd76 	bl	40898c <__aeabi_dmul>
  405ea0:	a369      	add	r3, pc, #420	; (adr r3, 406048 <_dtoa_r+0x2b8>)
  405ea2:	e9d3 2300 	ldrd	r2, r3, [r3]
  405ea6:	f002 fbbf 	bl	408628 <__adddf3>
  405eaa:	4606      	mov	r6, r0
  405eac:	4628      	mov	r0, r5
  405eae:	460f      	mov	r7, r1
  405eb0:	f002 fd06 	bl	4088c0 <__aeabi_i2d>
  405eb4:	a366      	add	r3, pc, #408	; (adr r3, 406050 <_dtoa_r+0x2c0>)
  405eb6:	e9d3 2300 	ldrd	r2, r3, [r3]
  405eba:	f002 fd67 	bl	40898c <__aeabi_dmul>
  405ebe:	4602      	mov	r2, r0
  405ec0:	460b      	mov	r3, r1
  405ec2:	4630      	mov	r0, r6
  405ec4:	4639      	mov	r1, r7
  405ec6:	f002 fbaf 	bl	408628 <__adddf3>
  405eca:	4606      	mov	r6, r0
  405ecc:	460f      	mov	r7, r1
  405ece:	f002 fff7 	bl	408ec0 <__aeabi_d2iz>
  405ed2:	4639      	mov	r1, r7
  405ed4:	9004      	str	r0, [sp, #16]
  405ed6:	2200      	movs	r2, #0
  405ed8:	4630      	mov	r0, r6
  405eda:	2300      	movs	r3, #0
  405edc:	f002 ffc8 	bl	408e70 <__aeabi_dcmplt>
  405ee0:	2800      	cmp	r0, #0
  405ee2:	f040 81a6 	bne.w	406232 <_dtoa_r+0x4a2>
  405ee6:	9b04      	ldr	r3, [sp, #16]
  405ee8:	2b16      	cmp	r3, #22
  405eea:	f200 819f 	bhi.w	40622c <_dtoa_r+0x49c>
  405eee:	9a04      	ldr	r2, [sp, #16]
  405ef0:	4b5e      	ldr	r3, [pc, #376]	; (40606c <_dtoa_r+0x2dc>)
  405ef2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  405ef6:	e9d3 0100 	ldrd	r0, r1, [r3]
  405efa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  405efe:	f002 ffd5 	bl	408eac <__aeabi_dcmpgt>
  405f02:	2800      	cmp	r0, #0
  405f04:	f000 824e 	beq.w	4063a4 <_dtoa_r+0x614>
  405f08:	9b04      	ldr	r3, [sp, #16]
  405f0a:	3b01      	subs	r3, #1
  405f0c:	9304      	str	r3, [sp, #16]
  405f0e:	2300      	movs	r3, #0
  405f10:	930b      	str	r3, [sp, #44]	; 0x2c
  405f12:	ebc5 0508 	rsb	r5, r5, r8
  405f16:	f1b5 0a01 	subs.w	sl, r5, #1
  405f1a:	f100 81a1 	bmi.w	406260 <_dtoa_r+0x4d0>
  405f1e:	2300      	movs	r3, #0
  405f20:	9305      	str	r3, [sp, #20]
  405f22:	9b04      	ldr	r3, [sp, #16]
  405f24:	2b00      	cmp	r3, #0
  405f26:	f2c0 8192 	blt.w	40624e <_dtoa_r+0x4be>
  405f2a:	449a      	add	sl, r3
  405f2c:	930a      	str	r3, [sp, #40]	; 0x28
  405f2e:	2300      	movs	r3, #0
  405f30:	9308      	str	r3, [sp, #32]
  405f32:	9b20      	ldr	r3, [sp, #128]	; 0x80
  405f34:	2b09      	cmp	r3, #9
  405f36:	d82b      	bhi.n	405f90 <_dtoa_r+0x200>
  405f38:	2b05      	cmp	r3, #5
  405f3a:	f340 8670 	ble.w	406c1e <_dtoa_r+0xe8e>
  405f3e:	3b04      	subs	r3, #4
  405f40:	9320      	str	r3, [sp, #128]	; 0x80
  405f42:	2500      	movs	r5, #0
  405f44:	9b20      	ldr	r3, [sp, #128]	; 0x80
  405f46:	3b02      	subs	r3, #2
  405f48:	2b03      	cmp	r3, #3
  405f4a:	f200 864e 	bhi.w	406bea <_dtoa_r+0xe5a>
  405f4e:	e8df f013 	tbh	[pc, r3, lsl #1]
  405f52:	03cc      	.short	0x03cc
  405f54:	02b203be 	.word	0x02b203be
  405f58:	0663      	.short	0x0663
  405f5a:	4b41      	ldr	r3, [pc, #260]	; (406060 <_dtoa_r+0x2d0>)
  405f5c:	4a44      	ldr	r2, [pc, #272]	; (406070 <_dtoa_r+0x2e0>)
  405f5e:	f3c9 0013 	ubfx	r0, r9, #0, #20
  405f62:	2800      	cmp	r0, #0
  405f64:	bf14      	ite	ne
  405f66:	4618      	movne	r0, r3
  405f68:	4610      	moveq	r0, r2
  405f6a:	e751      	b.n	405e10 <_dtoa_r+0x80>
  405f6c:	f3c7 0313 	ubfx	r3, r7, #0, #20
  405f70:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
  405f74:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
  405f78:	4630      	mov	r0, r6
  405f7a:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
  405f7e:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  405f82:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  405f86:	e782      	b.n	405e8e <_dtoa_r+0xfe>
  405f88:	483a      	ldr	r0, [pc, #232]	; (406074 <_dtoa_r+0x2e4>)
  405f8a:	e735      	b.n	405df8 <_dtoa_r+0x68>
  405f8c:	1cc3      	adds	r3, r0, #3
  405f8e:	e748      	b.n	405e22 <_dtoa_r+0x92>
  405f90:	2100      	movs	r1, #0
  405f92:	6461      	str	r1, [r4, #68]	; 0x44
  405f94:	4620      	mov	r0, r4
  405f96:	9120      	str	r1, [sp, #128]	; 0x80
  405f98:	f001 fc42 	bl	407820 <_Balloc>
  405f9c:	f04f 33ff 	mov.w	r3, #4294967295
  405fa0:	9306      	str	r3, [sp, #24]
  405fa2:	9a20      	ldr	r2, [sp, #128]	; 0x80
  405fa4:	930c      	str	r3, [sp, #48]	; 0x30
  405fa6:	2301      	movs	r3, #1
  405fa8:	9007      	str	r0, [sp, #28]
  405faa:	9221      	str	r2, [sp, #132]	; 0x84
  405fac:	6420      	str	r0, [r4, #64]	; 0x40
  405fae:	9309      	str	r3, [sp, #36]	; 0x24
  405fb0:	9b15      	ldr	r3, [sp, #84]	; 0x54
  405fb2:	2b00      	cmp	r3, #0
  405fb4:	f2c0 80d2 	blt.w	40615c <_dtoa_r+0x3cc>
  405fb8:	9a04      	ldr	r2, [sp, #16]
  405fba:	2a0e      	cmp	r2, #14
  405fbc:	f300 80ce 	bgt.w	40615c <_dtoa_r+0x3cc>
  405fc0:	4b2a      	ldr	r3, [pc, #168]	; (40606c <_dtoa_r+0x2dc>)
  405fc2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  405fc6:	e9d3 8900 	ldrd	r8, r9, [r3]
  405fca:	9b21      	ldr	r3, [sp, #132]	; 0x84
  405fcc:	2b00      	cmp	r3, #0
  405fce:	f2c0 838f 	blt.w	4066f0 <_dtoa_r+0x960>
  405fd2:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  405fd6:	4642      	mov	r2, r8
  405fd8:	464b      	mov	r3, r9
  405fda:	4630      	mov	r0, r6
  405fdc:	4639      	mov	r1, r7
  405fde:	f002 fdff 	bl	408be0 <__aeabi_ddiv>
  405fe2:	f002 ff6d 	bl	408ec0 <__aeabi_d2iz>
  405fe6:	4682      	mov	sl, r0
  405fe8:	f002 fc6a 	bl	4088c0 <__aeabi_i2d>
  405fec:	4642      	mov	r2, r8
  405fee:	464b      	mov	r3, r9
  405ff0:	f002 fccc 	bl	40898c <__aeabi_dmul>
  405ff4:	460b      	mov	r3, r1
  405ff6:	4602      	mov	r2, r0
  405ff8:	4639      	mov	r1, r7
  405ffa:	4630      	mov	r0, r6
  405ffc:	f002 fb12 	bl	408624 <__aeabi_dsub>
  406000:	9d07      	ldr	r5, [sp, #28]
  406002:	f10a 0330 	add.w	r3, sl, #48	; 0x30
  406006:	702b      	strb	r3, [r5, #0]
  406008:	9b06      	ldr	r3, [sp, #24]
  40600a:	2b01      	cmp	r3, #1
  40600c:	4606      	mov	r6, r0
  40600e:	460f      	mov	r7, r1
  406010:	f105 0501 	add.w	r5, r5, #1
  406014:	d062      	beq.n	4060dc <_dtoa_r+0x34c>
  406016:	2200      	movs	r2, #0
  406018:	4b17      	ldr	r3, [pc, #92]	; (406078 <_dtoa_r+0x2e8>)
  40601a:	f002 fcb7 	bl	40898c <__aeabi_dmul>
  40601e:	2200      	movs	r2, #0
  406020:	2300      	movs	r3, #0
  406022:	4606      	mov	r6, r0
  406024:	460f      	mov	r7, r1
  406026:	f002 ff19 	bl	408e5c <__aeabi_dcmpeq>
  40602a:	2800      	cmp	r0, #0
  40602c:	f040 8083 	bne.w	406136 <_dtoa_r+0x3a6>
  406030:	f8cd b008 	str.w	fp, [sp, #8]
  406034:	9405      	str	r4, [sp, #20]
  406036:	f8dd b01c 	ldr.w	fp, [sp, #28]
  40603a:	9c06      	ldr	r4, [sp, #24]
  40603c:	e029      	b.n	406092 <_dtoa_r+0x302>
  40603e:	bf00      	nop
  406040:	636f4361 	.word	0x636f4361
  406044:	3fd287a7 	.word	0x3fd287a7
  406048:	8b60c8b3 	.word	0x8b60c8b3
  40604c:	3fc68a28 	.word	0x3fc68a28
  406050:	509f79fb 	.word	0x509f79fb
  406054:	3fd34413 	.word	0x3fd34413
  406058:	7ff00000 	.word	0x7ff00000
  40605c:	0040a015 	.word	0x0040a015
  406060:	0040a128 	.word	0x0040a128
  406064:	fffffc0e 	.word	0xfffffc0e
  406068:	3ff80000 	.word	0x3ff80000
  40606c:	0040a138 	.word	0x0040a138
  406070:	0040a11c 	.word	0x0040a11c
  406074:	0040a014 	.word	0x0040a014
  406078:	40240000 	.word	0x40240000
  40607c:	f002 fc86 	bl	40898c <__aeabi_dmul>
  406080:	2200      	movs	r2, #0
  406082:	2300      	movs	r3, #0
  406084:	4606      	mov	r6, r0
  406086:	460f      	mov	r7, r1
  406088:	f002 fee8 	bl	408e5c <__aeabi_dcmpeq>
  40608c:	2800      	cmp	r0, #0
  40608e:	f040 83de 	bne.w	40684e <_dtoa_r+0xabe>
  406092:	4642      	mov	r2, r8
  406094:	464b      	mov	r3, r9
  406096:	4630      	mov	r0, r6
  406098:	4639      	mov	r1, r7
  40609a:	f002 fda1 	bl	408be0 <__aeabi_ddiv>
  40609e:	f002 ff0f 	bl	408ec0 <__aeabi_d2iz>
  4060a2:	4682      	mov	sl, r0
  4060a4:	f002 fc0c 	bl	4088c0 <__aeabi_i2d>
  4060a8:	4642      	mov	r2, r8
  4060aa:	464b      	mov	r3, r9
  4060ac:	f002 fc6e 	bl	40898c <__aeabi_dmul>
  4060b0:	4602      	mov	r2, r0
  4060b2:	460b      	mov	r3, r1
  4060b4:	4630      	mov	r0, r6
  4060b6:	4639      	mov	r1, r7
  4060b8:	f002 fab4 	bl	408624 <__aeabi_dsub>
  4060bc:	f10a 0e30 	add.w	lr, sl, #48	; 0x30
  4060c0:	f805 eb01 	strb.w	lr, [r5], #1
  4060c4:	ebcb 0e05 	rsb	lr, fp, r5
  4060c8:	4574      	cmp	r4, lr
  4060ca:	4606      	mov	r6, r0
  4060cc:	460f      	mov	r7, r1
  4060ce:	f04f 0200 	mov.w	r2, #0
  4060d2:	4bb5      	ldr	r3, [pc, #724]	; (4063a8 <_dtoa_r+0x618>)
  4060d4:	d1d2      	bne.n	40607c <_dtoa_r+0x2ec>
  4060d6:	f8dd b008 	ldr.w	fp, [sp, #8]
  4060da:	9c05      	ldr	r4, [sp, #20]
  4060dc:	4632      	mov	r2, r6
  4060de:	463b      	mov	r3, r7
  4060e0:	4630      	mov	r0, r6
  4060e2:	4639      	mov	r1, r7
  4060e4:	f002 faa0 	bl	408628 <__adddf3>
  4060e8:	4606      	mov	r6, r0
  4060ea:	460f      	mov	r7, r1
  4060ec:	4640      	mov	r0, r8
  4060ee:	4649      	mov	r1, r9
  4060f0:	4632      	mov	r2, r6
  4060f2:	463b      	mov	r3, r7
  4060f4:	f002 febc 	bl	408e70 <__aeabi_dcmplt>
  4060f8:	b948      	cbnz	r0, 40610e <_dtoa_r+0x37e>
  4060fa:	4640      	mov	r0, r8
  4060fc:	4649      	mov	r1, r9
  4060fe:	4632      	mov	r2, r6
  406100:	463b      	mov	r3, r7
  406102:	f002 feab 	bl	408e5c <__aeabi_dcmpeq>
  406106:	b1b0      	cbz	r0, 406136 <_dtoa_r+0x3a6>
  406108:	f01a 0f01 	tst.w	sl, #1
  40610c:	d013      	beq.n	406136 <_dtoa_r+0x3a6>
  40610e:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  406112:	9907      	ldr	r1, [sp, #28]
  406114:	1e6b      	subs	r3, r5, #1
  406116:	e004      	b.n	406122 <_dtoa_r+0x392>
  406118:	428b      	cmp	r3, r1
  40611a:	f000 8440 	beq.w	40699e <_dtoa_r+0xc0e>
  40611e:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
  406122:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
  406126:	f103 0501 	add.w	r5, r3, #1
  40612a:	461a      	mov	r2, r3
  40612c:	d0f4      	beq.n	406118 <_dtoa_r+0x388>
  40612e:	f108 0301 	add.w	r3, r8, #1
  406132:	b2db      	uxtb	r3, r3
  406134:	7013      	strb	r3, [r2, #0]
  406136:	4620      	mov	r0, r4
  406138:	4659      	mov	r1, fp
  40613a:	f001 fb97 	bl	40786c <_Bfree>
  40613e:	2200      	movs	r2, #0
  406140:	9b04      	ldr	r3, [sp, #16]
  406142:	702a      	strb	r2, [r5, #0]
  406144:	9a22      	ldr	r2, [sp, #136]	; 0x88
  406146:	3301      	adds	r3, #1
  406148:	6013      	str	r3, [r2, #0]
  40614a:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40614c:	2b00      	cmp	r3, #0
  40614e:	f000 8345 	beq.w	4067dc <_dtoa_r+0xa4c>
  406152:	9807      	ldr	r0, [sp, #28]
  406154:	601d      	str	r5, [r3, #0]
  406156:	b017      	add	sp, #92	; 0x5c
  406158:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40615c:	9a09      	ldr	r2, [sp, #36]	; 0x24
  40615e:	2a00      	cmp	r2, #0
  406160:	f000 8084 	beq.w	40626c <_dtoa_r+0x4dc>
  406164:	9a20      	ldr	r2, [sp, #128]	; 0x80
  406166:	2a01      	cmp	r2, #1
  406168:	f340 8304 	ble.w	406774 <_dtoa_r+0x9e4>
  40616c:	9b06      	ldr	r3, [sp, #24]
  40616e:	1e5f      	subs	r7, r3, #1
  406170:	9b08      	ldr	r3, [sp, #32]
  406172:	42bb      	cmp	r3, r7
  406174:	f2c0 83a9 	blt.w	4068ca <_dtoa_r+0xb3a>
  406178:	1bdf      	subs	r7, r3, r7
  40617a:	9b06      	ldr	r3, [sp, #24]
  40617c:	2b00      	cmp	r3, #0
  40617e:	f2c0 849c 	blt.w	406aba <_dtoa_r+0xd2a>
  406182:	9d05      	ldr	r5, [sp, #20]
  406184:	9b06      	ldr	r3, [sp, #24]
  406186:	9a05      	ldr	r2, [sp, #20]
  406188:	4620      	mov	r0, r4
  40618a:	441a      	add	r2, r3
  40618c:	2101      	movs	r1, #1
  40618e:	9205      	str	r2, [sp, #20]
  406190:	449a      	add	sl, r3
  406192:	f001 fc05 	bl	4079a0 <__i2b>
  406196:	4606      	mov	r6, r0
  406198:	b165      	cbz	r5, 4061b4 <_dtoa_r+0x424>
  40619a:	f1ba 0f00 	cmp.w	sl, #0
  40619e:	dd09      	ble.n	4061b4 <_dtoa_r+0x424>
  4061a0:	45aa      	cmp	sl, r5
  4061a2:	9a05      	ldr	r2, [sp, #20]
  4061a4:	4653      	mov	r3, sl
  4061a6:	bfa8      	it	ge
  4061a8:	462b      	movge	r3, r5
  4061aa:	1ad2      	subs	r2, r2, r3
  4061ac:	9205      	str	r2, [sp, #20]
  4061ae:	1aed      	subs	r5, r5, r3
  4061b0:	ebc3 0a0a 	rsb	sl, r3, sl
  4061b4:	9b08      	ldr	r3, [sp, #32]
  4061b6:	2b00      	cmp	r3, #0
  4061b8:	dd1a      	ble.n	4061f0 <_dtoa_r+0x460>
  4061ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4061bc:	2b00      	cmp	r3, #0
  4061be:	f000 837d 	beq.w	4068bc <_dtoa_r+0xb2c>
  4061c2:	2f00      	cmp	r7, #0
  4061c4:	dd10      	ble.n	4061e8 <_dtoa_r+0x458>
  4061c6:	4631      	mov	r1, r6
  4061c8:	463a      	mov	r2, r7
  4061ca:	4620      	mov	r0, r4
  4061cc:	f001 fc8c 	bl	407ae8 <__pow5mult>
  4061d0:	4606      	mov	r6, r0
  4061d2:	465a      	mov	r2, fp
  4061d4:	4631      	mov	r1, r6
  4061d6:	4620      	mov	r0, r4
  4061d8:	f001 fbec 	bl	4079b4 <__multiply>
  4061dc:	4659      	mov	r1, fp
  4061de:	4680      	mov	r8, r0
  4061e0:	4620      	mov	r0, r4
  4061e2:	f001 fb43 	bl	40786c <_Bfree>
  4061e6:	46c3      	mov	fp, r8
  4061e8:	9b08      	ldr	r3, [sp, #32]
  4061ea:	1bda      	subs	r2, r3, r7
  4061ec:	f040 82a2 	bne.w	406734 <_dtoa_r+0x9a4>
  4061f0:	4620      	mov	r0, r4
  4061f2:	2101      	movs	r1, #1
  4061f4:	f001 fbd4 	bl	4079a0 <__i2b>
  4061f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4061fa:	2b00      	cmp	r3, #0
  4061fc:	4680      	mov	r8, r0
  4061fe:	dd39      	ble.n	406274 <_dtoa_r+0x4e4>
  406200:	4601      	mov	r1, r0
  406202:	461a      	mov	r2, r3
  406204:	4620      	mov	r0, r4
  406206:	f001 fc6f 	bl	407ae8 <__pow5mult>
  40620a:	9b20      	ldr	r3, [sp, #128]	; 0x80
  40620c:	2b01      	cmp	r3, #1
  40620e:	4680      	mov	r8, r0
  406210:	f340 8296 	ble.w	406740 <_dtoa_r+0x9b0>
  406214:	f04f 0900 	mov.w	r9, #0
  406218:	f8d8 3010 	ldr.w	r3, [r8, #16]
  40621c:	eb08 0383 	add.w	r3, r8, r3, lsl #2
  406220:	6918      	ldr	r0, [r3, #16]
  406222:	f001 fb6f 	bl	407904 <__hi0bits>
  406226:	f1c0 0020 	rsb	r0, r0, #32
  40622a:	e02d      	b.n	406288 <_dtoa_r+0x4f8>
  40622c:	2301      	movs	r3, #1
  40622e:	930b      	str	r3, [sp, #44]	; 0x2c
  406230:	e66f      	b.n	405f12 <_dtoa_r+0x182>
  406232:	9804      	ldr	r0, [sp, #16]
  406234:	f002 fb44 	bl	4088c0 <__aeabi_i2d>
  406238:	4632      	mov	r2, r6
  40623a:	463b      	mov	r3, r7
  40623c:	f002 fe0e 	bl	408e5c <__aeabi_dcmpeq>
  406240:	2800      	cmp	r0, #0
  406242:	f47f ae50 	bne.w	405ee6 <_dtoa_r+0x156>
  406246:	9b04      	ldr	r3, [sp, #16]
  406248:	3b01      	subs	r3, #1
  40624a:	9304      	str	r3, [sp, #16]
  40624c:	e64b      	b.n	405ee6 <_dtoa_r+0x156>
  40624e:	9a05      	ldr	r2, [sp, #20]
  406250:	9b04      	ldr	r3, [sp, #16]
  406252:	1ad2      	subs	r2, r2, r3
  406254:	425b      	negs	r3, r3
  406256:	9308      	str	r3, [sp, #32]
  406258:	2300      	movs	r3, #0
  40625a:	9205      	str	r2, [sp, #20]
  40625c:	930a      	str	r3, [sp, #40]	; 0x28
  40625e:	e668      	b.n	405f32 <_dtoa_r+0x1a2>
  406260:	f1ca 0300 	rsb	r3, sl, #0
  406264:	9305      	str	r3, [sp, #20]
  406266:	f04f 0a00 	mov.w	sl, #0
  40626a:	e65a      	b.n	405f22 <_dtoa_r+0x192>
  40626c:	9f08      	ldr	r7, [sp, #32]
  40626e:	9d05      	ldr	r5, [sp, #20]
  406270:	9e09      	ldr	r6, [sp, #36]	; 0x24
  406272:	e791      	b.n	406198 <_dtoa_r+0x408>
  406274:	9b20      	ldr	r3, [sp, #128]	; 0x80
  406276:	2b01      	cmp	r3, #1
  406278:	f340 82b3 	ble.w	4067e2 <_dtoa_r+0xa52>
  40627c:	f04f 0900 	mov.w	r9, #0
  406280:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  406282:	2b00      	cmp	r3, #0
  406284:	d1c8      	bne.n	406218 <_dtoa_r+0x488>
  406286:	2001      	movs	r0, #1
  406288:	4450      	add	r0, sl
  40628a:	f010 001f 	ands.w	r0, r0, #31
  40628e:	f000 8081 	beq.w	406394 <_dtoa_r+0x604>
  406292:	f1c0 0320 	rsb	r3, r0, #32
  406296:	2b04      	cmp	r3, #4
  406298:	f340 84b8 	ble.w	406c0c <_dtoa_r+0xe7c>
  40629c:	f1c0 001c 	rsb	r0, r0, #28
  4062a0:	9b05      	ldr	r3, [sp, #20]
  4062a2:	4403      	add	r3, r0
  4062a4:	9305      	str	r3, [sp, #20]
  4062a6:	4405      	add	r5, r0
  4062a8:	4482      	add	sl, r0
  4062aa:	9b05      	ldr	r3, [sp, #20]
  4062ac:	2b00      	cmp	r3, #0
  4062ae:	dd05      	ble.n	4062bc <_dtoa_r+0x52c>
  4062b0:	4659      	mov	r1, fp
  4062b2:	461a      	mov	r2, r3
  4062b4:	4620      	mov	r0, r4
  4062b6:	f001 fc67 	bl	407b88 <__lshift>
  4062ba:	4683      	mov	fp, r0
  4062bc:	f1ba 0f00 	cmp.w	sl, #0
  4062c0:	dd05      	ble.n	4062ce <_dtoa_r+0x53e>
  4062c2:	4641      	mov	r1, r8
  4062c4:	4652      	mov	r2, sl
  4062c6:	4620      	mov	r0, r4
  4062c8:	f001 fc5e 	bl	407b88 <__lshift>
  4062cc:	4680      	mov	r8, r0
  4062ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4062d0:	2b00      	cmp	r3, #0
  4062d2:	f040 8268 	bne.w	4067a6 <_dtoa_r+0xa16>
  4062d6:	9b06      	ldr	r3, [sp, #24]
  4062d8:	2b00      	cmp	r3, #0
  4062da:	f340 8295 	ble.w	406808 <_dtoa_r+0xa78>
  4062de:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4062e0:	2b00      	cmp	r3, #0
  4062e2:	d171      	bne.n	4063c8 <_dtoa_r+0x638>
  4062e4:	f8dd 901c 	ldr.w	r9, [sp, #28]
  4062e8:	9f06      	ldr	r7, [sp, #24]
  4062ea:	464d      	mov	r5, r9
  4062ec:	e002      	b.n	4062f4 <_dtoa_r+0x564>
  4062ee:	f001 fac7 	bl	407880 <__multadd>
  4062f2:	4683      	mov	fp, r0
  4062f4:	4641      	mov	r1, r8
  4062f6:	4658      	mov	r0, fp
  4062f8:	f7ff fcb2 	bl	405c60 <quorem>
  4062fc:	f100 0c30 	add.w	ip, r0, #48	; 0x30
  406300:	f805 cb01 	strb.w	ip, [r5], #1
  406304:	ebc9 0305 	rsb	r3, r9, r5
  406308:	42bb      	cmp	r3, r7
  40630a:	4620      	mov	r0, r4
  40630c:	4659      	mov	r1, fp
  40630e:	f04f 020a 	mov.w	r2, #10
  406312:	f04f 0300 	mov.w	r3, #0
  406316:	dbea      	blt.n	4062ee <_dtoa_r+0x55e>
  406318:	9b07      	ldr	r3, [sp, #28]
  40631a:	9a06      	ldr	r2, [sp, #24]
  40631c:	2a01      	cmp	r2, #1
  40631e:	bfac      	ite	ge
  406320:	189b      	addge	r3, r3, r2
  406322:	3301      	addlt	r3, #1
  406324:	461d      	mov	r5, r3
  406326:	f04f 0a00 	mov.w	sl, #0
  40632a:	4659      	mov	r1, fp
  40632c:	2201      	movs	r2, #1
  40632e:	4620      	mov	r0, r4
  406330:	f8cd c008 	str.w	ip, [sp, #8]
  406334:	f001 fc28 	bl	407b88 <__lshift>
  406338:	4641      	mov	r1, r8
  40633a:	4683      	mov	fp, r0
  40633c:	f001 fc7a 	bl	407c34 <__mcmp>
  406340:	2800      	cmp	r0, #0
  406342:	f8dd c008 	ldr.w	ip, [sp, #8]
  406346:	f340 82f6 	ble.w	406936 <_dtoa_r+0xba6>
  40634a:	f815 2c01 	ldrb.w	r2, [r5, #-1]
  40634e:	9907      	ldr	r1, [sp, #28]
  406350:	1e6b      	subs	r3, r5, #1
  406352:	e004      	b.n	40635e <_dtoa_r+0x5ce>
  406354:	428b      	cmp	r3, r1
  406356:	f000 8273 	beq.w	406840 <_dtoa_r+0xab0>
  40635a:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  40635e:	2a39      	cmp	r2, #57	; 0x39
  406360:	f103 0501 	add.w	r5, r3, #1
  406364:	d0f6      	beq.n	406354 <_dtoa_r+0x5c4>
  406366:	3201      	adds	r2, #1
  406368:	701a      	strb	r2, [r3, #0]
  40636a:	4641      	mov	r1, r8
  40636c:	4620      	mov	r0, r4
  40636e:	f001 fa7d 	bl	40786c <_Bfree>
  406372:	2e00      	cmp	r6, #0
  406374:	f43f aedf 	beq.w	406136 <_dtoa_r+0x3a6>
  406378:	f1ba 0f00 	cmp.w	sl, #0
  40637c:	d005      	beq.n	40638a <_dtoa_r+0x5fa>
  40637e:	45b2      	cmp	sl, r6
  406380:	d003      	beq.n	40638a <_dtoa_r+0x5fa>
  406382:	4651      	mov	r1, sl
  406384:	4620      	mov	r0, r4
  406386:	f001 fa71 	bl	40786c <_Bfree>
  40638a:	4631      	mov	r1, r6
  40638c:	4620      	mov	r0, r4
  40638e:	f001 fa6d 	bl	40786c <_Bfree>
  406392:	e6d0      	b.n	406136 <_dtoa_r+0x3a6>
  406394:	201c      	movs	r0, #28
  406396:	e783      	b.n	4062a0 <_dtoa_r+0x510>
  406398:	4b04      	ldr	r3, [pc, #16]	; (4063ac <_dtoa_r+0x61c>)
  40639a:	9a02      	ldr	r2, [sp, #8]
  40639c:	1b5b      	subs	r3, r3, r5
  40639e:	fa02 f003 	lsl.w	r0, r2, r3
  4063a2:	e56d      	b.n	405e80 <_dtoa_r+0xf0>
  4063a4:	900b      	str	r0, [sp, #44]	; 0x2c
  4063a6:	e5b4      	b.n	405f12 <_dtoa_r+0x182>
  4063a8:	40240000 	.word	0x40240000
  4063ac:	fffffbee 	.word	0xfffffbee
  4063b0:	4631      	mov	r1, r6
  4063b2:	2300      	movs	r3, #0
  4063b4:	4620      	mov	r0, r4
  4063b6:	220a      	movs	r2, #10
  4063b8:	f001 fa62 	bl	407880 <__multadd>
  4063bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4063be:	2b00      	cmp	r3, #0
  4063c0:	4606      	mov	r6, r0
  4063c2:	f340 840c 	ble.w	406bde <_dtoa_r+0xe4e>
  4063c6:	9306      	str	r3, [sp, #24]
  4063c8:	2d00      	cmp	r5, #0
  4063ca:	dd05      	ble.n	4063d8 <_dtoa_r+0x648>
  4063cc:	4631      	mov	r1, r6
  4063ce:	462a      	mov	r2, r5
  4063d0:	4620      	mov	r0, r4
  4063d2:	f001 fbd9 	bl	407b88 <__lshift>
  4063d6:	4606      	mov	r6, r0
  4063d8:	f1b9 0f00 	cmp.w	r9, #0
  4063dc:	f040 82e9 	bne.w	4069b2 <_dtoa_r+0xc22>
  4063e0:	46b1      	mov	r9, r6
  4063e2:	9b06      	ldr	r3, [sp, #24]
  4063e4:	9a07      	ldr	r2, [sp, #28]
  4063e6:	3b01      	subs	r3, #1
  4063e8:	18d3      	adds	r3, r2, r3
  4063ea:	9308      	str	r3, [sp, #32]
  4063ec:	9b02      	ldr	r3, [sp, #8]
  4063ee:	f003 0301 	and.w	r3, r3, #1
  4063f2:	9309      	str	r3, [sp, #36]	; 0x24
  4063f4:	4617      	mov	r7, r2
  4063f6:	4641      	mov	r1, r8
  4063f8:	4658      	mov	r0, fp
  4063fa:	f7ff fc31 	bl	405c60 <quorem>
  4063fe:	4631      	mov	r1, r6
  406400:	4605      	mov	r5, r0
  406402:	4658      	mov	r0, fp
  406404:	f001 fc16 	bl	407c34 <__mcmp>
  406408:	464a      	mov	r2, r9
  40640a:	4682      	mov	sl, r0
  40640c:	4641      	mov	r1, r8
  40640e:	4620      	mov	r0, r4
  406410:	f001 fc34 	bl	407c7c <__mdiff>
  406414:	68c2      	ldr	r2, [r0, #12]
  406416:	4603      	mov	r3, r0
  406418:	f105 0c30 	add.w	ip, r5, #48	; 0x30
  40641c:	2a00      	cmp	r2, #0
  40641e:	f040 81b8 	bne.w	406792 <_dtoa_r+0xa02>
  406422:	4619      	mov	r1, r3
  406424:	4658      	mov	r0, fp
  406426:	f8cd c018 	str.w	ip, [sp, #24]
  40642a:	9305      	str	r3, [sp, #20]
  40642c:	f001 fc02 	bl	407c34 <__mcmp>
  406430:	9b05      	ldr	r3, [sp, #20]
  406432:	9002      	str	r0, [sp, #8]
  406434:	4619      	mov	r1, r3
  406436:	4620      	mov	r0, r4
  406438:	f001 fa18 	bl	40786c <_Bfree>
  40643c:	9a02      	ldr	r2, [sp, #8]
  40643e:	f8dd c018 	ldr.w	ip, [sp, #24]
  406442:	b92a      	cbnz	r2, 406450 <_dtoa_r+0x6c0>
  406444:	9b20      	ldr	r3, [sp, #128]	; 0x80
  406446:	b91b      	cbnz	r3, 406450 <_dtoa_r+0x6c0>
  406448:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40644a:	2b00      	cmp	r3, #0
  40644c:	f000 83a7 	beq.w	406b9e <_dtoa_r+0xe0e>
  406450:	f1ba 0f00 	cmp.w	sl, #0
  406454:	f2c0 8251 	blt.w	4068fa <_dtoa_r+0xb6a>
  406458:	d105      	bne.n	406466 <_dtoa_r+0x6d6>
  40645a:	9b20      	ldr	r3, [sp, #128]	; 0x80
  40645c:	b91b      	cbnz	r3, 406466 <_dtoa_r+0x6d6>
  40645e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406460:	2b00      	cmp	r3, #0
  406462:	f000 824a 	beq.w	4068fa <_dtoa_r+0xb6a>
  406466:	2a00      	cmp	r2, #0
  406468:	f300 82b7 	bgt.w	4069da <_dtoa_r+0xc4a>
  40646c:	9b08      	ldr	r3, [sp, #32]
  40646e:	f887 c000 	strb.w	ip, [r7]
  406472:	f107 0a01 	add.w	sl, r7, #1
  406476:	429f      	cmp	r7, r3
  406478:	4655      	mov	r5, sl
  40647a:	f000 82ba 	beq.w	4069f2 <_dtoa_r+0xc62>
  40647e:	4659      	mov	r1, fp
  406480:	220a      	movs	r2, #10
  406482:	2300      	movs	r3, #0
  406484:	4620      	mov	r0, r4
  406486:	f001 f9fb 	bl	407880 <__multadd>
  40648a:	454e      	cmp	r6, r9
  40648c:	4683      	mov	fp, r0
  40648e:	4631      	mov	r1, r6
  406490:	4620      	mov	r0, r4
  406492:	f04f 020a 	mov.w	r2, #10
  406496:	f04f 0300 	mov.w	r3, #0
  40649a:	f000 8174 	beq.w	406786 <_dtoa_r+0x9f6>
  40649e:	f001 f9ef 	bl	407880 <__multadd>
  4064a2:	4649      	mov	r1, r9
  4064a4:	4606      	mov	r6, r0
  4064a6:	220a      	movs	r2, #10
  4064a8:	4620      	mov	r0, r4
  4064aa:	2300      	movs	r3, #0
  4064ac:	f001 f9e8 	bl	407880 <__multadd>
  4064b0:	4657      	mov	r7, sl
  4064b2:	4681      	mov	r9, r0
  4064b4:	e79f      	b.n	4063f6 <_dtoa_r+0x666>
  4064b6:	2301      	movs	r3, #1
  4064b8:	9309      	str	r3, [sp, #36]	; 0x24
  4064ba:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4064bc:	2b00      	cmp	r3, #0
  4064be:	f340 8213 	ble.w	4068e8 <_dtoa_r+0xb58>
  4064c2:	461f      	mov	r7, r3
  4064c4:	461e      	mov	r6, r3
  4064c6:	930c      	str	r3, [sp, #48]	; 0x30
  4064c8:	9306      	str	r3, [sp, #24]
  4064ca:	2100      	movs	r1, #0
  4064cc:	2f17      	cmp	r7, #23
  4064ce:	6461      	str	r1, [r4, #68]	; 0x44
  4064d0:	d90a      	bls.n	4064e8 <_dtoa_r+0x758>
  4064d2:	2201      	movs	r2, #1
  4064d4:	2304      	movs	r3, #4
  4064d6:	005b      	lsls	r3, r3, #1
  4064d8:	f103 0014 	add.w	r0, r3, #20
  4064dc:	4287      	cmp	r7, r0
  4064de:	4611      	mov	r1, r2
  4064e0:	f102 0201 	add.w	r2, r2, #1
  4064e4:	d2f7      	bcs.n	4064d6 <_dtoa_r+0x746>
  4064e6:	6461      	str	r1, [r4, #68]	; 0x44
  4064e8:	4620      	mov	r0, r4
  4064ea:	f001 f999 	bl	407820 <_Balloc>
  4064ee:	2e0e      	cmp	r6, #14
  4064f0:	9007      	str	r0, [sp, #28]
  4064f2:	6420      	str	r0, [r4, #64]	; 0x40
  4064f4:	f63f ad5c 	bhi.w	405fb0 <_dtoa_r+0x220>
  4064f8:	2d00      	cmp	r5, #0
  4064fa:	f43f ad59 	beq.w	405fb0 <_dtoa_r+0x220>
  4064fe:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  406502:	9904      	ldr	r1, [sp, #16]
  406504:	2900      	cmp	r1, #0
  406506:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  40650a:	f340 8221 	ble.w	406950 <_dtoa_r+0xbc0>
  40650e:	4bb7      	ldr	r3, [pc, #732]	; (4067ec <_dtoa_r+0xa5c>)
  406510:	f001 020f 	and.w	r2, r1, #15
  406514:	110d      	asrs	r5, r1, #4
  406516:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  40651a:	06e9      	lsls	r1, r5, #27
  40651c:	e9d3 6700 	ldrd	r6, r7, [r3]
  406520:	f140 81db 	bpl.w	4068da <_dtoa_r+0xb4a>
  406524:	4bb2      	ldr	r3, [pc, #712]	; (4067f0 <_dtoa_r+0xa60>)
  406526:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  40652a:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
  40652e:	f002 fb57 	bl	408be0 <__aeabi_ddiv>
  406532:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406536:	f005 050f 	and.w	r5, r5, #15
  40653a:	f04f 0803 	mov.w	r8, #3
  40653e:	b18d      	cbz	r5, 406564 <_dtoa_r+0x7d4>
  406540:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 4067f0 <_dtoa_r+0xa60>
  406544:	4630      	mov	r0, r6
  406546:	4639      	mov	r1, r7
  406548:	07ea      	lsls	r2, r5, #31
  40654a:	d505      	bpl.n	406558 <_dtoa_r+0x7c8>
  40654c:	e9d9 2300 	ldrd	r2, r3, [r9]
  406550:	f108 0801 	add.w	r8, r8, #1
  406554:	f002 fa1a 	bl	40898c <__aeabi_dmul>
  406558:	106d      	asrs	r5, r5, #1
  40655a:	f109 0908 	add.w	r9, r9, #8
  40655e:	d1f3      	bne.n	406548 <_dtoa_r+0x7b8>
  406560:	4606      	mov	r6, r0
  406562:	460f      	mov	r7, r1
  406564:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  406568:	4632      	mov	r2, r6
  40656a:	463b      	mov	r3, r7
  40656c:	f002 fb38 	bl	408be0 <__aeabi_ddiv>
  406570:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406574:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  406576:	b143      	cbz	r3, 40658a <_dtoa_r+0x7fa>
  406578:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40657c:	2200      	movs	r2, #0
  40657e:	4b9d      	ldr	r3, [pc, #628]	; (4067f4 <_dtoa_r+0xa64>)
  406580:	f002 fc76 	bl	408e70 <__aeabi_dcmplt>
  406584:	2800      	cmp	r0, #0
  406586:	f040 82ac 	bne.w	406ae2 <_dtoa_r+0xd52>
  40658a:	4640      	mov	r0, r8
  40658c:	f002 f998 	bl	4088c0 <__aeabi_i2d>
  406590:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  406594:	f002 f9fa 	bl	40898c <__aeabi_dmul>
  406598:	4b97      	ldr	r3, [pc, #604]	; (4067f8 <_dtoa_r+0xa68>)
  40659a:	2200      	movs	r2, #0
  40659c:	f002 f844 	bl	408628 <__adddf3>
  4065a0:	9b06      	ldr	r3, [sp, #24]
  4065a2:	4606      	mov	r6, r0
  4065a4:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  4065a8:	2b00      	cmp	r3, #0
  4065aa:	f000 8162 	beq.w	406872 <_dtoa_r+0xae2>
  4065ae:	9b04      	ldr	r3, [sp, #16]
  4065b0:	f8dd 9018 	ldr.w	r9, [sp, #24]
  4065b4:	9312      	str	r3, [sp, #72]	; 0x48
  4065b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4065b8:	2b00      	cmp	r3, #0
  4065ba:	f000 8221 	beq.w	406a00 <_dtoa_r+0xc70>
  4065be:	4b8b      	ldr	r3, [pc, #556]	; (4067ec <_dtoa_r+0xa5c>)
  4065c0:	498e      	ldr	r1, [pc, #568]	; (4067fc <_dtoa_r+0xa6c>)
  4065c2:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
  4065c6:	e953 2302 	ldrd	r2, r3, [r3, #-8]
  4065ca:	2000      	movs	r0, #0
  4065cc:	f002 fb08 	bl	408be0 <__aeabi_ddiv>
  4065d0:	4632      	mov	r2, r6
  4065d2:	463b      	mov	r3, r7
  4065d4:	f002 f826 	bl	408624 <__aeabi_dsub>
  4065d8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  4065dc:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
  4065e0:	4639      	mov	r1, r7
  4065e2:	4630      	mov	r0, r6
  4065e4:	f002 fc6c 	bl	408ec0 <__aeabi_d2iz>
  4065e8:	4605      	mov	r5, r0
  4065ea:	f002 f969 	bl	4088c0 <__aeabi_i2d>
  4065ee:	3530      	adds	r5, #48	; 0x30
  4065f0:	4602      	mov	r2, r0
  4065f2:	460b      	mov	r3, r1
  4065f4:	4630      	mov	r0, r6
  4065f6:	4639      	mov	r1, r7
  4065f8:	f002 f814 	bl	408624 <__aeabi_dsub>
  4065fc:	fa5f f885 	uxtb.w	r8, r5
  406600:	9d07      	ldr	r5, [sp, #28]
  406602:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
  406606:	f885 8000 	strb.w	r8, [r5]
  40660a:	4606      	mov	r6, r0
  40660c:	460f      	mov	r7, r1
  40660e:	3501      	adds	r5, #1
  406610:	f002 fc2e 	bl	408e70 <__aeabi_dcmplt>
  406614:	2800      	cmp	r0, #0
  406616:	f040 82b2 	bne.w	406b7e <_dtoa_r+0xdee>
  40661a:	4632      	mov	r2, r6
  40661c:	463b      	mov	r3, r7
  40661e:	2000      	movs	r0, #0
  406620:	4974      	ldr	r1, [pc, #464]	; (4067f4 <_dtoa_r+0xa64>)
  406622:	f001 ffff 	bl	408624 <__aeabi_dsub>
  406626:	4602      	mov	r2, r0
  406628:	460b      	mov	r3, r1
  40662a:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  40662e:	f002 fc3d 	bl	408eac <__aeabi_dcmpgt>
  406632:	2800      	cmp	r0, #0
  406634:	f040 82ac 	bne.w	406b90 <_dtoa_r+0xe00>
  406638:	f1b9 0f01 	cmp.w	r9, #1
  40663c:	f340 8138 	ble.w	4068b0 <_dtoa_r+0xb20>
  406640:	9b07      	ldr	r3, [sp, #28]
  406642:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
  406646:	f8cd b008 	str.w	fp, [sp, #8]
  40664a:	4499      	add	r9, r3
  40664c:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
  406650:	46a0      	mov	r8, r4
  406652:	e00d      	b.n	406670 <_dtoa_r+0x8e0>
  406654:	2000      	movs	r0, #0
  406656:	4967      	ldr	r1, [pc, #412]	; (4067f4 <_dtoa_r+0xa64>)
  406658:	f001 ffe4 	bl	408624 <__aeabi_dsub>
  40665c:	4652      	mov	r2, sl
  40665e:	465b      	mov	r3, fp
  406660:	f002 fc06 	bl	408e70 <__aeabi_dcmplt>
  406664:	2800      	cmp	r0, #0
  406666:	f040 828e 	bne.w	406b86 <_dtoa_r+0xdf6>
  40666a:	454d      	cmp	r5, r9
  40666c:	f000 811b 	beq.w	4068a6 <_dtoa_r+0xb16>
  406670:	4650      	mov	r0, sl
  406672:	4659      	mov	r1, fp
  406674:	2200      	movs	r2, #0
  406676:	4b62      	ldr	r3, [pc, #392]	; (406800 <_dtoa_r+0xa70>)
  406678:	f002 f988 	bl	40898c <__aeabi_dmul>
  40667c:	2200      	movs	r2, #0
  40667e:	4b60      	ldr	r3, [pc, #384]	; (406800 <_dtoa_r+0xa70>)
  406680:	4682      	mov	sl, r0
  406682:	468b      	mov	fp, r1
  406684:	4630      	mov	r0, r6
  406686:	4639      	mov	r1, r7
  406688:	f002 f980 	bl	40898c <__aeabi_dmul>
  40668c:	460f      	mov	r7, r1
  40668e:	4606      	mov	r6, r0
  406690:	f002 fc16 	bl	408ec0 <__aeabi_d2iz>
  406694:	4604      	mov	r4, r0
  406696:	f002 f913 	bl	4088c0 <__aeabi_i2d>
  40669a:	4602      	mov	r2, r0
  40669c:	460b      	mov	r3, r1
  40669e:	4630      	mov	r0, r6
  4066a0:	4639      	mov	r1, r7
  4066a2:	f001 ffbf 	bl	408624 <__aeabi_dsub>
  4066a6:	3430      	adds	r4, #48	; 0x30
  4066a8:	b2e4      	uxtb	r4, r4
  4066aa:	4652      	mov	r2, sl
  4066ac:	465b      	mov	r3, fp
  4066ae:	f805 4b01 	strb.w	r4, [r5], #1
  4066b2:	4606      	mov	r6, r0
  4066b4:	460f      	mov	r7, r1
  4066b6:	f002 fbdb 	bl	408e70 <__aeabi_dcmplt>
  4066ba:	4632      	mov	r2, r6
  4066bc:	463b      	mov	r3, r7
  4066be:	2800      	cmp	r0, #0
  4066c0:	d0c8      	beq.n	406654 <_dtoa_r+0x8c4>
  4066c2:	9b12      	ldr	r3, [sp, #72]	; 0x48
  4066c4:	f8dd b008 	ldr.w	fp, [sp, #8]
  4066c8:	9304      	str	r3, [sp, #16]
  4066ca:	4644      	mov	r4, r8
  4066cc:	e533      	b.n	406136 <_dtoa_r+0x3a6>
  4066ce:	2300      	movs	r3, #0
  4066d0:	9309      	str	r3, [sp, #36]	; 0x24
  4066d2:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4066d4:	9a04      	ldr	r2, [sp, #16]
  4066d6:	4413      	add	r3, r2
  4066d8:	930c      	str	r3, [sp, #48]	; 0x30
  4066da:	3301      	adds	r3, #1
  4066dc:	2b00      	cmp	r3, #0
  4066de:	9306      	str	r3, [sp, #24]
  4066e0:	f340 8109 	ble.w	4068f6 <_dtoa_r+0xb66>
  4066e4:	9e06      	ldr	r6, [sp, #24]
  4066e6:	4637      	mov	r7, r6
  4066e8:	e6ef      	b.n	4064ca <_dtoa_r+0x73a>
  4066ea:	2300      	movs	r3, #0
  4066ec:	9309      	str	r3, [sp, #36]	; 0x24
  4066ee:	e6e4      	b.n	4064ba <_dtoa_r+0x72a>
  4066f0:	9b06      	ldr	r3, [sp, #24]
  4066f2:	2b00      	cmp	r3, #0
  4066f4:	f73f ac6d 	bgt.w	405fd2 <_dtoa_r+0x242>
  4066f8:	f040 8262 	bne.w	406bc0 <_dtoa_r+0xe30>
  4066fc:	4640      	mov	r0, r8
  4066fe:	2200      	movs	r2, #0
  406700:	4b40      	ldr	r3, [pc, #256]	; (406804 <_dtoa_r+0xa74>)
  406702:	4649      	mov	r1, r9
  406704:	f002 f942 	bl	40898c <__aeabi_dmul>
  406708:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40670c:	f002 fbc4 	bl	408e98 <__aeabi_dcmpge>
  406710:	f8dd 8018 	ldr.w	r8, [sp, #24]
  406714:	4646      	mov	r6, r8
  406716:	2800      	cmp	r0, #0
  406718:	f000 808a 	beq.w	406830 <_dtoa_r+0xaa0>
  40671c:	9b21      	ldr	r3, [sp, #132]	; 0x84
  40671e:	9d07      	ldr	r5, [sp, #28]
  406720:	43db      	mvns	r3, r3
  406722:	9304      	str	r3, [sp, #16]
  406724:	4641      	mov	r1, r8
  406726:	4620      	mov	r0, r4
  406728:	f001 f8a0 	bl	40786c <_Bfree>
  40672c:	2e00      	cmp	r6, #0
  40672e:	f47f ae2c 	bne.w	40638a <_dtoa_r+0x5fa>
  406732:	e500      	b.n	406136 <_dtoa_r+0x3a6>
  406734:	4659      	mov	r1, fp
  406736:	4620      	mov	r0, r4
  406738:	f001 f9d6 	bl	407ae8 <__pow5mult>
  40673c:	4683      	mov	fp, r0
  40673e:	e557      	b.n	4061f0 <_dtoa_r+0x460>
  406740:	9b02      	ldr	r3, [sp, #8]
  406742:	2b00      	cmp	r3, #0
  406744:	f47f ad66 	bne.w	406214 <_dtoa_r+0x484>
  406748:	9b03      	ldr	r3, [sp, #12]
  40674a:	f3c3 0313 	ubfx	r3, r3, #0, #20
  40674e:	2b00      	cmp	r3, #0
  406750:	f47f ad94 	bne.w	40627c <_dtoa_r+0x4ec>
  406754:	9b03      	ldr	r3, [sp, #12]
  406756:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
  40675a:	0d3f      	lsrs	r7, r7, #20
  40675c:	053f      	lsls	r7, r7, #20
  40675e:	2f00      	cmp	r7, #0
  406760:	f000 821a 	beq.w	406b98 <_dtoa_r+0xe08>
  406764:	9b05      	ldr	r3, [sp, #20]
  406766:	3301      	adds	r3, #1
  406768:	9305      	str	r3, [sp, #20]
  40676a:	f10a 0a01 	add.w	sl, sl, #1
  40676e:	f04f 0901 	mov.w	r9, #1
  406772:	e585      	b.n	406280 <_dtoa_r+0x4f0>
  406774:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  406776:	2a00      	cmp	r2, #0
  406778:	f000 81a5 	beq.w	406ac6 <_dtoa_r+0xd36>
  40677c:	f203 4333 	addw	r3, r3, #1075	; 0x433
  406780:	9f08      	ldr	r7, [sp, #32]
  406782:	9d05      	ldr	r5, [sp, #20]
  406784:	e4ff      	b.n	406186 <_dtoa_r+0x3f6>
  406786:	f001 f87b 	bl	407880 <__multadd>
  40678a:	4657      	mov	r7, sl
  40678c:	4606      	mov	r6, r0
  40678e:	4681      	mov	r9, r0
  406790:	e631      	b.n	4063f6 <_dtoa_r+0x666>
  406792:	4601      	mov	r1, r0
  406794:	4620      	mov	r0, r4
  406796:	f8cd c008 	str.w	ip, [sp, #8]
  40679a:	f001 f867 	bl	40786c <_Bfree>
  40679e:	2201      	movs	r2, #1
  4067a0:	f8dd c008 	ldr.w	ip, [sp, #8]
  4067a4:	e654      	b.n	406450 <_dtoa_r+0x6c0>
  4067a6:	4658      	mov	r0, fp
  4067a8:	4641      	mov	r1, r8
  4067aa:	f001 fa43 	bl	407c34 <__mcmp>
  4067ae:	2800      	cmp	r0, #0
  4067b0:	f6bf ad91 	bge.w	4062d6 <_dtoa_r+0x546>
  4067b4:	9f04      	ldr	r7, [sp, #16]
  4067b6:	4659      	mov	r1, fp
  4067b8:	2300      	movs	r3, #0
  4067ba:	4620      	mov	r0, r4
  4067bc:	220a      	movs	r2, #10
  4067be:	3f01      	subs	r7, #1
  4067c0:	9704      	str	r7, [sp, #16]
  4067c2:	f001 f85d 	bl	407880 <__multadd>
  4067c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4067c8:	4683      	mov	fp, r0
  4067ca:	2b00      	cmp	r3, #0
  4067cc:	f47f adf0 	bne.w	4063b0 <_dtoa_r+0x620>
  4067d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4067d2:	2b00      	cmp	r3, #0
  4067d4:	f340 81f8 	ble.w	406bc8 <_dtoa_r+0xe38>
  4067d8:	9306      	str	r3, [sp, #24]
  4067da:	e583      	b.n	4062e4 <_dtoa_r+0x554>
  4067dc:	9807      	ldr	r0, [sp, #28]
  4067de:	f7ff bb0b 	b.w	405df8 <_dtoa_r+0x68>
  4067e2:	9b02      	ldr	r3, [sp, #8]
  4067e4:	2b00      	cmp	r3, #0
  4067e6:	f47f ad49 	bne.w	40627c <_dtoa_r+0x4ec>
  4067ea:	e7ad      	b.n	406748 <_dtoa_r+0x9b8>
  4067ec:	0040a138 	.word	0x0040a138
  4067f0:	0040a210 	.word	0x0040a210
  4067f4:	3ff00000 	.word	0x3ff00000
  4067f8:	401c0000 	.word	0x401c0000
  4067fc:	3fe00000 	.word	0x3fe00000
  406800:	40240000 	.word	0x40240000
  406804:	40140000 	.word	0x40140000
  406808:	9b20      	ldr	r3, [sp, #128]	; 0x80
  40680a:	2b02      	cmp	r3, #2
  40680c:	f77f ad67 	ble.w	4062de <_dtoa_r+0x54e>
  406810:	9b06      	ldr	r3, [sp, #24]
  406812:	2b00      	cmp	r3, #0
  406814:	d182      	bne.n	40671c <_dtoa_r+0x98c>
  406816:	4641      	mov	r1, r8
  406818:	2205      	movs	r2, #5
  40681a:	4620      	mov	r0, r4
  40681c:	f001 f830 	bl	407880 <__multadd>
  406820:	4680      	mov	r8, r0
  406822:	4641      	mov	r1, r8
  406824:	4658      	mov	r0, fp
  406826:	f001 fa05 	bl	407c34 <__mcmp>
  40682a:	2800      	cmp	r0, #0
  40682c:	f77f af76 	ble.w	40671c <_dtoa_r+0x98c>
  406830:	9a04      	ldr	r2, [sp, #16]
  406832:	9907      	ldr	r1, [sp, #28]
  406834:	2331      	movs	r3, #49	; 0x31
  406836:	3201      	adds	r2, #1
  406838:	9204      	str	r2, [sp, #16]
  40683a:	700b      	strb	r3, [r1, #0]
  40683c:	1c4d      	adds	r5, r1, #1
  40683e:	e771      	b.n	406724 <_dtoa_r+0x994>
  406840:	9a04      	ldr	r2, [sp, #16]
  406842:	3201      	adds	r2, #1
  406844:	9204      	str	r2, [sp, #16]
  406846:	9a07      	ldr	r2, [sp, #28]
  406848:	2331      	movs	r3, #49	; 0x31
  40684a:	7013      	strb	r3, [r2, #0]
  40684c:	e58d      	b.n	40636a <_dtoa_r+0x5da>
  40684e:	f8dd b008 	ldr.w	fp, [sp, #8]
  406852:	9c05      	ldr	r4, [sp, #20]
  406854:	e46f      	b.n	406136 <_dtoa_r+0x3a6>
  406856:	4640      	mov	r0, r8
  406858:	f002 f832 	bl	4088c0 <__aeabi_i2d>
  40685c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  406860:	f002 f894 	bl	40898c <__aeabi_dmul>
  406864:	2200      	movs	r2, #0
  406866:	4bbc      	ldr	r3, [pc, #752]	; (406b58 <_dtoa_r+0xdc8>)
  406868:	f001 fede 	bl	408628 <__adddf3>
  40686c:	4606      	mov	r6, r0
  40686e:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  406872:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  406876:	2200      	movs	r2, #0
  406878:	4bb8      	ldr	r3, [pc, #736]	; (406b5c <_dtoa_r+0xdcc>)
  40687a:	f001 fed3 	bl	408624 <__aeabi_dsub>
  40687e:	4632      	mov	r2, r6
  406880:	463b      	mov	r3, r7
  406882:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406886:	f002 fb11 	bl	408eac <__aeabi_dcmpgt>
  40688a:	4680      	mov	r8, r0
  40688c:	2800      	cmp	r0, #0
  40688e:	f040 80b3 	bne.w	4069f8 <_dtoa_r+0xc68>
  406892:	4632      	mov	r2, r6
  406894:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
  406898:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40689c:	f002 fae8 	bl	408e70 <__aeabi_dcmplt>
  4068a0:	b130      	cbz	r0, 4068b0 <_dtoa_r+0xb20>
  4068a2:	4646      	mov	r6, r8
  4068a4:	e73a      	b.n	40671c <_dtoa_r+0x98c>
  4068a6:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
  4068aa:	f8dd b008 	ldr.w	fp, [sp, #8]
  4068ae:	4644      	mov	r4, r8
  4068b0:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  4068b4:	e9cd 2302 	strd	r2, r3, [sp, #8]
  4068b8:	f7ff bb7a 	b.w	405fb0 <_dtoa_r+0x220>
  4068bc:	4659      	mov	r1, fp
  4068be:	9a08      	ldr	r2, [sp, #32]
  4068c0:	4620      	mov	r0, r4
  4068c2:	f001 f911 	bl	407ae8 <__pow5mult>
  4068c6:	4683      	mov	fp, r0
  4068c8:	e492      	b.n	4061f0 <_dtoa_r+0x460>
  4068ca:	9b08      	ldr	r3, [sp, #32]
  4068cc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  4068ce:	9708      	str	r7, [sp, #32]
  4068d0:	1afb      	subs	r3, r7, r3
  4068d2:	441a      	add	r2, r3
  4068d4:	920a      	str	r2, [sp, #40]	; 0x28
  4068d6:	2700      	movs	r7, #0
  4068d8:	e44f      	b.n	40617a <_dtoa_r+0x3ea>
  4068da:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  4068de:	f04f 0802 	mov.w	r8, #2
  4068e2:	e9cd 2302 	strd	r2, r3, [sp, #8]
  4068e6:	e62a      	b.n	40653e <_dtoa_r+0x7ae>
  4068e8:	2601      	movs	r6, #1
  4068ea:	9621      	str	r6, [sp, #132]	; 0x84
  4068ec:	960c      	str	r6, [sp, #48]	; 0x30
  4068ee:	9606      	str	r6, [sp, #24]
  4068f0:	2100      	movs	r1, #0
  4068f2:	6461      	str	r1, [r4, #68]	; 0x44
  4068f4:	e5f8      	b.n	4064e8 <_dtoa_r+0x758>
  4068f6:	461e      	mov	r6, r3
  4068f8:	e7fa      	b.n	4068f0 <_dtoa_r+0xb60>
  4068fa:	2a00      	cmp	r2, #0
  4068fc:	dd15      	ble.n	40692a <_dtoa_r+0xb9a>
  4068fe:	4659      	mov	r1, fp
  406900:	2201      	movs	r2, #1
  406902:	4620      	mov	r0, r4
  406904:	f8cd c008 	str.w	ip, [sp, #8]
  406908:	f001 f93e 	bl	407b88 <__lshift>
  40690c:	4641      	mov	r1, r8
  40690e:	4683      	mov	fp, r0
  406910:	f001 f990 	bl	407c34 <__mcmp>
  406914:	2800      	cmp	r0, #0
  406916:	f8dd c008 	ldr.w	ip, [sp, #8]
  40691a:	f340 814a 	ble.w	406bb2 <_dtoa_r+0xe22>
  40691e:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
  406922:	f000 8106 	beq.w	406b32 <_dtoa_r+0xda2>
  406926:	f10c 0c01 	add.w	ip, ip, #1
  40692a:	46b2      	mov	sl, r6
  40692c:	f887 c000 	strb.w	ip, [r7]
  406930:	1c7d      	adds	r5, r7, #1
  406932:	464e      	mov	r6, r9
  406934:	e519      	b.n	40636a <_dtoa_r+0x5da>
  406936:	d104      	bne.n	406942 <_dtoa_r+0xbb2>
  406938:	f01c 0f01 	tst.w	ip, #1
  40693c:	d001      	beq.n	406942 <_dtoa_r+0xbb2>
  40693e:	e504      	b.n	40634a <_dtoa_r+0x5ba>
  406940:	4615      	mov	r5, r2
  406942:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  406946:	2b30      	cmp	r3, #48	; 0x30
  406948:	f105 32ff 	add.w	r2, r5, #4294967295
  40694c:	d0f8      	beq.n	406940 <_dtoa_r+0xbb0>
  40694e:	e50c      	b.n	40636a <_dtoa_r+0x5da>
  406950:	9b04      	ldr	r3, [sp, #16]
  406952:	425d      	negs	r5, r3
  406954:	2d00      	cmp	r5, #0
  406956:	f000 80bd 	beq.w	406ad4 <_dtoa_r+0xd44>
  40695a:	4b81      	ldr	r3, [pc, #516]	; (406b60 <_dtoa_r+0xdd0>)
  40695c:	f005 020f 	and.w	r2, r5, #15
  406960:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  406964:	e9d3 2300 	ldrd	r2, r3, [r3]
  406968:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  40696c:	f002 f80e 	bl	40898c <__aeabi_dmul>
  406970:	112d      	asrs	r5, r5, #4
  406972:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406976:	f000 812c 	beq.w	406bd2 <_dtoa_r+0xe42>
  40697a:	4e7a      	ldr	r6, [pc, #488]	; (406b64 <_dtoa_r+0xdd4>)
  40697c:	f04f 0802 	mov.w	r8, #2
  406980:	07eb      	lsls	r3, r5, #31
  406982:	d505      	bpl.n	406990 <_dtoa_r+0xc00>
  406984:	e9d6 2300 	ldrd	r2, r3, [r6]
  406988:	f108 0801 	add.w	r8, r8, #1
  40698c:	f001 fffe 	bl	40898c <__aeabi_dmul>
  406990:	106d      	asrs	r5, r5, #1
  406992:	f106 0608 	add.w	r6, r6, #8
  406996:	d1f3      	bne.n	406980 <_dtoa_r+0xbf0>
  406998:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40699c:	e5ea      	b.n	406574 <_dtoa_r+0x7e4>
  40699e:	9a04      	ldr	r2, [sp, #16]
  4069a0:	3201      	adds	r2, #1
  4069a2:	9204      	str	r2, [sp, #16]
  4069a4:	9a07      	ldr	r2, [sp, #28]
  4069a6:	2330      	movs	r3, #48	; 0x30
  4069a8:	7013      	strb	r3, [r2, #0]
  4069aa:	2331      	movs	r3, #49	; 0x31
  4069ac:	7013      	strb	r3, [r2, #0]
  4069ae:	f7ff bbc2 	b.w	406136 <_dtoa_r+0x3a6>
  4069b2:	6871      	ldr	r1, [r6, #4]
  4069b4:	4620      	mov	r0, r4
  4069b6:	f000 ff33 	bl	407820 <_Balloc>
  4069ba:	6933      	ldr	r3, [r6, #16]
  4069bc:	1c9a      	adds	r2, r3, #2
  4069be:	4605      	mov	r5, r0
  4069c0:	0092      	lsls	r2, r2, #2
  4069c2:	f106 010c 	add.w	r1, r6, #12
  4069c6:	300c      	adds	r0, #12
  4069c8:	f7fd fb6a 	bl	4040a0 <memcpy>
  4069cc:	4620      	mov	r0, r4
  4069ce:	4629      	mov	r1, r5
  4069d0:	2201      	movs	r2, #1
  4069d2:	f001 f8d9 	bl	407b88 <__lshift>
  4069d6:	4681      	mov	r9, r0
  4069d8:	e503      	b.n	4063e2 <_dtoa_r+0x652>
  4069da:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
  4069de:	f000 80a8 	beq.w	406b32 <_dtoa_r+0xda2>
  4069e2:	f10c 0c01 	add.w	ip, ip, #1
  4069e6:	46b2      	mov	sl, r6
  4069e8:	f887 c000 	strb.w	ip, [r7]
  4069ec:	1c7d      	adds	r5, r7, #1
  4069ee:	464e      	mov	r6, r9
  4069f0:	e4bb      	b.n	40636a <_dtoa_r+0x5da>
  4069f2:	46b2      	mov	sl, r6
  4069f4:	464e      	mov	r6, r9
  4069f6:	e498      	b.n	40632a <_dtoa_r+0x59a>
  4069f8:	f04f 0800 	mov.w	r8, #0
  4069fc:	4646      	mov	r6, r8
  4069fe:	e717      	b.n	406830 <_dtoa_r+0xaa0>
  406a00:	4957      	ldr	r1, [pc, #348]	; (406b60 <_dtoa_r+0xdd0>)
  406a02:	f109 33ff 	add.w	r3, r9, #4294967295
  406a06:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
  406a0a:	4632      	mov	r2, r6
  406a0c:	9313      	str	r3, [sp, #76]	; 0x4c
  406a0e:	e9d1 0100 	ldrd	r0, r1, [r1]
  406a12:	463b      	mov	r3, r7
  406a14:	f001 ffba 	bl	40898c <__aeabi_dmul>
  406a18:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  406a1c:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
  406a20:	4639      	mov	r1, r7
  406a22:	4630      	mov	r0, r6
  406a24:	f002 fa4c 	bl	408ec0 <__aeabi_d2iz>
  406a28:	4605      	mov	r5, r0
  406a2a:	f001 ff49 	bl	4088c0 <__aeabi_i2d>
  406a2e:	4602      	mov	r2, r0
  406a30:	460b      	mov	r3, r1
  406a32:	4630      	mov	r0, r6
  406a34:	4639      	mov	r1, r7
  406a36:	f001 fdf5 	bl	408624 <__aeabi_dsub>
  406a3a:	9a07      	ldr	r2, [sp, #28]
  406a3c:	3530      	adds	r5, #48	; 0x30
  406a3e:	f1b9 0f01 	cmp.w	r9, #1
  406a42:	7015      	strb	r5, [r2, #0]
  406a44:	4606      	mov	r6, r0
  406a46:	460f      	mov	r7, r1
  406a48:	f102 0501 	add.w	r5, r2, #1
  406a4c:	d023      	beq.n	406a96 <_dtoa_r+0xd06>
  406a4e:	9b07      	ldr	r3, [sp, #28]
  406a50:	f8cd a008 	str.w	sl, [sp, #8]
  406a54:	444b      	add	r3, r9
  406a56:	465e      	mov	r6, fp
  406a58:	469a      	mov	sl, r3
  406a5a:	46ab      	mov	fp, r5
  406a5c:	2200      	movs	r2, #0
  406a5e:	4b42      	ldr	r3, [pc, #264]	; (406b68 <_dtoa_r+0xdd8>)
  406a60:	f001 ff94 	bl	40898c <__aeabi_dmul>
  406a64:	4689      	mov	r9, r1
  406a66:	4680      	mov	r8, r0
  406a68:	f002 fa2a 	bl	408ec0 <__aeabi_d2iz>
  406a6c:	4607      	mov	r7, r0
  406a6e:	f001 ff27 	bl	4088c0 <__aeabi_i2d>
  406a72:	3730      	adds	r7, #48	; 0x30
  406a74:	4602      	mov	r2, r0
  406a76:	460b      	mov	r3, r1
  406a78:	4640      	mov	r0, r8
  406a7a:	4649      	mov	r1, r9
  406a7c:	f001 fdd2 	bl	408624 <__aeabi_dsub>
  406a80:	f80b 7b01 	strb.w	r7, [fp], #1
  406a84:	45d3      	cmp	fp, sl
  406a86:	d1e9      	bne.n	406a5c <_dtoa_r+0xccc>
  406a88:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  406a8a:	f8dd a008 	ldr.w	sl, [sp, #8]
  406a8e:	46b3      	mov	fp, r6
  406a90:	460f      	mov	r7, r1
  406a92:	4606      	mov	r6, r0
  406a94:	441d      	add	r5, r3
  406a96:	2200      	movs	r2, #0
  406a98:	4b34      	ldr	r3, [pc, #208]	; (406b6c <_dtoa_r+0xddc>)
  406a9a:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  406a9e:	f001 fdc3 	bl	408628 <__adddf3>
  406aa2:	4632      	mov	r2, r6
  406aa4:	463b      	mov	r3, r7
  406aa6:	f002 f9e3 	bl	408e70 <__aeabi_dcmplt>
  406aaa:	2800      	cmp	r0, #0
  406aac:	d047      	beq.n	406b3e <_dtoa_r+0xdae>
  406aae:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406ab0:	9304      	str	r3, [sp, #16]
  406ab2:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  406ab6:	f7ff bb2c 	b.w	406112 <_dtoa_r+0x382>
  406aba:	9b05      	ldr	r3, [sp, #20]
  406abc:	9a06      	ldr	r2, [sp, #24]
  406abe:	1a9d      	subs	r5, r3, r2
  406ac0:	2300      	movs	r3, #0
  406ac2:	f7ff bb60 	b.w	406186 <_dtoa_r+0x3f6>
  406ac6:	9b14      	ldr	r3, [sp, #80]	; 0x50
  406ac8:	9f08      	ldr	r7, [sp, #32]
  406aca:	9d05      	ldr	r5, [sp, #20]
  406acc:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
  406ad0:	f7ff bb59 	b.w	406186 <_dtoa_r+0x3f6>
  406ad4:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  406ad8:	f04f 0802 	mov.w	r8, #2
  406adc:	e9cd 2302 	strd	r2, r3, [sp, #8]
  406ae0:	e548      	b.n	406574 <_dtoa_r+0x7e4>
  406ae2:	9b06      	ldr	r3, [sp, #24]
  406ae4:	2b00      	cmp	r3, #0
  406ae6:	f43f aeb6 	beq.w	406856 <_dtoa_r+0xac6>
  406aea:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  406aec:	2d00      	cmp	r5, #0
  406aee:	f77f aedf 	ble.w	4068b0 <_dtoa_r+0xb20>
  406af2:	2200      	movs	r2, #0
  406af4:	4b1c      	ldr	r3, [pc, #112]	; (406b68 <_dtoa_r+0xdd8>)
  406af6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  406afa:	f001 ff47 	bl	40898c <__aeabi_dmul>
  406afe:	4606      	mov	r6, r0
  406b00:	460f      	mov	r7, r1
  406b02:	f108 0001 	add.w	r0, r8, #1
  406b06:	e9cd 6702 	strd	r6, r7, [sp, #8]
  406b0a:	f001 fed9 	bl	4088c0 <__aeabi_i2d>
  406b0e:	4602      	mov	r2, r0
  406b10:	460b      	mov	r3, r1
  406b12:	4630      	mov	r0, r6
  406b14:	4639      	mov	r1, r7
  406b16:	f001 ff39 	bl	40898c <__aeabi_dmul>
  406b1a:	4b0f      	ldr	r3, [pc, #60]	; (406b58 <_dtoa_r+0xdc8>)
  406b1c:	2200      	movs	r2, #0
  406b1e:	f001 fd83 	bl	408628 <__adddf3>
  406b22:	9b04      	ldr	r3, [sp, #16]
  406b24:	3b01      	subs	r3, #1
  406b26:	4606      	mov	r6, r0
  406b28:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  406b2c:	9312      	str	r3, [sp, #72]	; 0x48
  406b2e:	46a9      	mov	r9, r5
  406b30:	e541      	b.n	4065b6 <_dtoa_r+0x826>
  406b32:	2239      	movs	r2, #57	; 0x39
  406b34:	46b2      	mov	sl, r6
  406b36:	703a      	strb	r2, [r7, #0]
  406b38:	464e      	mov	r6, r9
  406b3a:	1c7d      	adds	r5, r7, #1
  406b3c:	e407      	b.n	40634e <_dtoa_r+0x5be>
  406b3e:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
  406b42:	2000      	movs	r0, #0
  406b44:	4909      	ldr	r1, [pc, #36]	; (406b6c <_dtoa_r+0xddc>)
  406b46:	f001 fd6d 	bl	408624 <__aeabi_dsub>
  406b4a:	4632      	mov	r2, r6
  406b4c:	463b      	mov	r3, r7
  406b4e:	f002 f9ad 	bl	408eac <__aeabi_dcmpgt>
  406b52:	b970      	cbnz	r0, 406b72 <_dtoa_r+0xde2>
  406b54:	e6ac      	b.n	4068b0 <_dtoa_r+0xb20>
  406b56:	bf00      	nop
  406b58:	401c0000 	.word	0x401c0000
  406b5c:	40140000 	.word	0x40140000
  406b60:	0040a138 	.word	0x0040a138
  406b64:	0040a210 	.word	0x0040a210
  406b68:	40240000 	.word	0x40240000
  406b6c:	3fe00000 	.word	0x3fe00000
  406b70:	4615      	mov	r5, r2
  406b72:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  406b76:	2b30      	cmp	r3, #48	; 0x30
  406b78:	f105 32ff 	add.w	r2, r5, #4294967295
  406b7c:	d0f8      	beq.n	406b70 <_dtoa_r+0xde0>
  406b7e:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406b80:	9304      	str	r3, [sp, #16]
  406b82:	f7ff bad8 	b.w	406136 <_dtoa_r+0x3a6>
  406b86:	4643      	mov	r3, r8
  406b88:	f8dd b008 	ldr.w	fp, [sp, #8]
  406b8c:	46a0      	mov	r8, r4
  406b8e:	461c      	mov	r4, r3
  406b90:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406b92:	9304      	str	r3, [sp, #16]
  406b94:	f7ff babd 	b.w	406112 <_dtoa_r+0x382>
  406b98:	46b9      	mov	r9, r7
  406b9a:	f7ff bb71 	b.w	406280 <_dtoa_r+0x4f0>
  406b9e:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
  406ba2:	d0c6      	beq.n	406b32 <_dtoa_r+0xda2>
  406ba4:	f1ba 0f00 	cmp.w	sl, #0
  406ba8:	f77f aebf 	ble.w	40692a <_dtoa_r+0xb9a>
  406bac:	f105 0c31 	add.w	ip, r5, #49	; 0x31
  406bb0:	e6bb      	b.n	40692a <_dtoa_r+0xb9a>
  406bb2:	f47f aeba 	bne.w	40692a <_dtoa_r+0xb9a>
  406bb6:	f01c 0f01 	tst.w	ip, #1
  406bba:	f43f aeb6 	beq.w	40692a <_dtoa_r+0xb9a>
  406bbe:	e6ae      	b.n	40691e <_dtoa_r+0xb8e>
  406bc0:	f04f 0800 	mov.w	r8, #0
  406bc4:	4646      	mov	r6, r8
  406bc6:	e5a9      	b.n	40671c <_dtoa_r+0x98c>
  406bc8:	9b20      	ldr	r3, [sp, #128]	; 0x80
  406bca:	2b02      	cmp	r3, #2
  406bcc:	dc04      	bgt.n	406bd8 <_dtoa_r+0xe48>
  406bce:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  406bd0:	e602      	b.n	4067d8 <_dtoa_r+0xa48>
  406bd2:	f04f 0802 	mov.w	r8, #2
  406bd6:	e4cd      	b.n	406574 <_dtoa_r+0x7e4>
  406bd8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  406bda:	9306      	str	r3, [sp, #24]
  406bdc:	e618      	b.n	406810 <_dtoa_r+0xa80>
  406bde:	9b20      	ldr	r3, [sp, #128]	; 0x80
  406be0:	2b02      	cmp	r3, #2
  406be2:	dcf9      	bgt.n	406bd8 <_dtoa_r+0xe48>
  406be4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  406be6:	f7ff bbee 	b.w	4063c6 <_dtoa_r+0x636>
  406bea:	2500      	movs	r5, #0
  406bec:	6465      	str	r5, [r4, #68]	; 0x44
  406bee:	4629      	mov	r1, r5
  406bf0:	4620      	mov	r0, r4
  406bf2:	f000 fe15 	bl	407820 <_Balloc>
  406bf6:	f04f 33ff 	mov.w	r3, #4294967295
  406bfa:	9306      	str	r3, [sp, #24]
  406bfc:	930c      	str	r3, [sp, #48]	; 0x30
  406bfe:	2301      	movs	r3, #1
  406c00:	9007      	str	r0, [sp, #28]
  406c02:	9521      	str	r5, [sp, #132]	; 0x84
  406c04:	6420      	str	r0, [r4, #64]	; 0x40
  406c06:	9309      	str	r3, [sp, #36]	; 0x24
  406c08:	f7ff b9d2 	b.w	405fb0 <_dtoa_r+0x220>
  406c0c:	f43f ab4d 	beq.w	4062aa <_dtoa_r+0x51a>
  406c10:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
  406c14:	f7ff bb44 	b.w	4062a0 <_dtoa_r+0x510>
  406c18:	2301      	movs	r3, #1
  406c1a:	9309      	str	r3, [sp, #36]	; 0x24
  406c1c:	e559      	b.n	4066d2 <_dtoa_r+0x942>
  406c1e:	2501      	movs	r5, #1
  406c20:	f7ff b990 	b.w	405f44 <_dtoa_r+0x1b4>

00406c24 <__sflush_r>:
  406c24:	898b      	ldrh	r3, [r1, #12]
  406c26:	b29a      	uxth	r2, r3
  406c28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  406c2c:	460d      	mov	r5, r1
  406c2e:	0711      	lsls	r1, r2, #28
  406c30:	4680      	mov	r8, r0
  406c32:	d43c      	bmi.n	406cae <__sflush_r+0x8a>
  406c34:	686a      	ldr	r2, [r5, #4]
  406c36:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  406c3a:	2a00      	cmp	r2, #0
  406c3c:	81ab      	strh	r3, [r5, #12]
  406c3e:	dd65      	ble.n	406d0c <__sflush_r+0xe8>
  406c40:	6aae      	ldr	r6, [r5, #40]	; 0x28
  406c42:	2e00      	cmp	r6, #0
  406c44:	d04b      	beq.n	406cde <__sflush_r+0xba>
  406c46:	b29b      	uxth	r3, r3
  406c48:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
  406c4c:	2100      	movs	r1, #0
  406c4e:	b292      	uxth	r2, r2
  406c50:	f8d8 4000 	ldr.w	r4, [r8]
  406c54:	f8c8 1000 	str.w	r1, [r8]
  406c58:	2a00      	cmp	r2, #0
  406c5a:	d05b      	beq.n	406d14 <__sflush_r+0xf0>
  406c5c:	6d2a      	ldr	r2, [r5, #80]	; 0x50
  406c5e:	075f      	lsls	r7, r3, #29
  406c60:	d505      	bpl.n	406c6e <__sflush_r+0x4a>
  406c62:	6869      	ldr	r1, [r5, #4]
  406c64:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  406c66:	1a52      	subs	r2, r2, r1
  406c68:	b10b      	cbz	r3, 406c6e <__sflush_r+0x4a>
  406c6a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  406c6c:	1ad2      	subs	r2, r2, r3
  406c6e:	4640      	mov	r0, r8
  406c70:	69e9      	ldr	r1, [r5, #28]
  406c72:	2300      	movs	r3, #0
  406c74:	47b0      	blx	r6
  406c76:	1c46      	adds	r6, r0, #1
  406c78:	d056      	beq.n	406d28 <__sflush_r+0x104>
  406c7a:	89ab      	ldrh	r3, [r5, #12]
  406c7c:	692a      	ldr	r2, [r5, #16]
  406c7e:	602a      	str	r2, [r5, #0]
  406c80:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  406c84:	b29b      	uxth	r3, r3
  406c86:	2200      	movs	r2, #0
  406c88:	606a      	str	r2, [r5, #4]
  406c8a:	04da      	lsls	r2, r3, #19
  406c8c:	81ab      	strh	r3, [r5, #12]
  406c8e:	d43b      	bmi.n	406d08 <__sflush_r+0xe4>
  406c90:	6b29      	ldr	r1, [r5, #48]	; 0x30
  406c92:	f8c8 4000 	str.w	r4, [r8]
  406c96:	b311      	cbz	r1, 406cde <__sflush_r+0xba>
  406c98:	f105 0340 	add.w	r3, r5, #64	; 0x40
  406c9c:	4299      	cmp	r1, r3
  406c9e:	d002      	beq.n	406ca6 <__sflush_r+0x82>
  406ca0:	4640      	mov	r0, r8
  406ca2:	f000 f96b 	bl	406f7c <_free_r>
  406ca6:	2000      	movs	r0, #0
  406ca8:	6328      	str	r0, [r5, #48]	; 0x30
  406caa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  406cae:	692e      	ldr	r6, [r5, #16]
  406cb0:	b1ae      	cbz	r6, 406cde <__sflush_r+0xba>
  406cb2:	682c      	ldr	r4, [r5, #0]
  406cb4:	602e      	str	r6, [r5, #0]
  406cb6:	0791      	lsls	r1, r2, #30
  406cb8:	bf0c      	ite	eq
  406cba:	696b      	ldreq	r3, [r5, #20]
  406cbc:	2300      	movne	r3, #0
  406cbe:	1ba4      	subs	r4, r4, r6
  406cc0:	60ab      	str	r3, [r5, #8]
  406cc2:	e00a      	b.n	406cda <__sflush_r+0xb6>
  406cc4:	4632      	mov	r2, r6
  406cc6:	4623      	mov	r3, r4
  406cc8:	6a6f      	ldr	r7, [r5, #36]	; 0x24
  406cca:	69e9      	ldr	r1, [r5, #28]
  406ccc:	4640      	mov	r0, r8
  406cce:	47b8      	blx	r7
  406cd0:	2800      	cmp	r0, #0
  406cd2:	eba4 0400 	sub.w	r4, r4, r0
  406cd6:	4406      	add	r6, r0
  406cd8:	dd04      	ble.n	406ce4 <__sflush_r+0xc0>
  406cda:	2c00      	cmp	r4, #0
  406cdc:	dcf2      	bgt.n	406cc4 <__sflush_r+0xa0>
  406cde:	2000      	movs	r0, #0
  406ce0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  406ce4:	89ab      	ldrh	r3, [r5, #12]
  406ce6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  406cea:	81ab      	strh	r3, [r5, #12]
  406cec:	f04f 30ff 	mov.w	r0, #4294967295
  406cf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  406cf4:	89ab      	ldrh	r3, [r5, #12]
  406cf6:	692a      	ldr	r2, [r5, #16]
  406cf8:	6069      	str	r1, [r5, #4]
  406cfa:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  406cfe:	b29b      	uxth	r3, r3
  406d00:	81ab      	strh	r3, [r5, #12]
  406d02:	04db      	lsls	r3, r3, #19
  406d04:	602a      	str	r2, [r5, #0]
  406d06:	d5c3      	bpl.n	406c90 <__sflush_r+0x6c>
  406d08:	6528      	str	r0, [r5, #80]	; 0x50
  406d0a:	e7c1      	b.n	406c90 <__sflush_r+0x6c>
  406d0c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
  406d0e:	2a00      	cmp	r2, #0
  406d10:	dc96      	bgt.n	406c40 <__sflush_r+0x1c>
  406d12:	e7e4      	b.n	406cde <__sflush_r+0xba>
  406d14:	2301      	movs	r3, #1
  406d16:	4640      	mov	r0, r8
  406d18:	69e9      	ldr	r1, [r5, #28]
  406d1a:	47b0      	blx	r6
  406d1c:	1c43      	adds	r3, r0, #1
  406d1e:	4602      	mov	r2, r0
  406d20:	d019      	beq.n	406d56 <__sflush_r+0x132>
  406d22:	89ab      	ldrh	r3, [r5, #12]
  406d24:	6aae      	ldr	r6, [r5, #40]	; 0x28
  406d26:	e79a      	b.n	406c5e <__sflush_r+0x3a>
  406d28:	f8d8 1000 	ldr.w	r1, [r8]
  406d2c:	2900      	cmp	r1, #0
  406d2e:	d0e1      	beq.n	406cf4 <__sflush_r+0xd0>
  406d30:	291d      	cmp	r1, #29
  406d32:	d007      	beq.n	406d44 <__sflush_r+0x120>
  406d34:	2916      	cmp	r1, #22
  406d36:	d005      	beq.n	406d44 <__sflush_r+0x120>
  406d38:	89ab      	ldrh	r3, [r5, #12]
  406d3a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  406d3e:	81ab      	strh	r3, [r5, #12]
  406d40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  406d44:	89ab      	ldrh	r3, [r5, #12]
  406d46:	692a      	ldr	r2, [r5, #16]
  406d48:	602a      	str	r2, [r5, #0]
  406d4a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  406d4e:	2200      	movs	r2, #0
  406d50:	81ab      	strh	r3, [r5, #12]
  406d52:	606a      	str	r2, [r5, #4]
  406d54:	e79c      	b.n	406c90 <__sflush_r+0x6c>
  406d56:	f8d8 3000 	ldr.w	r3, [r8]
  406d5a:	2b00      	cmp	r3, #0
  406d5c:	d0e1      	beq.n	406d22 <__sflush_r+0xfe>
  406d5e:	2b1d      	cmp	r3, #29
  406d60:	d007      	beq.n	406d72 <__sflush_r+0x14e>
  406d62:	2b16      	cmp	r3, #22
  406d64:	d005      	beq.n	406d72 <__sflush_r+0x14e>
  406d66:	89ab      	ldrh	r3, [r5, #12]
  406d68:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  406d6c:	81ab      	strh	r3, [r5, #12]
  406d6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  406d72:	f8c8 4000 	str.w	r4, [r8]
  406d76:	e7b2      	b.n	406cde <__sflush_r+0xba>

00406d78 <_fflush_r>:
  406d78:	b510      	push	{r4, lr}
  406d7a:	4604      	mov	r4, r0
  406d7c:	b082      	sub	sp, #8
  406d7e:	b108      	cbz	r0, 406d84 <_fflush_r+0xc>
  406d80:	6b83      	ldr	r3, [r0, #56]	; 0x38
  406d82:	b153      	cbz	r3, 406d9a <_fflush_r+0x22>
  406d84:	f9b1 000c 	ldrsh.w	r0, [r1, #12]
  406d88:	b908      	cbnz	r0, 406d8e <_fflush_r+0x16>
  406d8a:	b002      	add	sp, #8
  406d8c:	bd10      	pop	{r4, pc}
  406d8e:	4620      	mov	r0, r4
  406d90:	b002      	add	sp, #8
  406d92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  406d96:	f7ff bf45 	b.w	406c24 <__sflush_r>
  406d9a:	9101      	str	r1, [sp, #4]
  406d9c:	f000 f880 	bl	406ea0 <__sinit>
  406da0:	9901      	ldr	r1, [sp, #4]
  406da2:	e7ef      	b.n	406d84 <_fflush_r+0xc>

00406da4 <_cleanup_r>:
  406da4:	4901      	ldr	r1, [pc, #4]	; (406dac <_cleanup_r+0x8>)
  406da6:	f000 b9c1 	b.w	40712c <_fwalk_reent>
  406daa:	bf00      	nop
  406dac:	00408549 	.word	0x00408549

00406db0 <__sinit.part.1>:
  406db0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406db4:	4b35      	ldr	r3, [pc, #212]	; (406e8c <__sinit.part.1+0xdc>)
  406db6:	6845      	ldr	r5, [r0, #4]
  406db8:	63c3      	str	r3, [r0, #60]	; 0x3c
  406dba:	2400      	movs	r4, #0
  406dbc:	4607      	mov	r7, r0
  406dbe:	f500 723b 	add.w	r2, r0, #748	; 0x2ec
  406dc2:	2304      	movs	r3, #4
  406dc4:	2103      	movs	r1, #3
  406dc6:	f8c0 12e4 	str.w	r1, [r0, #740]	; 0x2e4
  406dca:	f8c0 22e8 	str.w	r2, [r0, #744]	; 0x2e8
  406dce:	f8c0 42e0 	str.w	r4, [r0, #736]	; 0x2e0
  406dd2:	b083      	sub	sp, #12
  406dd4:	602c      	str	r4, [r5, #0]
  406dd6:	606c      	str	r4, [r5, #4]
  406dd8:	60ac      	str	r4, [r5, #8]
  406dda:	666c      	str	r4, [r5, #100]	; 0x64
  406ddc:	81ec      	strh	r4, [r5, #14]
  406dde:	612c      	str	r4, [r5, #16]
  406de0:	616c      	str	r4, [r5, #20]
  406de2:	61ac      	str	r4, [r5, #24]
  406de4:	81ab      	strh	r3, [r5, #12]
  406de6:	4621      	mov	r1, r4
  406de8:	f105 005c 	add.w	r0, r5, #92	; 0x5c
  406dec:	2208      	movs	r2, #8
  406dee:	f7fd f9f1 	bl	4041d4 <memset>
  406df2:	68be      	ldr	r6, [r7, #8]
  406df4:	f8df b098 	ldr.w	fp, [pc, #152]	; 406e90 <__sinit.part.1+0xe0>
  406df8:	f8df a098 	ldr.w	sl, [pc, #152]	; 406e94 <__sinit.part.1+0xe4>
  406dfc:	f8df 9098 	ldr.w	r9, [pc, #152]	; 406e98 <__sinit.part.1+0xe8>
  406e00:	f8df 8098 	ldr.w	r8, [pc, #152]	; 406e9c <__sinit.part.1+0xec>
  406e04:	f8c5 b020 	str.w	fp, [r5, #32]
  406e08:	2301      	movs	r3, #1
  406e0a:	2209      	movs	r2, #9
  406e0c:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
  406e10:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  406e14:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
  406e18:	61ed      	str	r5, [r5, #28]
  406e1a:	4621      	mov	r1, r4
  406e1c:	81f3      	strh	r3, [r6, #14]
  406e1e:	81b2      	strh	r2, [r6, #12]
  406e20:	f106 005c 	add.w	r0, r6, #92	; 0x5c
  406e24:	6034      	str	r4, [r6, #0]
  406e26:	6074      	str	r4, [r6, #4]
  406e28:	60b4      	str	r4, [r6, #8]
  406e2a:	6674      	str	r4, [r6, #100]	; 0x64
  406e2c:	6134      	str	r4, [r6, #16]
  406e2e:	6174      	str	r4, [r6, #20]
  406e30:	61b4      	str	r4, [r6, #24]
  406e32:	2208      	movs	r2, #8
  406e34:	9301      	str	r3, [sp, #4]
  406e36:	f7fd f9cd 	bl	4041d4 <memset>
  406e3a:	68fd      	ldr	r5, [r7, #12]
  406e3c:	61f6      	str	r6, [r6, #28]
  406e3e:	2012      	movs	r0, #18
  406e40:	2202      	movs	r2, #2
  406e42:	f8c6 b020 	str.w	fp, [r6, #32]
  406e46:	f8c6 a024 	str.w	sl, [r6, #36]	; 0x24
  406e4a:	f8c6 9028 	str.w	r9, [r6, #40]	; 0x28
  406e4e:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
  406e52:	4621      	mov	r1, r4
  406e54:	81a8      	strh	r0, [r5, #12]
  406e56:	81ea      	strh	r2, [r5, #14]
  406e58:	602c      	str	r4, [r5, #0]
  406e5a:	606c      	str	r4, [r5, #4]
  406e5c:	60ac      	str	r4, [r5, #8]
  406e5e:	666c      	str	r4, [r5, #100]	; 0x64
  406e60:	612c      	str	r4, [r5, #16]
  406e62:	616c      	str	r4, [r5, #20]
  406e64:	61ac      	str	r4, [r5, #24]
  406e66:	f105 005c 	add.w	r0, r5, #92	; 0x5c
  406e6a:	2208      	movs	r2, #8
  406e6c:	f7fd f9b2 	bl	4041d4 <memset>
  406e70:	9b01      	ldr	r3, [sp, #4]
  406e72:	61ed      	str	r5, [r5, #28]
  406e74:	f8c5 b020 	str.w	fp, [r5, #32]
  406e78:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
  406e7c:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  406e80:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
  406e84:	63bb      	str	r3, [r7, #56]	; 0x38
  406e86:	b003      	add	sp, #12
  406e88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406e8c:	00406da5 	.word	0x00406da5
  406e90:	00408271 	.word	0x00408271
  406e94:	00408295 	.word	0x00408295
  406e98:	004082cd 	.word	0x004082cd
  406e9c:	004082ed 	.word	0x004082ed

00406ea0 <__sinit>:
  406ea0:	6b83      	ldr	r3, [r0, #56]	; 0x38
  406ea2:	b103      	cbz	r3, 406ea6 <__sinit+0x6>
  406ea4:	4770      	bx	lr
  406ea6:	f7ff bf83 	b.w	406db0 <__sinit.part.1>
  406eaa:	bf00      	nop

00406eac <__sfp_lock_acquire>:
  406eac:	4770      	bx	lr
  406eae:	bf00      	nop

00406eb0 <__sfp_lock_release>:
  406eb0:	4770      	bx	lr
  406eb2:	bf00      	nop

00406eb4 <__libc_fini_array>:
  406eb4:	b538      	push	{r3, r4, r5, lr}
  406eb6:	4b08      	ldr	r3, [pc, #32]	; (406ed8 <__libc_fini_array+0x24>)
  406eb8:	4d08      	ldr	r5, [pc, #32]	; (406edc <__libc_fini_array+0x28>)
  406eba:	1aed      	subs	r5, r5, r3
  406ebc:	10ac      	asrs	r4, r5, #2
  406ebe:	bf18      	it	ne
  406ec0:	18ed      	addne	r5, r5, r3
  406ec2:	d005      	beq.n	406ed0 <__libc_fini_array+0x1c>
  406ec4:	3c01      	subs	r4, #1
  406ec6:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  406eca:	4798      	blx	r3
  406ecc:	2c00      	cmp	r4, #0
  406ece:	d1f9      	bne.n	406ec4 <__libc_fini_array+0x10>
  406ed0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  406ed4:	f003 b9ba 	b.w	40a24c <_fini>
  406ed8:	0040a258 	.word	0x0040a258
  406edc:	0040a25c 	.word	0x0040a25c

00406ee0 <_malloc_trim_r>:
  406ee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406ee2:	4f23      	ldr	r7, [pc, #140]	; (406f70 <_malloc_trim_r+0x90>)
  406ee4:	460c      	mov	r4, r1
  406ee6:	4606      	mov	r6, r0
  406ee8:	f000 fc96 	bl	407818 <__malloc_lock>
  406eec:	68bb      	ldr	r3, [r7, #8]
  406eee:	685d      	ldr	r5, [r3, #4]
  406ef0:	f025 0503 	bic.w	r5, r5, #3
  406ef4:	1b29      	subs	r1, r5, r4
  406ef6:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
  406efa:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  406efe:	f021 010f 	bic.w	r1, r1, #15
  406f02:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
  406f06:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
  406f0a:	db07      	blt.n	406f1c <_malloc_trim_r+0x3c>
  406f0c:	4630      	mov	r0, r6
  406f0e:	2100      	movs	r1, #0
  406f10:	f001 f99c 	bl	40824c <_sbrk_r>
  406f14:	68bb      	ldr	r3, [r7, #8]
  406f16:	442b      	add	r3, r5
  406f18:	4298      	cmp	r0, r3
  406f1a:	d004      	beq.n	406f26 <_malloc_trim_r+0x46>
  406f1c:	4630      	mov	r0, r6
  406f1e:	f000 fc7d 	bl	40781c <__malloc_unlock>
  406f22:	2000      	movs	r0, #0
  406f24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406f26:	4630      	mov	r0, r6
  406f28:	4261      	negs	r1, r4
  406f2a:	f001 f98f 	bl	40824c <_sbrk_r>
  406f2e:	3001      	adds	r0, #1
  406f30:	d00d      	beq.n	406f4e <_malloc_trim_r+0x6e>
  406f32:	4b10      	ldr	r3, [pc, #64]	; (406f74 <_malloc_trim_r+0x94>)
  406f34:	68ba      	ldr	r2, [r7, #8]
  406f36:	6819      	ldr	r1, [r3, #0]
  406f38:	1b2d      	subs	r5, r5, r4
  406f3a:	f045 0501 	orr.w	r5, r5, #1
  406f3e:	4630      	mov	r0, r6
  406f40:	1b09      	subs	r1, r1, r4
  406f42:	6055      	str	r5, [r2, #4]
  406f44:	6019      	str	r1, [r3, #0]
  406f46:	f000 fc69 	bl	40781c <__malloc_unlock>
  406f4a:	2001      	movs	r0, #1
  406f4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406f4e:	4630      	mov	r0, r6
  406f50:	2100      	movs	r1, #0
  406f52:	f001 f97b 	bl	40824c <_sbrk_r>
  406f56:	68ba      	ldr	r2, [r7, #8]
  406f58:	1a83      	subs	r3, r0, r2
  406f5a:	2b0f      	cmp	r3, #15
  406f5c:	ddde      	ble.n	406f1c <_malloc_trim_r+0x3c>
  406f5e:	4c06      	ldr	r4, [pc, #24]	; (406f78 <_malloc_trim_r+0x98>)
  406f60:	4904      	ldr	r1, [pc, #16]	; (406f74 <_malloc_trim_r+0x94>)
  406f62:	6824      	ldr	r4, [r4, #0]
  406f64:	f043 0301 	orr.w	r3, r3, #1
  406f68:	1b00      	subs	r0, r0, r4
  406f6a:	6053      	str	r3, [r2, #4]
  406f6c:	6008      	str	r0, [r1, #0]
  406f6e:	e7d5      	b.n	406f1c <_malloc_trim_r+0x3c>
  406f70:	20000488 	.word	0x20000488
  406f74:	20004edc 	.word	0x20004edc
  406f78:	20000894 	.word	0x20000894

00406f7c <_free_r>:
  406f7c:	2900      	cmp	r1, #0
  406f7e:	d04e      	beq.n	40701e <_free_r+0xa2>
  406f80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  406f84:	460c      	mov	r4, r1
  406f86:	4680      	mov	r8, r0
  406f88:	f000 fc46 	bl	407818 <__malloc_lock>
  406f8c:	f854 7c04 	ldr.w	r7, [r4, #-4]
  406f90:	4962      	ldr	r1, [pc, #392]	; (40711c <_free_r+0x1a0>)
  406f92:	f027 0201 	bic.w	r2, r7, #1
  406f96:	f1a4 0508 	sub.w	r5, r4, #8
  406f9a:	18ab      	adds	r3, r5, r2
  406f9c:	688e      	ldr	r6, [r1, #8]
  406f9e:	6858      	ldr	r0, [r3, #4]
  406fa0:	429e      	cmp	r6, r3
  406fa2:	f020 0003 	bic.w	r0, r0, #3
  406fa6:	d05a      	beq.n	40705e <_free_r+0xe2>
  406fa8:	07fe      	lsls	r6, r7, #31
  406faa:	6058      	str	r0, [r3, #4]
  406fac:	d40b      	bmi.n	406fc6 <_free_r+0x4a>
  406fae:	f854 7c08 	ldr.w	r7, [r4, #-8]
  406fb2:	1bed      	subs	r5, r5, r7
  406fb4:	f101 0e08 	add.w	lr, r1, #8
  406fb8:	68ac      	ldr	r4, [r5, #8]
  406fba:	4574      	cmp	r4, lr
  406fbc:	443a      	add	r2, r7
  406fbe:	d067      	beq.n	407090 <_free_r+0x114>
  406fc0:	68ef      	ldr	r7, [r5, #12]
  406fc2:	60e7      	str	r7, [r4, #12]
  406fc4:	60bc      	str	r4, [r7, #8]
  406fc6:	181c      	adds	r4, r3, r0
  406fc8:	6864      	ldr	r4, [r4, #4]
  406fca:	07e4      	lsls	r4, r4, #31
  406fcc:	d40c      	bmi.n	406fe8 <_free_r+0x6c>
  406fce:	4f54      	ldr	r7, [pc, #336]	; (407120 <_free_r+0x1a4>)
  406fd0:	689c      	ldr	r4, [r3, #8]
  406fd2:	42bc      	cmp	r4, r7
  406fd4:	4402      	add	r2, r0
  406fd6:	d07c      	beq.n	4070d2 <_free_r+0x156>
  406fd8:	68d8      	ldr	r0, [r3, #12]
  406fda:	60e0      	str	r0, [r4, #12]
  406fdc:	f042 0301 	orr.w	r3, r2, #1
  406fe0:	6084      	str	r4, [r0, #8]
  406fe2:	606b      	str	r3, [r5, #4]
  406fe4:	50aa      	str	r2, [r5, r2]
  406fe6:	e003      	b.n	406ff0 <_free_r+0x74>
  406fe8:	f042 0301 	orr.w	r3, r2, #1
  406fec:	606b      	str	r3, [r5, #4]
  406fee:	50aa      	str	r2, [r5, r2]
  406ff0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  406ff4:	d214      	bcs.n	407020 <_free_r+0xa4>
  406ff6:	08d2      	lsrs	r2, r2, #3
  406ff8:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
  406ffc:	6848      	ldr	r0, [r1, #4]
  406ffe:	689f      	ldr	r7, [r3, #8]
  407000:	60af      	str	r7, [r5, #8]
  407002:	1092      	asrs	r2, r2, #2
  407004:	2401      	movs	r4, #1
  407006:	fa04 f202 	lsl.w	r2, r4, r2
  40700a:	4310      	orrs	r0, r2
  40700c:	60eb      	str	r3, [r5, #12]
  40700e:	6048      	str	r0, [r1, #4]
  407010:	609d      	str	r5, [r3, #8]
  407012:	60fd      	str	r5, [r7, #12]
  407014:	4640      	mov	r0, r8
  407016:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40701a:	f000 bbff 	b.w	40781c <__malloc_unlock>
  40701e:	4770      	bx	lr
  407020:	0a53      	lsrs	r3, r2, #9
  407022:	2b04      	cmp	r3, #4
  407024:	d847      	bhi.n	4070b6 <_free_r+0x13a>
  407026:	0993      	lsrs	r3, r2, #6
  407028:	f103 0438 	add.w	r4, r3, #56	; 0x38
  40702c:	0060      	lsls	r0, r4, #1
  40702e:	eb01 0080 	add.w	r0, r1, r0, lsl #2
  407032:	493a      	ldr	r1, [pc, #232]	; (40711c <_free_r+0x1a0>)
  407034:	6883      	ldr	r3, [r0, #8]
  407036:	4283      	cmp	r3, r0
  407038:	d043      	beq.n	4070c2 <_free_r+0x146>
  40703a:	6859      	ldr	r1, [r3, #4]
  40703c:	f021 0103 	bic.w	r1, r1, #3
  407040:	4291      	cmp	r1, r2
  407042:	d902      	bls.n	40704a <_free_r+0xce>
  407044:	689b      	ldr	r3, [r3, #8]
  407046:	4298      	cmp	r0, r3
  407048:	d1f7      	bne.n	40703a <_free_r+0xbe>
  40704a:	68da      	ldr	r2, [r3, #12]
  40704c:	60ea      	str	r2, [r5, #12]
  40704e:	60ab      	str	r3, [r5, #8]
  407050:	4640      	mov	r0, r8
  407052:	6095      	str	r5, [r2, #8]
  407054:	60dd      	str	r5, [r3, #12]
  407056:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40705a:	f000 bbdf 	b.w	40781c <__malloc_unlock>
  40705e:	07ff      	lsls	r7, r7, #31
  407060:	4402      	add	r2, r0
  407062:	d407      	bmi.n	407074 <_free_r+0xf8>
  407064:	f854 3c08 	ldr.w	r3, [r4, #-8]
  407068:	1aed      	subs	r5, r5, r3
  40706a:	441a      	add	r2, r3
  40706c:	68a8      	ldr	r0, [r5, #8]
  40706e:	68eb      	ldr	r3, [r5, #12]
  407070:	60c3      	str	r3, [r0, #12]
  407072:	6098      	str	r0, [r3, #8]
  407074:	4b2b      	ldr	r3, [pc, #172]	; (407124 <_free_r+0x1a8>)
  407076:	681b      	ldr	r3, [r3, #0]
  407078:	f042 0001 	orr.w	r0, r2, #1
  40707c:	429a      	cmp	r2, r3
  40707e:	6068      	str	r0, [r5, #4]
  407080:	608d      	str	r5, [r1, #8]
  407082:	d3c7      	bcc.n	407014 <_free_r+0x98>
  407084:	4b28      	ldr	r3, [pc, #160]	; (407128 <_free_r+0x1ac>)
  407086:	4640      	mov	r0, r8
  407088:	6819      	ldr	r1, [r3, #0]
  40708a:	f7ff ff29 	bl	406ee0 <_malloc_trim_r>
  40708e:	e7c1      	b.n	407014 <_free_r+0x98>
  407090:	1819      	adds	r1, r3, r0
  407092:	6849      	ldr	r1, [r1, #4]
  407094:	07c9      	lsls	r1, r1, #31
  407096:	d409      	bmi.n	4070ac <_free_r+0x130>
  407098:	68d9      	ldr	r1, [r3, #12]
  40709a:	689b      	ldr	r3, [r3, #8]
  40709c:	4402      	add	r2, r0
  40709e:	f042 0001 	orr.w	r0, r2, #1
  4070a2:	60d9      	str	r1, [r3, #12]
  4070a4:	608b      	str	r3, [r1, #8]
  4070a6:	6068      	str	r0, [r5, #4]
  4070a8:	50aa      	str	r2, [r5, r2]
  4070aa:	e7b3      	b.n	407014 <_free_r+0x98>
  4070ac:	f042 0301 	orr.w	r3, r2, #1
  4070b0:	606b      	str	r3, [r5, #4]
  4070b2:	50aa      	str	r2, [r5, r2]
  4070b4:	e7ae      	b.n	407014 <_free_r+0x98>
  4070b6:	2b14      	cmp	r3, #20
  4070b8:	d814      	bhi.n	4070e4 <_free_r+0x168>
  4070ba:	f103 045b 	add.w	r4, r3, #91	; 0x5b
  4070be:	0060      	lsls	r0, r4, #1
  4070c0:	e7b5      	b.n	40702e <_free_r+0xb2>
  4070c2:	684a      	ldr	r2, [r1, #4]
  4070c4:	10a4      	asrs	r4, r4, #2
  4070c6:	2001      	movs	r0, #1
  4070c8:	40a0      	lsls	r0, r4
  4070ca:	4302      	orrs	r2, r0
  4070cc:	604a      	str	r2, [r1, #4]
  4070ce:	461a      	mov	r2, r3
  4070d0:	e7bc      	b.n	40704c <_free_r+0xd0>
  4070d2:	f042 0301 	orr.w	r3, r2, #1
  4070d6:	614d      	str	r5, [r1, #20]
  4070d8:	610d      	str	r5, [r1, #16]
  4070da:	60ec      	str	r4, [r5, #12]
  4070dc:	60ac      	str	r4, [r5, #8]
  4070de:	606b      	str	r3, [r5, #4]
  4070e0:	50aa      	str	r2, [r5, r2]
  4070e2:	e797      	b.n	407014 <_free_r+0x98>
  4070e4:	2b54      	cmp	r3, #84	; 0x54
  4070e6:	d804      	bhi.n	4070f2 <_free_r+0x176>
  4070e8:	0b13      	lsrs	r3, r2, #12
  4070ea:	f103 046e 	add.w	r4, r3, #110	; 0x6e
  4070ee:	0060      	lsls	r0, r4, #1
  4070f0:	e79d      	b.n	40702e <_free_r+0xb2>
  4070f2:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  4070f6:	d804      	bhi.n	407102 <_free_r+0x186>
  4070f8:	0bd3      	lsrs	r3, r2, #15
  4070fa:	f103 0477 	add.w	r4, r3, #119	; 0x77
  4070fe:	0060      	lsls	r0, r4, #1
  407100:	e795      	b.n	40702e <_free_r+0xb2>
  407102:	f240 5054 	movw	r0, #1364	; 0x554
  407106:	4283      	cmp	r3, r0
  407108:	d804      	bhi.n	407114 <_free_r+0x198>
  40710a:	0c93      	lsrs	r3, r2, #18
  40710c:	f103 047c 	add.w	r4, r3, #124	; 0x7c
  407110:	0060      	lsls	r0, r4, #1
  407112:	e78c      	b.n	40702e <_free_r+0xb2>
  407114:	20fc      	movs	r0, #252	; 0xfc
  407116:	247e      	movs	r4, #126	; 0x7e
  407118:	e789      	b.n	40702e <_free_r+0xb2>
  40711a:	bf00      	nop
  40711c:	20000488 	.word	0x20000488
  407120:	20000490 	.word	0x20000490
  407124:	20000890 	.word	0x20000890
  407128:	20004ed8 	.word	0x20004ed8

0040712c <_fwalk_reent>:
  40712c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  407130:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
  407134:	d01f      	beq.n	407176 <_fwalk_reent+0x4a>
  407136:	4688      	mov	r8, r1
  407138:	4606      	mov	r6, r0
  40713a:	f04f 0900 	mov.w	r9, #0
  40713e:	687d      	ldr	r5, [r7, #4]
  407140:	68bc      	ldr	r4, [r7, #8]
  407142:	3d01      	subs	r5, #1
  407144:	d411      	bmi.n	40716a <_fwalk_reent+0x3e>
  407146:	89a3      	ldrh	r3, [r4, #12]
  407148:	2b01      	cmp	r3, #1
  40714a:	f105 35ff 	add.w	r5, r5, #4294967295
  40714e:	d908      	bls.n	407162 <_fwalk_reent+0x36>
  407150:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
  407154:	3301      	adds	r3, #1
  407156:	4621      	mov	r1, r4
  407158:	4630      	mov	r0, r6
  40715a:	d002      	beq.n	407162 <_fwalk_reent+0x36>
  40715c:	47c0      	blx	r8
  40715e:	ea49 0900 	orr.w	r9, r9, r0
  407162:	1c6b      	adds	r3, r5, #1
  407164:	f104 0468 	add.w	r4, r4, #104	; 0x68
  407168:	d1ed      	bne.n	407146 <_fwalk_reent+0x1a>
  40716a:	683f      	ldr	r7, [r7, #0]
  40716c:	2f00      	cmp	r7, #0
  40716e:	d1e6      	bne.n	40713e <_fwalk_reent+0x12>
  407170:	4648      	mov	r0, r9
  407172:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  407176:	46b9      	mov	r9, r7
  407178:	4648      	mov	r0, r9
  40717a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40717e:	bf00      	nop

00407180 <_localeconv_r>:
  407180:	4800      	ldr	r0, [pc, #0]	; (407184 <_localeconv_r+0x4>)
  407182:	4770      	bx	lr
  407184:	20000450 	.word	0x20000450

00407188 <malloc>:
  407188:	4b02      	ldr	r3, [pc, #8]	; (407194 <malloc+0xc>)
  40718a:	4601      	mov	r1, r0
  40718c:	6818      	ldr	r0, [r3, #0]
  40718e:	f000 b803 	b.w	407198 <_malloc_r>
  407192:	bf00      	nop
  407194:	20000448 	.word	0x20000448

00407198 <_malloc_r>:
  407198:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40719c:	f101 050b 	add.w	r5, r1, #11
  4071a0:	2d16      	cmp	r5, #22
  4071a2:	b083      	sub	sp, #12
  4071a4:	4606      	mov	r6, r0
  4071a6:	d927      	bls.n	4071f8 <_malloc_r+0x60>
  4071a8:	f035 0507 	bics.w	r5, r5, #7
  4071ac:	f100 80b6 	bmi.w	40731c <_malloc_r+0x184>
  4071b0:	42a9      	cmp	r1, r5
  4071b2:	f200 80b3 	bhi.w	40731c <_malloc_r+0x184>
  4071b6:	f000 fb2f 	bl	407818 <__malloc_lock>
  4071ba:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
  4071be:	d222      	bcs.n	407206 <_malloc_r+0x6e>
  4071c0:	4fc2      	ldr	r7, [pc, #776]	; (4074cc <_malloc_r+0x334>)
  4071c2:	08e8      	lsrs	r0, r5, #3
  4071c4:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
  4071c8:	68dc      	ldr	r4, [r3, #12]
  4071ca:	429c      	cmp	r4, r3
  4071cc:	f000 81c8 	beq.w	407560 <_malloc_r+0x3c8>
  4071d0:	6863      	ldr	r3, [r4, #4]
  4071d2:	68e1      	ldr	r1, [r4, #12]
  4071d4:	68a5      	ldr	r5, [r4, #8]
  4071d6:	f023 0303 	bic.w	r3, r3, #3
  4071da:	4423      	add	r3, r4
  4071dc:	4630      	mov	r0, r6
  4071de:	685a      	ldr	r2, [r3, #4]
  4071e0:	60e9      	str	r1, [r5, #12]
  4071e2:	f042 0201 	orr.w	r2, r2, #1
  4071e6:	608d      	str	r5, [r1, #8]
  4071e8:	605a      	str	r2, [r3, #4]
  4071ea:	f000 fb17 	bl	40781c <__malloc_unlock>
  4071ee:	3408      	adds	r4, #8
  4071f0:	4620      	mov	r0, r4
  4071f2:	b003      	add	sp, #12
  4071f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4071f8:	2910      	cmp	r1, #16
  4071fa:	f200 808f 	bhi.w	40731c <_malloc_r+0x184>
  4071fe:	f000 fb0b 	bl	407818 <__malloc_lock>
  407202:	2510      	movs	r5, #16
  407204:	e7dc      	b.n	4071c0 <_malloc_r+0x28>
  407206:	0a68      	lsrs	r0, r5, #9
  407208:	f000 808f 	beq.w	40732a <_malloc_r+0x192>
  40720c:	2804      	cmp	r0, #4
  40720e:	f200 8154 	bhi.w	4074ba <_malloc_r+0x322>
  407212:	09a8      	lsrs	r0, r5, #6
  407214:	3038      	adds	r0, #56	; 0x38
  407216:	0041      	lsls	r1, r0, #1
  407218:	4fac      	ldr	r7, [pc, #688]	; (4074cc <_malloc_r+0x334>)
  40721a:	eb07 0181 	add.w	r1, r7, r1, lsl #2
  40721e:	68cc      	ldr	r4, [r1, #12]
  407220:	42a1      	cmp	r1, r4
  407222:	d106      	bne.n	407232 <_malloc_r+0x9a>
  407224:	e00c      	b.n	407240 <_malloc_r+0xa8>
  407226:	2a00      	cmp	r2, #0
  407228:	f280 8082 	bge.w	407330 <_malloc_r+0x198>
  40722c:	68e4      	ldr	r4, [r4, #12]
  40722e:	42a1      	cmp	r1, r4
  407230:	d006      	beq.n	407240 <_malloc_r+0xa8>
  407232:	6863      	ldr	r3, [r4, #4]
  407234:	f023 0303 	bic.w	r3, r3, #3
  407238:	1b5a      	subs	r2, r3, r5
  40723a:	2a0f      	cmp	r2, #15
  40723c:	ddf3      	ble.n	407226 <_malloc_r+0x8e>
  40723e:	3801      	subs	r0, #1
  407240:	3001      	adds	r0, #1
  407242:	49a2      	ldr	r1, [pc, #648]	; (4074cc <_malloc_r+0x334>)
  407244:	693c      	ldr	r4, [r7, #16]
  407246:	f101 0e08 	add.w	lr, r1, #8
  40724a:	4574      	cmp	r4, lr
  40724c:	f000 817d 	beq.w	40754a <_malloc_r+0x3b2>
  407250:	6863      	ldr	r3, [r4, #4]
  407252:	f023 0303 	bic.w	r3, r3, #3
  407256:	1b5a      	subs	r2, r3, r5
  407258:	2a0f      	cmp	r2, #15
  40725a:	f300 8163 	bgt.w	407524 <_malloc_r+0x38c>
  40725e:	2a00      	cmp	r2, #0
  407260:	f8c1 e014 	str.w	lr, [r1, #20]
  407264:	f8c1 e010 	str.w	lr, [r1, #16]
  407268:	da73      	bge.n	407352 <_malloc_r+0x1ba>
  40726a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40726e:	f080 8139 	bcs.w	4074e4 <_malloc_r+0x34c>
  407272:	08db      	lsrs	r3, r3, #3
  407274:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
  407278:	ea4f 0ca3 	mov.w	ip, r3, asr #2
  40727c:	684a      	ldr	r2, [r1, #4]
  40727e:	f8d8 9008 	ldr.w	r9, [r8, #8]
  407282:	f8c4 9008 	str.w	r9, [r4, #8]
  407286:	2301      	movs	r3, #1
  407288:	fa03 f30c 	lsl.w	r3, r3, ip
  40728c:	4313      	orrs	r3, r2
  40728e:	f8c4 800c 	str.w	r8, [r4, #12]
  407292:	604b      	str	r3, [r1, #4]
  407294:	f8c8 4008 	str.w	r4, [r8, #8]
  407298:	f8c9 400c 	str.w	r4, [r9, #12]
  40729c:	1082      	asrs	r2, r0, #2
  40729e:	2401      	movs	r4, #1
  4072a0:	4094      	lsls	r4, r2
  4072a2:	429c      	cmp	r4, r3
  4072a4:	d862      	bhi.n	40736c <_malloc_r+0x1d4>
  4072a6:	4223      	tst	r3, r4
  4072a8:	d106      	bne.n	4072b8 <_malloc_r+0x120>
  4072aa:	f020 0003 	bic.w	r0, r0, #3
  4072ae:	0064      	lsls	r4, r4, #1
  4072b0:	4223      	tst	r3, r4
  4072b2:	f100 0004 	add.w	r0, r0, #4
  4072b6:	d0fa      	beq.n	4072ae <_malloc_r+0x116>
  4072b8:	eb07 08c0 	add.w	r8, r7, r0, lsl #3
  4072bc:	46c4      	mov	ip, r8
  4072be:	4681      	mov	r9, r0
  4072c0:	f8dc 300c 	ldr.w	r3, [ip, #12]
  4072c4:	459c      	cmp	ip, r3
  4072c6:	d107      	bne.n	4072d8 <_malloc_r+0x140>
  4072c8:	e141      	b.n	40754e <_malloc_r+0x3b6>
  4072ca:	2900      	cmp	r1, #0
  4072cc:	f280 8151 	bge.w	407572 <_malloc_r+0x3da>
  4072d0:	68db      	ldr	r3, [r3, #12]
  4072d2:	459c      	cmp	ip, r3
  4072d4:	f000 813b 	beq.w	40754e <_malloc_r+0x3b6>
  4072d8:	685a      	ldr	r2, [r3, #4]
  4072da:	f022 0203 	bic.w	r2, r2, #3
  4072de:	1b51      	subs	r1, r2, r5
  4072e0:	290f      	cmp	r1, #15
  4072e2:	ddf2      	ble.n	4072ca <_malloc_r+0x132>
  4072e4:	461c      	mov	r4, r3
  4072e6:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  4072ea:	f854 8f08 	ldr.w	r8, [r4, #8]!
  4072ee:	195a      	adds	r2, r3, r5
  4072f0:	f045 0901 	orr.w	r9, r5, #1
  4072f4:	f041 0501 	orr.w	r5, r1, #1
  4072f8:	f8c3 9004 	str.w	r9, [r3, #4]
  4072fc:	4630      	mov	r0, r6
  4072fe:	f8c8 c00c 	str.w	ip, [r8, #12]
  407302:	f8cc 8008 	str.w	r8, [ip, #8]
  407306:	617a      	str	r2, [r7, #20]
  407308:	613a      	str	r2, [r7, #16]
  40730a:	f8c2 e00c 	str.w	lr, [r2, #12]
  40730e:	f8c2 e008 	str.w	lr, [r2, #8]
  407312:	6055      	str	r5, [r2, #4]
  407314:	5051      	str	r1, [r2, r1]
  407316:	f000 fa81 	bl	40781c <__malloc_unlock>
  40731a:	e769      	b.n	4071f0 <_malloc_r+0x58>
  40731c:	2400      	movs	r4, #0
  40731e:	230c      	movs	r3, #12
  407320:	4620      	mov	r0, r4
  407322:	6033      	str	r3, [r6, #0]
  407324:	b003      	add	sp, #12
  407326:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40732a:	217e      	movs	r1, #126	; 0x7e
  40732c:	203f      	movs	r0, #63	; 0x3f
  40732e:	e773      	b.n	407218 <_malloc_r+0x80>
  407330:	4423      	add	r3, r4
  407332:	68e1      	ldr	r1, [r4, #12]
  407334:	685a      	ldr	r2, [r3, #4]
  407336:	68a5      	ldr	r5, [r4, #8]
  407338:	f042 0201 	orr.w	r2, r2, #1
  40733c:	60e9      	str	r1, [r5, #12]
  40733e:	4630      	mov	r0, r6
  407340:	608d      	str	r5, [r1, #8]
  407342:	605a      	str	r2, [r3, #4]
  407344:	f000 fa6a 	bl	40781c <__malloc_unlock>
  407348:	3408      	adds	r4, #8
  40734a:	4620      	mov	r0, r4
  40734c:	b003      	add	sp, #12
  40734e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407352:	4423      	add	r3, r4
  407354:	4630      	mov	r0, r6
  407356:	685a      	ldr	r2, [r3, #4]
  407358:	f042 0201 	orr.w	r2, r2, #1
  40735c:	605a      	str	r2, [r3, #4]
  40735e:	f000 fa5d 	bl	40781c <__malloc_unlock>
  407362:	3408      	adds	r4, #8
  407364:	4620      	mov	r0, r4
  407366:	b003      	add	sp, #12
  407368:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40736c:	68bc      	ldr	r4, [r7, #8]
  40736e:	6863      	ldr	r3, [r4, #4]
  407370:	f023 0803 	bic.w	r8, r3, #3
  407374:	4545      	cmp	r5, r8
  407376:	d804      	bhi.n	407382 <_malloc_r+0x1ea>
  407378:	ebc5 0308 	rsb	r3, r5, r8
  40737c:	2b0f      	cmp	r3, #15
  40737e:	f300 808c 	bgt.w	40749a <_malloc_r+0x302>
  407382:	4b53      	ldr	r3, [pc, #332]	; (4074d0 <_malloc_r+0x338>)
  407384:	f8df a158 	ldr.w	sl, [pc, #344]	; 4074e0 <_malloc_r+0x348>
  407388:	681a      	ldr	r2, [r3, #0]
  40738a:	f8da 3000 	ldr.w	r3, [sl]
  40738e:	3301      	adds	r3, #1
  407390:	442a      	add	r2, r5
  407392:	eb04 0b08 	add.w	fp, r4, r8
  407396:	f000 8150 	beq.w	40763a <_malloc_r+0x4a2>
  40739a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  40739e:	320f      	adds	r2, #15
  4073a0:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
  4073a4:	f022 020f 	bic.w	r2, r2, #15
  4073a8:	4611      	mov	r1, r2
  4073aa:	4630      	mov	r0, r6
  4073ac:	9201      	str	r2, [sp, #4]
  4073ae:	f000 ff4d 	bl	40824c <_sbrk_r>
  4073b2:	f1b0 3fff 	cmp.w	r0, #4294967295
  4073b6:	4681      	mov	r9, r0
  4073b8:	9a01      	ldr	r2, [sp, #4]
  4073ba:	f000 8147 	beq.w	40764c <_malloc_r+0x4b4>
  4073be:	4583      	cmp	fp, r0
  4073c0:	f200 80ee 	bhi.w	4075a0 <_malloc_r+0x408>
  4073c4:	4b43      	ldr	r3, [pc, #268]	; (4074d4 <_malloc_r+0x33c>)
  4073c6:	6819      	ldr	r1, [r3, #0]
  4073c8:	45cb      	cmp	fp, r9
  4073ca:	4411      	add	r1, r2
  4073cc:	6019      	str	r1, [r3, #0]
  4073ce:	f000 8142 	beq.w	407656 <_malloc_r+0x4be>
  4073d2:	f8da 0000 	ldr.w	r0, [sl]
  4073d6:	f8df e108 	ldr.w	lr, [pc, #264]	; 4074e0 <_malloc_r+0x348>
  4073da:	3001      	adds	r0, #1
  4073dc:	bf1b      	ittet	ne
  4073de:	ebcb 0b09 	rsbne	fp, fp, r9
  4073e2:	4459      	addne	r1, fp
  4073e4:	f8ce 9000 	streq.w	r9, [lr]
  4073e8:	6019      	strne	r1, [r3, #0]
  4073ea:	f019 0107 	ands.w	r1, r9, #7
  4073ee:	f000 8107 	beq.w	407600 <_malloc_r+0x468>
  4073f2:	f1c1 0008 	rsb	r0, r1, #8
  4073f6:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
  4073fa:	4481      	add	r9, r0
  4073fc:	3108      	adds	r1, #8
  4073fe:	444a      	add	r2, r9
  407400:	f3c2 020b 	ubfx	r2, r2, #0, #12
  407404:	ebc2 0a01 	rsb	sl, r2, r1
  407408:	4651      	mov	r1, sl
  40740a:	4630      	mov	r0, r6
  40740c:	9301      	str	r3, [sp, #4]
  40740e:	f000 ff1d 	bl	40824c <_sbrk_r>
  407412:	1c43      	adds	r3, r0, #1
  407414:	9b01      	ldr	r3, [sp, #4]
  407416:	f000 812c 	beq.w	407672 <_malloc_r+0x4da>
  40741a:	ebc9 0200 	rsb	r2, r9, r0
  40741e:	4452      	add	r2, sl
  407420:	f042 0201 	orr.w	r2, r2, #1
  407424:	6819      	ldr	r1, [r3, #0]
  407426:	f8c7 9008 	str.w	r9, [r7, #8]
  40742a:	4451      	add	r1, sl
  40742c:	42bc      	cmp	r4, r7
  40742e:	f8c9 2004 	str.w	r2, [r9, #4]
  407432:	6019      	str	r1, [r3, #0]
  407434:	f8df a09c 	ldr.w	sl, [pc, #156]	; 4074d4 <_malloc_r+0x33c>
  407438:	d016      	beq.n	407468 <_malloc_r+0x2d0>
  40743a:	f1b8 0f0f 	cmp.w	r8, #15
  40743e:	f240 80ee 	bls.w	40761e <_malloc_r+0x486>
  407442:	6862      	ldr	r2, [r4, #4]
  407444:	f1a8 030c 	sub.w	r3, r8, #12
  407448:	f023 0307 	bic.w	r3, r3, #7
  40744c:	18e0      	adds	r0, r4, r3
  40744e:	f002 0201 	and.w	r2, r2, #1
  407452:	f04f 0e05 	mov.w	lr, #5
  407456:	431a      	orrs	r2, r3
  407458:	2b0f      	cmp	r3, #15
  40745a:	6062      	str	r2, [r4, #4]
  40745c:	f8c0 e004 	str.w	lr, [r0, #4]
  407460:	f8c0 e008 	str.w	lr, [r0, #8]
  407464:	f200 8109 	bhi.w	40767a <_malloc_r+0x4e2>
  407468:	4b1b      	ldr	r3, [pc, #108]	; (4074d8 <_malloc_r+0x340>)
  40746a:	68bc      	ldr	r4, [r7, #8]
  40746c:	681a      	ldr	r2, [r3, #0]
  40746e:	4291      	cmp	r1, r2
  407470:	bf88      	it	hi
  407472:	6019      	strhi	r1, [r3, #0]
  407474:	4b19      	ldr	r3, [pc, #100]	; (4074dc <_malloc_r+0x344>)
  407476:	681a      	ldr	r2, [r3, #0]
  407478:	4291      	cmp	r1, r2
  40747a:	6862      	ldr	r2, [r4, #4]
  40747c:	bf88      	it	hi
  40747e:	6019      	strhi	r1, [r3, #0]
  407480:	f022 0203 	bic.w	r2, r2, #3
  407484:	4295      	cmp	r5, r2
  407486:	eba2 0305 	sub.w	r3, r2, r5
  40748a:	d801      	bhi.n	407490 <_malloc_r+0x2f8>
  40748c:	2b0f      	cmp	r3, #15
  40748e:	dc04      	bgt.n	40749a <_malloc_r+0x302>
  407490:	4630      	mov	r0, r6
  407492:	f000 f9c3 	bl	40781c <__malloc_unlock>
  407496:	2400      	movs	r4, #0
  407498:	e6aa      	b.n	4071f0 <_malloc_r+0x58>
  40749a:	1962      	adds	r2, r4, r5
  40749c:	f043 0301 	orr.w	r3, r3, #1
  4074a0:	f045 0501 	orr.w	r5, r5, #1
  4074a4:	6065      	str	r5, [r4, #4]
  4074a6:	4630      	mov	r0, r6
  4074a8:	60ba      	str	r2, [r7, #8]
  4074aa:	6053      	str	r3, [r2, #4]
  4074ac:	f000 f9b6 	bl	40781c <__malloc_unlock>
  4074b0:	3408      	adds	r4, #8
  4074b2:	4620      	mov	r0, r4
  4074b4:	b003      	add	sp, #12
  4074b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4074ba:	2814      	cmp	r0, #20
  4074bc:	d968      	bls.n	407590 <_malloc_r+0x3f8>
  4074be:	2854      	cmp	r0, #84	; 0x54
  4074c0:	f200 8097 	bhi.w	4075f2 <_malloc_r+0x45a>
  4074c4:	0b28      	lsrs	r0, r5, #12
  4074c6:	306e      	adds	r0, #110	; 0x6e
  4074c8:	0041      	lsls	r1, r0, #1
  4074ca:	e6a5      	b.n	407218 <_malloc_r+0x80>
  4074cc:	20000488 	.word	0x20000488
  4074d0:	20004ed8 	.word	0x20004ed8
  4074d4:	20004edc 	.word	0x20004edc
  4074d8:	20004ed4 	.word	0x20004ed4
  4074dc:	20004ed0 	.word	0x20004ed0
  4074e0:	20000894 	.word	0x20000894
  4074e4:	0a5a      	lsrs	r2, r3, #9
  4074e6:	2a04      	cmp	r2, #4
  4074e8:	d955      	bls.n	407596 <_malloc_r+0x3fe>
  4074ea:	2a14      	cmp	r2, #20
  4074ec:	f200 80a7 	bhi.w	40763e <_malloc_r+0x4a6>
  4074f0:	325b      	adds	r2, #91	; 0x5b
  4074f2:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  4074f6:	eb07 0c8c 	add.w	ip, r7, ip, lsl #2
  4074fa:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 4076b8 <_malloc_r+0x520>
  4074fe:	f8dc 1008 	ldr.w	r1, [ip, #8]
  407502:	4561      	cmp	r1, ip
  407504:	d07f      	beq.n	407606 <_malloc_r+0x46e>
  407506:	684a      	ldr	r2, [r1, #4]
  407508:	f022 0203 	bic.w	r2, r2, #3
  40750c:	4293      	cmp	r3, r2
  40750e:	d202      	bcs.n	407516 <_malloc_r+0x37e>
  407510:	6889      	ldr	r1, [r1, #8]
  407512:	458c      	cmp	ip, r1
  407514:	d1f7      	bne.n	407506 <_malloc_r+0x36e>
  407516:	68ca      	ldr	r2, [r1, #12]
  407518:	687b      	ldr	r3, [r7, #4]
  40751a:	60e2      	str	r2, [r4, #12]
  40751c:	60a1      	str	r1, [r4, #8]
  40751e:	6094      	str	r4, [r2, #8]
  407520:	60cc      	str	r4, [r1, #12]
  407522:	e6bb      	b.n	40729c <_malloc_r+0x104>
  407524:	1963      	adds	r3, r4, r5
  407526:	f042 0701 	orr.w	r7, r2, #1
  40752a:	f045 0501 	orr.w	r5, r5, #1
  40752e:	6065      	str	r5, [r4, #4]
  407530:	4630      	mov	r0, r6
  407532:	614b      	str	r3, [r1, #20]
  407534:	610b      	str	r3, [r1, #16]
  407536:	f8c3 e00c 	str.w	lr, [r3, #12]
  40753a:	f8c3 e008 	str.w	lr, [r3, #8]
  40753e:	605f      	str	r7, [r3, #4]
  407540:	509a      	str	r2, [r3, r2]
  407542:	3408      	adds	r4, #8
  407544:	f000 f96a 	bl	40781c <__malloc_unlock>
  407548:	e652      	b.n	4071f0 <_malloc_r+0x58>
  40754a:	684b      	ldr	r3, [r1, #4]
  40754c:	e6a6      	b.n	40729c <_malloc_r+0x104>
  40754e:	f109 0901 	add.w	r9, r9, #1
  407552:	f019 0f03 	tst.w	r9, #3
  407556:	f10c 0c08 	add.w	ip, ip, #8
  40755a:	f47f aeb1 	bne.w	4072c0 <_malloc_r+0x128>
  40755e:	e02c      	b.n	4075ba <_malloc_r+0x422>
  407560:	f104 0308 	add.w	r3, r4, #8
  407564:	6964      	ldr	r4, [r4, #20]
  407566:	42a3      	cmp	r3, r4
  407568:	bf08      	it	eq
  40756a:	3002      	addeq	r0, #2
  40756c:	f43f ae69 	beq.w	407242 <_malloc_r+0xaa>
  407570:	e62e      	b.n	4071d0 <_malloc_r+0x38>
  407572:	441a      	add	r2, r3
  407574:	461c      	mov	r4, r3
  407576:	6851      	ldr	r1, [r2, #4]
  407578:	68db      	ldr	r3, [r3, #12]
  40757a:	f854 5f08 	ldr.w	r5, [r4, #8]!
  40757e:	f041 0101 	orr.w	r1, r1, #1
  407582:	6051      	str	r1, [r2, #4]
  407584:	4630      	mov	r0, r6
  407586:	60eb      	str	r3, [r5, #12]
  407588:	609d      	str	r5, [r3, #8]
  40758a:	f000 f947 	bl	40781c <__malloc_unlock>
  40758e:	e62f      	b.n	4071f0 <_malloc_r+0x58>
  407590:	305b      	adds	r0, #91	; 0x5b
  407592:	0041      	lsls	r1, r0, #1
  407594:	e640      	b.n	407218 <_malloc_r+0x80>
  407596:	099a      	lsrs	r2, r3, #6
  407598:	3238      	adds	r2, #56	; 0x38
  40759a:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  40759e:	e7aa      	b.n	4074f6 <_malloc_r+0x35e>
  4075a0:	42bc      	cmp	r4, r7
  4075a2:	4b45      	ldr	r3, [pc, #276]	; (4076b8 <_malloc_r+0x520>)
  4075a4:	f43f af0e 	beq.w	4073c4 <_malloc_r+0x22c>
  4075a8:	689c      	ldr	r4, [r3, #8]
  4075aa:	6862      	ldr	r2, [r4, #4]
  4075ac:	f022 0203 	bic.w	r2, r2, #3
  4075b0:	e768      	b.n	407484 <_malloc_r+0x2ec>
  4075b2:	f8d8 8000 	ldr.w	r8, [r8]
  4075b6:	4598      	cmp	r8, r3
  4075b8:	d17c      	bne.n	4076b4 <_malloc_r+0x51c>
  4075ba:	f010 0f03 	tst.w	r0, #3
  4075be:	f1a8 0308 	sub.w	r3, r8, #8
  4075c2:	f100 30ff 	add.w	r0, r0, #4294967295
  4075c6:	d1f4      	bne.n	4075b2 <_malloc_r+0x41a>
  4075c8:	687b      	ldr	r3, [r7, #4]
  4075ca:	ea23 0304 	bic.w	r3, r3, r4
  4075ce:	607b      	str	r3, [r7, #4]
  4075d0:	0064      	lsls	r4, r4, #1
  4075d2:	429c      	cmp	r4, r3
  4075d4:	f63f aeca 	bhi.w	40736c <_malloc_r+0x1d4>
  4075d8:	2c00      	cmp	r4, #0
  4075da:	f43f aec7 	beq.w	40736c <_malloc_r+0x1d4>
  4075de:	4223      	tst	r3, r4
  4075e0:	4648      	mov	r0, r9
  4075e2:	f47f ae69 	bne.w	4072b8 <_malloc_r+0x120>
  4075e6:	0064      	lsls	r4, r4, #1
  4075e8:	4223      	tst	r3, r4
  4075ea:	f100 0004 	add.w	r0, r0, #4
  4075ee:	d0fa      	beq.n	4075e6 <_malloc_r+0x44e>
  4075f0:	e662      	b.n	4072b8 <_malloc_r+0x120>
  4075f2:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
  4075f6:	d818      	bhi.n	40762a <_malloc_r+0x492>
  4075f8:	0be8      	lsrs	r0, r5, #15
  4075fa:	3077      	adds	r0, #119	; 0x77
  4075fc:	0041      	lsls	r1, r0, #1
  4075fe:	e60b      	b.n	407218 <_malloc_r+0x80>
  407600:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  407604:	e6fb      	b.n	4073fe <_malloc_r+0x266>
  407606:	f8d8 3004 	ldr.w	r3, [r8, #4]
  40760a:	1092      	asrs	r2, r2, #2
  40760c:	f04f 0c01 	mov.w	ip, #1
  407610:	fa0c f202 	lsl.w	r2, ip, r2
  407614:	4313      	orrs	r3, r2
  407616:	f8c8 3004 	str.w	r3, [r8, #4]
  40761a:	460a      	mov	r2, r1
  40761c:	e77d      	b.n	40751a <_malloc_r+0x382>
  40761e:	2301      	movs	r3, #1
  407620:	f8c9 3004 	str.w	r3, [r9, #4]
  407624:	464c      	mov	r4, r9
  407626:	2200      	movs	r2, #0
  407628:	e72c      	b.n	407484 <_malloc_r+0x2ec>
  40762a:	f240 5354 	movw	r3, #1364	; 0x554
  40762e:	4298      	cmp	r0, r3
  407630:	d81c      	bhi.n	40766c <_malloc_r+0x4d4>
  407632:	0ca8      	lsrs	r0, r5, #18
  407634:	307c      	adds	r0, #124	; 0x7c
  407636:	0041      	lsls	r1, r0, #1
  407638:	e5ee      	b.n	407218 <_malloc_r+0x80>
  40763a:	3210      	adds	r2, #16
  40763c:	e6b4      	b.n	4073a8 <_malloc_r+0x210>
  40763e:	2a54      	cmp	r2, #84	; 0x54
  407640:	d823      	bhi.n	40768a <_malloc_r+0x4f2>
  407642:	0b1a      	lsrs	r2, r3, #12
  407644:	326e      	adds	r2, #110	; 0x6e
  407646:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  40764a:	e754      	b.n	4074f6 <_malloc_r+0x35e>
  40764c:	68bc      	ldr	r4, [r7, #8]
  40764e:	6862      	ldr	r2, [r4, #4]
  407650:	f022 0203 	bic.w	r2, r2, #3
  407654:	e716      	b.n	407484 <_malloc_r+0x2ec>
  407656:	f3cb 000b 	ubfx	r0, fp, #0, #12
  40765a:	2800      	cmp	r0, #0
  40765c:	f47f aeb9 	bne.w	4073d2 <_malloc_r+0x23a>
  407660:	4442      	add	r2, r8
  407662:	68bb      	ldr	r3, [r7, #8]
  407664:	f042 0201 	orr.w	r2, r2, #1
  407668:	605a      	str	r2, [r3, #4]
  40766a:	e6fd      	b.n	407468 <_malloc_r+0x2d0>
  40766c:	21fc      	movs	r1, #252	; 0xfc
  40766e:	207e      	movs	r0, #126	; 0x7e
  407670:	e5d2      	b.n	407218 <_malloc_r+0x80>
  407672:	2201      	movs	r2, #1
  407674:	f04f 0a00 	mov.w	sl, #0
  407678:	e6d4      	b.n	407424 <_malloc_r+0x28c>
  40767a:	f104 0108 	add.w	r1, r4, #8
  40767e:	4630      	mov	r0, r6
  407680:	f7ff fc7c 	bl	406f7c <_free_r>
  407684:	f8da 1000 	ldr.w	r1, [sl]
  407688:	e6ee      	b.n	407468 <_malloc_r+0x2d0>
  40768a:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  40768e:	d804      	bhi.n	40769a <_malloc_r+0x502>
  407690:	0bda      	lsrs	r2, r3, #15
  407692:	3277      	adds	r2, #119	; 0x77
  407694:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  407698:	e72d      	b.n	4074f6 <_malloc_r+0x35e>
  40769a:	f240 5154 	movw	r1, #1364	; 0x554
  40769e:	428a      	cmp	r2, r1
  4076a0:	d804      	bhi.n	4076ac <_malloc_r+0x514>
  4076a2:	0c9a      	lsrs	r2, r3, #18
  4076a4:	327c      	adds	r2, #124	; 0x7c
  4076a6:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  4076aa:	e724      	b.n	4074f6 <_malloc_r+0x35e>
  4076ac:	f04f 0cfc 	mov.w	ip, #252	; 0xfc
  4076b0:	227e      	movs	r2, #126	; 0x7e
  4076b2:	e720      	b.n	4074f6 <_malloc_r+0x35e>
  4076b4:	687b      	ldr	r3, [r7, #4]
  4076b6:	e78b      	b.n	4075d0 <_malloc_r+0x438>
  4076b8:	20000488 	.word	0x20000488

004076bc <memchr>:
  4076bc:	0783      	lsls	r3, r0, #30
  4076be:	b470      	push	{r4, r5, r6}
  4076c0:	b2c9      	uxtb	r1, r1
  4076c2:	d040      	beq.n	407746 <memchr+0x8a>
  4076c4:	1e54      	subs	r4, r2, #1
  4076c6:	2a00      	cmp	r2, #0
  4076c8:	d03f      	beq.n	40774a <memchr+0x8e>
  4076ca:	7803      	ldrb	r3, [r0, #0]
  4076cc:	428b      	cmp	r3, r1
  4076ce:	bf18      	it	ne
  4076d0:	1c43      	addne	r3, r0, #1
  4076d2:	d106      	bne.n	4076e2 <memchr+0x26>
  4076d4:	e01d      	b.n	407712 <memchr+0x56>
  4076d6:	b1f4      	cbz	r4, 407716 <memchr+0x5a>
  4076d8:	7802      	ldrb	r2, [r0, #0]
  4076da:	428a      	cmp	r2, r1
  4076dc:	f104 34ff 	add.w	r4, r4, #4294967295
  4076e0:	d017      	beq.n	407712 <memchr+0x56>
  4076e2:	f013 0f03 	tst.w	r3, #3
  4076e6:	4618      	mov	r0, r3
  4076e8:	f103 0301 	add.w	r3, r3, #1
  4076ec:	d1f3      	bne.n	4076d6 <memchr+0x1a>
  4076ee:	2c03      	cmp	r4, #3
  4076f0:	d814      	bhi.n	40771c <memchr+0x60>
  4076f2:	b184      	cbz	r4, 407716 <memchr+0x5a>
  4076f4:	7803      	ldrb	r3, [r0, #0]
  4076f6:	428b      	cmp	r3, r1
  4076f8:	d00b      	beq.n	407712 <memchr+0x56>
  4076fa:	1905      	adds	r5, r0, r4
  4076fc:	1c43      	adds	r3, r0, #1
  4076fe:	e002      	b.n	407706 <memchr+0x4a>
  407700:	7802      	ldrb	r2, [r0, #0]
  407702:	428a      	cmp	r2, r1
  407704:	d005      	beq.n	407712 <memchr+0x56>
  407706:	42ab      	cmp	r3, r5
  407708:	4618      	mov	r0, r3
  40770a:	f103 0301 	add.w	r3, r3, #1
  40770e:	d1f7      	bne.n	407700 <memchr+0x44>
  407710:	2000      	movs	r0, #0
  407712:	bc70      	pop	{r4, r5, r6}
  407714:	4770      	bx	lr
  407716:	4620      	mov	r0, r4
  407718:	bc70      	pop	{r4, r5, r6}
  40771a:	4770      	bx	lr
  40771c:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
  407720:	4602      	mov	r2, r0
  407722:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
  407726:	4610      	mov	r0, r2
  407728:	3204      	adds	r2, #4
  40772a:	6803      	ldr	r3, [r0, #0]
  40772c:	4073      	eors	r3, r6
  40772e:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
  407732:	ea25 0303 	bic.w	r3, r5, r3
  407736:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  40773a:	d1da      	bne.n	4076f2 <memchr+0x36>
  40773c:	3c04      	subs	r4, #4
  40773e:	2c03      	cmp	r4, #3
  407740:	4610      	mov	r0, r2
  407742:	d8f0      	bhi.n	407726 <memchr+0x6a>
  407744:	e7d5      	b.n	4076f2 <memchr+0x36>
  407746:	4614      	mov	r4, r2
  407748:	e7d1      	b.n	4076ee <memchr+0x32>
  40774a:	4610      	mov	r0, r2
  40774c:	e7e1      	b.n	407712 <memchr+0x56>
  40774e:	bf00      	nop

00407750 <memmove>:
  407750:	4288      	cmp	r0, r1
  407752:	b5f0      	push	{r4, r5, r6, r7, lr}
  407754:	d90d      	bls.n	407772 <memmove+0x22>
  407756:	188b      	adds	r3, r1, r2
  407758:	4298      	cmp	r0, r3
  40775a:	d20a      	bcs.n	407772 <memmove+0x22>
  40775c:	1881      	adds	r1, r0, r2
  40775e:	2a00      	cmp	r2, #0
  407760:	d054      	beq.n	40780c <memmove+0xbc>
  407762:	1a9a      	subs	r2, r3, r2
  407764:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  407768:	f801 4d01 	strb.w	r4, [r1, #-1]!
  40776c:	4293      	cmp	r3, r2
  40776e:	d1f9      	bne.n	407764 <memmove+0x14>
  407770:	bdf0      	pop	{r4, r5, r6, r7, pc}
  407772:	2a0f      	cmp	r2, #15
  407774:	d948      	bls.n	407808 <memmove+0xb8>
  407776:	ea40 0301 	orr.w	r3, r0, r1
  40777a:	079b      	lsls	r3, r3, #30
  40777c:	d147      	bne.n	40780e <memmove+0xbe>
  40777e:	f100 0410 	add.w	r4, r0, #16
  407782:	f101 0310 	add.w	r3, r1, #16
  407786:	4615      	mov	r5, r2
  407788:	f853 6c10 	ldr.w	r6, [r3, #-16]
  40778c:	f844 6c10 	str.w	r6, [r4, #-16]
  407790:	f853 6c0c 	ldr.w	r6, [r3, #-12]
  407794:	f844 6c0c 	str.w	r6, [r4, #-12]
  407798:	f853 6c08 	ldr.w	r6, [r3, #-8]
  40779c:	f844 6c08 	str.w	r6, [r4, #-8]
  4077a0:	3d10      	subs	r5, #16
  4077a2:	f853 6c04 	ldr.w	r6, [r3, #-4]
  4077a6:	f844 6c04 	str.w	r6, [r4, #-4]
  4077aa:	2d0f      	cmp	r5, #15
  4077ac:	f103 0310 	add.w	r3, r3, #16
  4077b0:	f104 0410 	add.w	r4, r4, #16
  4077b4:	d8e8      	bhi.n	407788 <memmove+0x38>
  4077b6:	f1a2 0310 	sub.w	r3, r2, #16
  4077ba:	f023 030f 	bic.w	r3, r3, #15
  4077be:	f002 0e0f 	and.w	lr, r2, #15
  4077c2:	3310      	adds	r3, #16
  4077c4:	f1be 0f03 	cmp.w	lr, #3
  4077c8:	4419      	add	r1, r3
  4077ca:	4403      	add	r3, r0
  4077cc:	d921      	bls.n	407812 <memmove+0xc2>
  4077ce:	1f1e      	subs	r6, r3, #4
  4077d0:	460d      	mov	r5, r1
  4077d2:	4674      	mov	r4, lr
  4077d4:	3c04      	subs	r4, #4
  4077d6:	f855 7b04 	ldr.w	r7, [r5], #4
  4077da:	f846 7f04 	str.w	r7, [r6, #4]!
  4077de:	2c03      	cmp	r4, #3
  4077e0:	d8f8      	bhi.n	4077d4 <memmove+0x84>
  4077e2:	f1ae 0404 	sub.w	r4, lr, #4
  4077e6:	f024 0403 	bic.w	r4, r4, #3
  4077ea:	3404      	adds	r4, #4
  4077ec:	4423      	add	r3, r4
  4077ee:	4421      	add	r1, r4
  4077f0:	f002 0203 	and.w	r2, r2, #3
  4077f4:	b152      	cbz	r2, 40780c <memmove+0xbc>
  4077f6:	3b01      	subs	r3, #1
  4077f8:	440a      	add	r2, r1
  4077fa:	f811 4b01 	ldrb.w	r4, [r1], #1
  4077fe:	f803 4f01 	strb.w	r4, [r3, #1]!
  407802:	4291      	cmp	r1, r2
  407804:	d1f9      	bne.n	4077fa <memmove+0xaa>
  407806:	bdf0      	pop	{r4, r5, r6, r7, pc}
  407808:	4603      	mov	r3, r0
  40780a:	e7f3      	b.n	4077f4 <memmove+0xa4>
  40780c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40780e:	4603      	mov	r3, r0
  407810:	e7f1      	b.n	4077f6 <memmove+0xa6>
  407812:	4672      	mov	r2, lr
  407814:	e7ee      	b.n	4077f4 <memmove+0xa4>
  407816:	bf00      	nop

00407818 <__malloc_lock>:
  407818:	4770      	bx	lr
  40781a:	bf00      	nop

0040781c <__malloc_unlock>:
  40781c:	4770      	bx	lr
  40781e:	bf00      	nop

00407820 <_Balloc>:
  407820:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  407822:	b570      	push	{r4, r5, r6, lr}
  407824:	4605      	mov	r5, r0
  407826:	460c      	mov	r4, r1
  407828:	b14b      	cbz	r3, 40783e <_Balloc+0x1e>
  40782a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  40782e:	b180      	cbz	r0, 407852 <_Balloc+0x32>
  407830:	6802      	ldr	r2, [r0, #0]
  407832:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  407836:	2300      	movs	r3, #0
  407838:	6103      	str	r3, [r0, #16]
  40783a:	60c3      	str	r3, [r0, #12]
  40783c:	bd70      	pop	{r4, r5, r6, pc}
  40783e:	2104      	movs	r1, #4
  407840:	2221      	movs	r2, #33	; 0x21
  407842:	f000 fe3f 	bl	4084c4 <_calloc_r>
  407846:	64e8      	str	r0, [r5, #76]	; 0x4c
  407848:	4603      	mov	r3, r0
  40784a:	2800      	cmp	r0, #0
  40784c:	d1ed      	bne.n	40782a <_Balloc+0xa>
  40784e:	2000      	movs	r0, #0
  407850:	bd70      	pop	{r4, r5, r6, pc}
  407852:	2101      	movs	r1, #1
  407854:	fa01 f604 	lsl.w	r6, r1, r4
  407858:	1d72      	adds	r2, r6, #5
  40785a:	4628      	mov	r0, r5
  40785c:	0092      	lsls	r2, r2, #2
  40785e:	f000 fe31 	bl	4084c4 <_calloc_r>
  407862:	2800      	cmp	r0, #0
  407864:	d0f3      	beq.n	40784e <_Balloc+0x2e>
  407866:	6044      	str	r4, [r0, #4]
  407868:	6086      	str	r6, [r0, #8]
  40786a:	e7e4      	b.n	407836 <_Balloc+0x16>

0040786c <_Bfree>:
  40786c:	b131      	cbz	r1, 40787c <_Bfree+0x10>
  40786e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  407870:	684a      	ldr	r2, [r1, #4]
  407872:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
  407876:	6008      	str	r0, [r1, #0]
  407878:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  40787c:	4770      	bx	lr
  40787e:	bf00      	nop

00407880 <__multadd>:
  407880:	b5f0      	push	{r4, r5, r6, r7, lr}
  407882:	690c      	ldr	r4, [r1, #16]
  407884:	b083      	sub	sp, #12
  407886:	460d      	mov	r5, r1
  407888:	4606      	mov	r6, r0
  40788a:	f101 0e14 	add.w	lr, r1, #20
  40788e:	2700      	movs	r7, #0
  407890:	f8de 1000 	ldr.w	r1, [lr]
  407894:	b288      	uxth	r0, r1
  407896:	0c09      	lsrs	r1, r1, #16
  407898:	fb02 3300 	mla	r3, r2, r0, r3
  40789c:	fb02 f101 	mul.w	r1, r2, r1
  4078a0:	eb01 4113 	add.w	r1, r1, r3, lsr #16
  4078a4:	3701      	adds	r7, #1
  4078a6:	b29b      	uxth	r3, r3
  4078a8:	eb03 4301 	add.w	r3, r3, r1, lsl #16
  4078ac:	42bc      	cmp	r4, r7
  4078ae:	f84e 3b04 	str.w	r3, [lr], #4
  4078b2:	ea4f 4311 	mov.w	r3, r1, lsr #16
  4078b6:	dceb      	bgt.n	407890 <__multadd+0x10>
  4078b8:	b13b      	cbz	r3, 4078ca <__multadd+0x4a>
  4078ba:	68aa      	ldr	r2, [r5, #8]
  4078bc:	4294      	cmp	r4, r2
  4078be:	da07      	bge.n	4078d0 <__multadd+0x50>
  4078c0:	eb05 0284 	add.w	r2, r5, r4, lsl #2
  4078c4:	3401      	adds	r4, #1
  4078c6:	6153      	str	r3, [r2, #20]
  4078c8:	612c      	str	r4, [r5, #16]
  4078ca:	4628      	mov	r0, r5
  4078cc:	b003      	add	sp, #12
  4078ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4078d0:	6869      	ldr	r1, [r5, #4]
  4078d2:	9301      	str	r3, [sp, #4]
  4078d4:	3101      	adds	r1, #1
  4078d6:	4630      	mov	r0, r6
  4078d8:	f7ff ffa2 	bl	407820 <_Balloc>
  4078dc:	692a      	ldr	r2, [r5, #16]
  4078de:	3202      	adds	r2, #2
  4078e0:	f105 010c 	add.w	r1, r5, #12
  4078e4:	4607      	mov	r7, r0
  4078e6:	0092      	lsls	r2, r2, #2
  4078e8:	300c      	adds	r0, #12
  4078ea:	f7fc fbd9 	bl	4040a0 <memcpy>
  4078ee:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
  4078f0:	6869      	ldr	r1, [r5, #4]
  4078f2:	9b01      	ldr	r3, [sp, #4]
  4078f4:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
  4078f8:	6028      	str	r0, [r5, #0]
  4078fa:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
  4078fe:	463d      	mov	r5, r7
  407900:	e7de      	b.n	4078c0 <__multadd+0x40>
  407902:	bf00      	nop

00407904 <__hi0bits>:
  407904:	0c03      	lsrs	r3, r0, #16
  407906:	041b      	lsls	r3, r3, #16
  407908:	b9b3      	cbnz	r3, 407938 <__hi0bits+0x34>
  40790a:	0400      	lsls	r0, r0, #16
  40790c:	2310      	movs	r3, #16
  40790e:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
  407912:	bf04      	itt	eq
  407914:	0200      	lsleq	r0, r0, #8
  407916:	3308      	addeq	r3, #8
  407918:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
  40791c:	bf04      	itt	eq
  40791e:	0100      	lsleq	r0, r0, #4
  407920:	3304      	addeq	r3, #4
  407922:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
  407926:	bf04      	itt	eq
  407928:	0080      	lsleq	r0, r0, #2
  40792a:	3302      	addeq	r3, #2
  40792c:	2800      	cmp	r0, #0
  40792e:	db07      	blt.n	407940 <__hi0bits+0x3c>
  407930:	0042      	lsls	r2, r0, #1
  407932:	d403      	bmi.n	40793c <__hi0bits+0x38>
  407934:	2020      	movs	r0, #32
  407936:	4770      	bx	lr
  407938:	2300      	movs	r3, #0
  40793a:	e7e8      	b.n	40790e <__hi0bits+0xa>
  40793c:	1c58      	adds	r0, r3, #1
  40793e:	4770      	bx	lr
  407940:	4618      	mov	r0, r3
  407942:	4770      	bx	lr

00407944 <__lo0bits>:
  407944:	6803      	ldr	r3, [r0, #0]
  407946:	f013 0207 	ands.w	r2, r3, #7
  40794a:	d007      	beq.n	40795c <__lo0bits+0x18>
  40794c:	07d9      	lsls	r1, r3, #31
  40794e:	d420      	bmi.n	407992 <__lo0bits+0x4e>
  407950:	079a      	lsls	r2, r3, #30
  407952:	d420      	bmi.n	407996 <__lo0bits+0x52>
  407954:	089b      	lsrs	r3, r3, #2
  407956:	6003      	str	r3, [r0, #0]
  407958:	2002      	movs	r0, #2
  40795a:	4770      	bx	lr
  40795c:	b299      	uxth	r1, r3
  40795e:	b909      	cbnz	r1, 407964 <__lo0bits+0x20>
  407960:	0c1b      	lsrs	r3, r3, #16
  407962:	2210      	movs	r2, #16
  407964:	f013 0fff 	tst.w	r3, #255	; 0xff
  407968:	bf04      	itt	eq
  40796a:	0a1b      	lsreq	r3, r3, #8
  40796c:	3208      	addeq	r2, #8
  40796e:	0719      	lsls	r1, r3, #28
  407970:	bf04      	itt	eq
  407972:	091b      	lsreq	r3, r3, #4
  407974:	3204      	addeq	r2, #4
  407976:	0799      	lsls	r1, r3, #30
  407978:	bf04      	itt	eq
  40797a:	089b      	lsreq	r3, r3, #2
  40797c:	3202      	addeq	r2, #2
  40797e:	07d9      	lsls	r1, r3, #31
  407980:	d404      	bmi.n	40798c <__lo0bits+0x48>
  407982:	085b      	lsrs	r3, r3, #1
  407984:	d101      	bne.n	40798a <__lo0bits+0x46>
  407986:	2020      	movs	r0, #32
  407988:	4770      	bx	lr
  40798a:	3201      	adds	r2, #1
  40798c:	6003      	str	r3, [r0, #0]
  40798e:	4610      	mov	r0, r2
  407990:	4770      	bx	lr
  407992:	2000      	movs	r0, #0
  407994:	4770      	bx	lr
  407996:	085b      	lsrs	r3, r3, #1
  407998:	6003      	str	r3, [r0, #0]
  40799a:	2001      	movs	r0, #1
  40799c:	4770      	bx	lr
  40799e:	bf00      	nop

004079a0 <__i2b>:
  4079a0:	b510      	push	{r4, lr}
  4079a2:	460c      	mov	r4, r1
  4079a4:	2101      	movs	r1, #1
  4079a6:	f7ff ff3b 	bl	407820 <_Balloc>
  4079aa:	2201      	movs	r2, #1
  4079ac:	6144      	str	r4, [r0, #20]
  4079ae:	6102      	str	r2, [r0, #16]
  4079b0:	bd10      	pop	{r4, pc}
  4079b2:	bf00      	nop

004079b4 <__multiply>:
  4079b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4079b8:	690f      	ldr	r7, [r1, #16]
  4079ba:	6916      	ldr	r6, [r2, #16]
  4079bc:	42b7      	cmp	r7, r6
  4079be:	b083      	sub	sp, #12
  4079c0:	460d      	mov	r5, r1
  4079c2:	4614      	mov	r4, r2
  4079c4:	f2c0 808d 	blt.w	407ae2 <__multiply+0x12e>
  4079c8:	4633      	mov	r3, r6
  4079ca:	463e      	mov	r6, r7
  4079cc:	461f      	mov	r7, r3
  4079ce:	68ab      	ldr	r3, [r5, #8]
  4079d0:	6869      	ldr	r1, [r5, #4]
  4079d2:	eb06 0807 	add.w	r8, r6, r7
  4079d6:	4598      	cmp	r8, r3
  4079d8:	bfc8      	it	gt
  4079da:	3101      	addgt	r1, #1
  4079dc:	f7ff ff20 	bl	407820 <_Balloc>
  4079e0:	f100 0c14 	add.w	ip, r0, #20
  4079e4:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
  4079e8:	45cc      	cmp	ip, r9
  4079ea:	9000      	str	r0, [sp, #0]
  4079ec:	d205      	bcs.n	4079fa <__multiply+0x46>
  4079ee:	4663      	mov	r3, ip
  4079f0:	2100      	movs	r1, #0
  4079f2:	f843 1b04 	str.w	r1, [r3], #4
  4079f6:	4599      	cmp	r9, r3
  4079f8:	d8fb      	bhi.n	4079f2 <__multiply+0x3e>
  4079fa:	f104 0214 	add.w	r2, r4, #20
  4079fe:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
  407a02:	f105 0314 	add.w	r3, r5, #20
  407a06:	4552      	cmp	r2, sl
  407a08:	eb03 0e86 	add.w	lr, r3, r6, lsl #2
  407a0c:	d254      	bcs.n	407ab8 <__multiply+0x104>
  407a0e:	f8cd 9004 	str.w	r9, [sp, #4]
  407a12:	4699      	mov	r9, r3
  407a14:	f852 3b04 	ldr.w	r3, [r2], #4
  407a18:	fa1f fb83 	uxth.w	fp, r3
  407a1c:	f1bb 0f00 	cmp.w	fp, #0
  407a20:	d020      	beq.n	407a64 <__multiply+0xb0>
  407a22:	2000      	movs	r0, #0
  407a24:	464f      	mov	r7, r9
  407a26:	4666      	mov	r6, ip
  407a28:	4605      	mov	r5, r0
  407a2a:	e000      	b.n	407a2e <__multiply+0x7a>
  407a2c:	461e      	mov	r6, r3
  407a2e:	f857 4b04 	ldr.w	r4, [r7], #4
  407a32:	6830      	ldr	r0, [r6, #0]
  407a34:	b2a1      	uxth	r1, r4
  407a36:	b283      	uxth	r3, r0
  407a38:	fb0b 3101 	mla	r1, fp, r1, r3
  407a3c:	0c24      	lsrs	r4, r4, #16
  407a3e:	0c00      	lsrs	r0, r0, #16
  407a40:	194b      	adds	r3, r1, r5
  407a42:	fb0b 0004 	mla	r0, fp, r4, r0
  407a46:	eb00 4013 	add.w	r0, r0, r3, lsr #16
  407a4a:	b299      	uxth	r1, r3
  407a4c:	4633      	mov	r3, r6
  407a4e:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
  407a52:	45be      	cmp	lr, r7
  407a54:	ea4f 4510 	mov.w	r5, r0, lsr #16
  407a58:	f843 1b04 	str.w	r1, [r3], #4
  407a5c:	d8e6      	bhi.n	407a2c <__multiply+0x78>
  407a5e:	6075      	str	r5, [r6, #4]
  407a60:	f852 3c04 	ldr.w	r3, [r2, #-4]
  407a64:	ea5f 4b13 	movs.w	fp, r3, lsr #16
  407a68:	d020      	beq.n	407aac <__multiply+0xf8>
  407a6a:	f8dc 3000 	ldr.w	r3, [ip]
  407a6e:	4667      	mov	r7, ip
  407a70:	4618      	mov	r0, r3
  407a72:	464d      	mov	r5, r9
  407a74:	2100      	movs	r1, #0
  407a76:	e000      	b.n	407a7a <__multiply+0xc6>
  407a78:	4637      	mov	r7, r6
  407a7a:	882c      	ldrh	r4, [r5, #0]
  407a7c:	0c00      	lsrs	r0, r0, #16
  407a7e:	fb0b 0004 	mla	r0, fp, r4, r0
  407a82:	4401      	add	r1, r0
  407a84:	b29c      	uxth	r4, r3
  407a86:	463e      	mov	r6, r7
  407a88:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
  407a8c:	f846 3b04 	str.w	r3, [r6], #4
  407a90:	6878      	ldr	r0, [r7, #4]
  407a92:	f855 4b04 	ldr.w	r4, [r5], #4
  407a96:	b283      	uxth	r3, r0
  407a98:	0c24      	lsrs	r4, r4, #16
  407a9a:	fb0b 3404 	mla	r4, fp, r4, r3
  407a9e:	eb04 4311 	add.w	r3, r4, r1, lsr #16
  407aa2:	45ae      	cmp	lr, r5
  407aa4:	ea4f 4113 	mov.w	r1, r3, lsr #16
  407aa8:	d8e6      	bhi.n	407a78 <__multiply+0xc4>
  407aaa:	607b      	str	r3, [r7, #4]
  407aac:	4592      	cmp	sl, r2
  407aae:	f10c 0c04 	add.w	ip, ip, #4
  407ab2:	d8af      	bhi.n	407a14 <__multiply+0x60>
  407ab4:	f8dd 9004 	ldr.w	r9, [sp, #4]
  407ab8:	f1b8 0f00 	cmp.w	r8, #0
  407abc:	dd0b      	ble.n	407ad6 <__multiply+0x122>
  407abe:	f859 3c04 	ldr.w	r3, [r9, #-4]
  407ac2:	f1a9 0904 	sub.w	r9, r9, #4
  407ac6:	b11b      	cbz	r3, 407ad0 <__multiply+0x11c>
  407ac8:	e005      	b.n	407ad6 <__multiply+0x122>
  407aca:	f859 3d04 	ldr.w	r3, [r9, #-4]!
  407ace:	b913      	cbnz	r3, 407ad6 <__multiply+0x122>
  407ad0:	f1b8 0801 	subs.w	r8, r8, #1
  407ad4:	d1f9      	bne.n	407aca <__multiply+0x116>
  407ad6:	9800      	ldr	r0, [sp, #0]
  407ad8:	f8c0 8010 	str.w	r8, [r0, #16]
  407adc:	b003      	add	sp, #12
  407ade:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407ae2:	4615      	mov	r5, r2
  407ae4:	460c      	mov	r4, r1
  407ae6:	e772      	b.n	4079ce <__multiply+0x1a>

00407ae8 <__pow5mult>:
  407ae8:	f012 0303 	ands.w	r3, r2, #3
  407aec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  407af0:	4614      	mov	r4, r2
  407af2:	4607      	mov	r7, r0
  407af4:	460e      	mov	r6, r1
  407af6:	d12d      	bne.n	407b54 <__pow5mult+0x6c>
  407af8:	10a4      	asrs	r4, r4, #2
  407afa:	d01c      	beq.n	407b36 <__pow5mult+0x4e>
  407afc:	6cbd      	ldr	r5, [r7, #72]	; 0x48
  407afe:	b395      	cbz	r5, 407b66 <__pow5mult+0x7e>
  407b00:	07e3      	lsls	r3, r4, #31
  407b02:	f04f 0800 	mov.w	r8, #0
  407b06:	d406      	bmi.n	407b16 <__pow5mult+0x2e>
  407b08:	1064      	asrs	r4, r4, #1
  407b0a:	d014      	beq.n	407b36 <__pow5mult+0x4e>
  407b0c:	6828      	ldr	r0, [r5, #0]
  407b0e:	b1a8      	cbz	r0, 407b3c <__pow5mult+0x54>
  407b10:	4605      	mov	r5, r0
  407b12:	07e3      	lsls	r3, r4, #31
  407b14:	d5f8      	bpl.n	407b08 <__pow5mult+0x20>
  407b16:	4638      	mov	r0, r7
  407b18:	4631      	mov	r1, r6
  407b1a:	462a      	mov	r2, r5
  407b1c:	f7ff ff4a 	bl	4079b4 <__multiply>
  407b20:	b1b6      	cbz	r6, 407b50 <__pow5mult+0x68>
  407b22:	6872      	ldr	r2, [r6, #4]
  407b24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  407b26:	1064      	asrs	r4, r4, #1
  407b28:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  407b2c:	6031      	str	r1, [r6, #0]
  407b2e:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  407b32:	4606      	mov	r6, r0
  407b34:	d1ea      	bne.n	407b0c <__pow5mult+0x24>
  407b36:	4630      	mov	r0, r6
  407b38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  407b3c:	4629      	mov	r1, r5
  407b3e:	462a      	mov	r2, r5
  407b40:	4638      	mov	r0, r7
  407b42:	f7ff ff37 	bl	4079b4 <__multiply>
  407b46:	6028      	str	r0, [r5, #0]
  407b48:	f8c0 8000 	str.w	r8, [r0]
  407b4c:	4605      	mov	r5, r0
  407b4e:	e7e0      	b.n	407b12 <__pow5mult+0x2a>
  407b50:	4606      	mov	r6, r0
  407b52:	e7d9      	b.n	407b08 <__pow5mult+0x20>
  407b54:	1e5a      	subs	r2, r3, #1
  407b56:	4d0b      	ldr	r5, [pc, #44]	; (407b84 <__pow5mult+0x9c>)
  407b58:	2300      	movs	r3, #0
  407b5a:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
  407b5e:	f7ff fe8f 	bl	407880 <__multadd>
  407b62:	4606      	mov	r6, r0
  407b64:	e7c8      	b.n	407af8 <__pow5mult+0x10>
  407b66:	2101      	movs	r1, #1
  407b68:	4638      	mov	r0, r7
  407b6a:	f7ff fe59 	bl	407820 <_Balloc>
  407b6e:	f240 2171 	movw	r1, #625	; 0x271
  407b72:	2201      	movs	r2, #1
  407b74:	2300      	movs	r3, #0
  407b76:	6141      	str	r1, [r0, #20]
  407b78:	6102      	str	r2, [r0, #16]
  407b7a:	4605      	mov	r5, r0
  407b7c:	64b8      	str	r0, [r7, #72]	; 0x48
  407b7e:	6003      	str	r3, [r0, #0]
  407b80:	e7be      	b.n	407b00 <__pow5mult+0x18>
  407b82:	bf00      	nop
  407b84:	0040a200 	.word	0x0040a200

00407b88 <__lshift>:
  407b88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  407b8c:	690f      	ldr	r7, [r1, #16]
  407b8e:	688b      	ldr	r3, [r1, #8]
  407b90:	ea4f 1962 	mov.w	r9, r2, asr #5
  407b94:	444f      	add	r7, r9
  407b96:	1c7d      	adds	r5, r7, #1
  407b98:	429d      	cmp	r5, r3
  407b9a:	460e      	mov	r6, r1
  407b9c:	4614      	mov	r4, r2
  407b9e:	6849      	ldr	r1, [r1, #4]
  407ba0:	4680      	mov	r8, r0
  407ba2:	dd04      	ble.n	407bae <__lshift+0x26>
  407ba4:	005b      	lsls	r3, r3, #1
  407ba6:	429d      	cmp	r5, r3
  407ba8:	f101 0101 	add.w	r1, r1, #1
  407bac:	dcfa      	bgt.n	407ba4 <__lshift+0x1c>
  407bae:	4640      	mov	r0, r8
  407bb0:	f7ff fe36 	bl	407820 <_Balloc>
  407bb4:	f1b9 0f00 	cmp.w	r9, #0
  407bb8:	f100 0114 	add.w	r1, r0, #20
  407bbc:	dd09      	ble.n	407bd2 <__lshift+0x4a>
  407bbe:	2300      	movs	r3, #0
  407bc0:	469e      	mov	lr, r3
  407bc2:	460a      	mov	r2, r1
  407bc4:	3301      	adds	r3, #1
  407bc6:	454b      	cmp	r3, r9
  407bc8:	f842 eb04 	str.w	lr, [r2], #4
  407bcc:	d1fa      	bne.n	407bc4 <__lshift+0x3c>
  407bce:	eb01 0183 	add.w	r1, r1, r3, lsl #2
  407bd2:	6932      	ldr	r2, [r6, #16]
  407bd4:	f106 0314 	add.w	r3, r6, #20
  407bd8:	f014 0c1f 	ands.w	ip, r4, #31
  407bdc:	eb03 0e82 	add.w	lr, r3, r2, lsl #2
  407be0:	d01f      	beq.n	407c22 <__lshift+0x9a>
  407be2:	f1cc 0920 	rsb	r9, ip, #32
  407be6:	2200      	movs	r2, #0
  407be8:	681c      	ldr	r4, [r3, #0]
  407bea:	fa04 f40c 	lsl.w	r4, r4, ip
  407bee:	4314      	orrs	r4, r2
  407bf0:	468a      	mov	sl, r1
  407bf2:	f841 4b04 	str.w	r4, [r1], #4
  407bf6:	f853 4b04 	ldr.w	r4, [r3], #4
  407bfa:	459e      	cmp	lr, r3
  407bfc:	fa24 f209 	lsr.w	r2, r4, r9
  407c00:	d8f2      	bhi.n	407be8 <__lshift+0x60>
  407c02:	f8ca 2004 	str.w	r2, [sl, #4]
  407c06:	b102      	cbz	r2, 407c0a <__lshift+0x82>
  407c08:	1cbd      	adds	r5, r7, #2
  407c0a:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
  407c0e:	6872      	ldr	r2, [r6, #4]
  407c10:	3d01      	subs	r5, #1
  407c12:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  407c16:	6105      	str	r5, [r0, #16]
  407c18:	6031      	str	r1, [r6, #0]
  407c1a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  407c1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  407c22:	3904      	subs	r1, #4
  407c24:	f853 2b04 	ldr.w	r2, [r3], #4
  407c28:	f841 2f04 	str.w	r2, [r1, #4]!
  407c2c:	459e      	cmp	lr, r3
  407c2e:	d8f9      	bhi.n	407c24 <__lshift+0x9c>
  407c30:	e7eb      	b.n	407c0a <__lshift+0x82>
  407c32:	bf00      	nop

00407c34 <__mcmp>:
  407c34:	6902      	ldr	r2, [r0, #16]
  407c36:	690b      	ldr	r3, [r1, #16]
  407c38:	1ad2      	subs	r2, r2, r3
  407c3a:	d113      	bne.n	407c64 <__mcmp+0x30>
  407c3c:	009b      	lsls	r3, r3, #2
  407c3e:	3014      	adds	r0, #20
  407c40:	3114      	adds	r1, #20
  407c42:	4419      	add	r1, r3
  407c44:	b410      	push	{r4}
  407c46:	4403      	add	r3, r0
  407c48:	e001      	b.n	407c4e <__mcmp+0x1a>
  407c4a:	4298      	cmp	r0, r3
  407c4c:	d20c      	bcs.n	407c68 <__mcmp+0x34>
  407c4e:	f853 4d04 	ldr.w	r4, [r3, #-4]!
  407c52:	f851 2d04 	ldr.w	r2, [r1, #-4]!
  407c56:	4294      	cmp	r4, r2
  407c58:	d0f7      	beq.n	407c4a <__mcmp+0x16>
  407c5a:	d309      	bcc.n	407c70 <__mcmp+0x3c>
  407c5c:	2001      	movs	r0, #1
  407c5e:	f85d 4b04 	ldr.w	r4, [sp], #4
  407c62:	4770      	bx	lr
  407c64:	4610      	mov	r0, r2
  407c66:	4770      	bx	lr
  407c68:	2000      	movs	r0, #0
  407c6a:	f85d 4b04 	ldr.w	r4, [sp], #4
  407c6e:	4770      	bx	lr
  407c70:	f04f 30ff 	mov.w	r0, #4294967295
  407c74:	f85d 4b04 	ldr.w	r4, [sp], #4
  407c78:	4770      	bx	lr
  407c7a:	bf00      	nop

00407c7c <__mdiff>:
  407c7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  407c80:	460e      	mov	r6, r1
  407c82:	4605      	mov	r5, r0
  407c84:	4611      	mov	r1, r2
  407c86:	4630      	mov	r0, r6
  407c88:	4614      	mov	r4, r2
  407c8a:	f7ff ffd3 	bl	407c34 <__mcmp>
  407c8e:	1e07      	subs	r7, r0, #0
  407c90:	d054      	beq.n	407d3c <__mdiff+0xc0>
  407c92:	db4d      	blt.n	407d30 <__mdiff+0xb4>
  407c94:	f04f 0800 	mov.w	r8, #0
  407c98:	6871      	ldr	r1, [r6, #4]
  407c9a:	4628      	mov	r0, r5
  407c9c:	f7ff fdc0 	bl	407820 <_Balloc>
  407ca0:	6937      	ldr	r7, [r6, #16]
  407ca2:	6923      	ldr	r3, [r4, #16]
  407ca4:	f8c0 800c 	str.w	r8, [r0, #12]
  407ca8:	3614      	adds	r6, #20
  407caa:	f104 0214 	add.w	r2, r4, #20
  407cae:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
  407cb2:	f100 0514 	add.w	r5, r0, #20
  407cb6:	eb06 0e87 	add.w	lr, r6, r7, lsl #2
  407cba:	2300      	movs	r3, #0
  407cbc:	f856 8b04 	ldr.w	r8, [r6], #4
  407cc0:	f852 4b04 	ldr.w	r4, [r2], #4
  407cc4:	fa13 f388 	uxtah	r3, r3, r8
  407cc8:	b2a1      	uxth	r1, r4
  407cca:	0c24      	lsrs	r4, r4, #16
  407ccc:	1a59      	subs	r1, r3, r1
  407cce:	ebc4 4318 	rsb	r3, r4, r8, lsr #16
  407cd2:	eb03 4321 	add.w	r3, r3, r1, asr #16
  407cd6:	b289      	uxth	r1, r1
  407cd8:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  407cdc:	4594      	cmp	ip, r2
  407cde:	f845 1b04 	str.w	r1, [r5], #4
  407ce2:	ea4f 4323 	mov.w	r3, r3, asr #16
  407ce6:	4634      	mov	r4, r6
  407ce8:	d8e8      	bhi.n	407cbc <__mdiff+0x40>
  407cea:	45b6      	cmp	lr, r6
  407cec:	46ac      	mov	ip, r5
  407cee:	d915      	bls.n	407d1c <__mdiff+0xa0>
  407cf0:	f854 2b04 	ldr.w	r2, [r4], #4
  407cf4:	fa13 f182 	uxtah	r1, r3, r2
  407cf8:	0c13      	lsrs	r3, r2, #16
  407cfa:	eb03 4321 	add.w	r3, r3, r1, asr #16
  407cfe:	b289      	uxth	r1, r1
  407d00:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  407d04:	45a6      	cmp	lr, r4
  407d06:	f845 1b04 	str.w	r1, [r5], #4
  407d0a:	ea4f 4323 	mov.w	r3, r3, asr #16
  407d0e:	d8ef      	bhi.n	407cf0 <__mdiff+0x74>
  407d10:	43f6      	mvns	r6, r6
  407d12:	4476      	add	r6, lr
  407d14:	f026 0503 	bic.w	r5, r6, #3
  407d18:	3504      	adds	r5, #4
  407d1a:	4465      	add	r5, ip
  407d1c:	3d04      	subs	r5, #4
  407d1e:	b921      	cbnz	r1, 407d2a <__mdiff+0xae>
  407d20:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  407d24:	3f01      	subs	r7, #1
  407d26:	2b00      	cmp	r3, #0
  407d28:	d0fa      	beq.n	407d20 <__mdiff+0xa4>
  407d2a:	6107      	str	r7, [r0, #16]
  407d2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  407d30:	4633      	mov	r3, r6
  407d32:	f04f 0801 	mov.w	r8, #1
  407d36:	4626      	mov	r6, r4
  407d38:	461c      	mov	r4, r3
  407d3a:	e7ad      	b.n	407c98 <__mdiff+0x1c>
  407d3c:	4628      	mov	r0, r5
  407d3e:	4639      	mov	r1, r7
  407d40:	f7ff fd6e 	bl	407820 <_Balloc>
  407d44:	2301      	movs	r3, #1
  407d46:	6147      	str	r7, [r0, #20]
  407d48:	6103      	str	r3, [r0, #16]
  407d4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  407d4e:	bf00      	nop

00407d50 <__d2b>:
  407d50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  407d54:	b082      	sub	sp, #8
  407d56:	2101      	movs	r1, #1
  407d58:	461c      	mov	r4, r3
  407d5a:	f3c3 570a 	ubfx	r7, r3, #20, #11
  407d5e:	4615      	mov	r5, r2
  407d60:	9e08      	ldr	r6, [sp, #32]
  407d62:	f7ff fd5d 	bl	407820 <_Balloc>
  407d66:	f3c4 0413 	ubfx	r4, r4, #0, #20
  407d6a:	4680      	mov	r8, r0
  407d6c:	b10f      	cbz	r7, 407d72 <__d2b+0x22>
  407d6e:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
  407d72:	9401      	str	r4, [sp, #4]
  407d74:	b31d      	cbz	r5, 407dbe <__d2b+0x6e>
  407d76:	a802      	add	r0, sp, #8
  407d78:	f840 5d08 	str.w	r5, [r0, #-8]!
  407d7c:	f7ff fde2 	bl	407944 <__lo0bits>
  407d80:	2800      	cmp	r0, #0
  407d82:	d134      	bne.n	407dee <__d2b+0x9e>
  407d84:	e89d 000c 	ldmia.w	sp, {r2, r3}
  407d88:	f8c8 2014 	str.w	r2, [r8, #20]
  407d8c:	2b00      	cmp	r3, #0
  407d8e:	bf14      	ite	ne
  407d90:	2402      	movne	r4, #2
  407d92:	2401      	moveq	r4, #1
  407d94:	f8c8 3018 	str.w	r3, [r8, #24]
  407d98:	f8c8 4010 	str.w	r4, [r8, #16]
  407d9c:	b9df      	cbnz	r7, 407dd6 <__d2b+0x86>
  407d9e:	eb08 0384 	add.w	r3, r8, r4, lsl #2
  407da2:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
  407da6:	6030      	str	r0, [r6, #0]
  407da8:	6918      	ldr	r0, [r3, #16]
  407daa:	f7ff fdab 	bl	407904 <__hi0bits>
  407dae:	9b09      	ldr	r3, [sp, #36]	; 0x24
  407db0:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
  407db4:	6018      	str	r0, [r3, #0]
  407db6:	4640      	mov	r0, r8
  407db8:	b002      	add	sp, #8
  407dba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  407dbe:	a801      	add	r0, sp, #4
  407dc0:	f7ff fdc0 	bl	407944 <__lo0bits>
  407dc4:	2401      	movs	r4, #1
  407dc6:	9b01      	ldr	r3, [sp, #4]
  407dc8:	f8c8 3014 	str.w	r3, [r8, #20]
  407dcc:	3020      	adds	r0, #32
  407dce:	f8c8 4010 	str.w	r4, [r8, #16]
  407dd2:	2f00      	cmp	r7, #0
  407dd4:	d0e3      	beq.n	407d9e <__d2b+0x4e>
  407dd6:	9b09      	ldr	r3, [sp, #36]	; 0x24
  407dd8:	f2a7 4733 	subw	r7, r7, #1075	; 0x433
  407ddc:	4407      	add	r7, r0
  407dde:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
  407de2:	6037      	str	r7, [r6, #0]
  407de4:	6018      	str	r0, [r3, #0]
  407de6:	4640      	mov	r0, r8
  407de8:	b002      	add	sp, #8
  407dea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  407dee:	e89d 000c 	ldmia.w	sp, {r2, r3}
  407df2:	f1c0 0120 	rsb	r1, r0, #32
  407df6:	fa03 f101 	lsl.w	r1, r3, r1
  407dfa:	430a      	orrs	r2, r1
  407dfc:	40c3      	lsrs	r3, r0
  407dfe:	9301      	str	r3, [sp, #4]
  407e00:	f8c8 2014 	str.w	r2, [r8, #20]
  407e04:	e7c2      	b.n	407d8c <__d2b+0x3c>
  407e06:	bf00      	nop

00407e08 <_realloc_r>:
  407e08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  407e0c:	4617      	mov	r7, r2
  407e0e:	b083      	sub	sp, #12
  407e10:	460e      	mov	r6, r1
  407e12:	2900      	cmp	r1, #0
  407e14:	f000 80e7 	beq.w	407fe6 <_realloc_r+0x1de>
  407e18:	4681      	mov	r9, r0
  407e1a:	f107 050b 	add.w	r5, r7, #11
  407e1e:	f7ff fcfb 	bl	407818 <__malloc_lock>
  407e22:	f856 3c04 	ldr.w	r3, [r6, #-4]
  407e26:	2d16      	cmp	r5, #22
  407e28:	f023 0403 	bic.w	r4, r3, #3
  407e2c:	f1a6 0808 	sub.w	r8, r6, #8
  407e30:	d84c      	bhi.n	407ecc <_realloc_r+0xc4>
  407e32:	2210      	movs	r2, #16
  407e34:	4615      	mov	r5, r2
  407e36:	42af      	cmp	r7, r5
  407e38:	d84d      	bhi.n	407ed6 <_realloc_r+0xce>
  407e3a:	4294      	cmp	r4, r2
  407e3c:	f280 8084 	bge.w	407f48 <_realloc_r+0x140>
  407e40:	f8df b3ac 	ldr.w	fp, [pc, #940]	; 4081f0 <_realloc_r+0x3e8>
  407e44:	f8db 0008 	ldr.w	r0, [fp, #8]
  407e48:	eb08 0104 	add.w	r1, r8, r4
  407e4c:	4288      	cmp	r0, r1
  407e4e:	f000 80d6 	beq.w	407ffe <_realloc_r+0x1f6>
  407e52:	6848      	ldr	r0, [r1, #4]
  407e54:	f020 0e01 	bic.w	lr, r0, #1
  407e58:	448e      	add	lr, r1
  407e5a:	f8de e004 	ldr.w	lr, [lr, #4]
  407e5e:	f01e 0f01 	tst.w	lr, #1
  407e62:	d13f      	bne.n	407ee4 <_realloc_r+0xdc>
  407e64:	f020 0003 	bic.w	r0, r0, #3
  407e68:	4420      	add	r0, r4
  407e6a:	4290      	cmp	r0, r2
  407e6c:	f280 80c1 	bge.w	407ff2 <_realloc_r+0x1ea>
  407e70:	07db      	lsls	r3, r3, #31
  407e72:	f100 808f 	bmi.w	407f94 <_realloc_r+0x18c>
  407e76:	f856 3c08 	ldr.w	r3, [r6, #-8]
  407e7a:	ebc3 0a08 	rsb	sl, r3, r8
  407e7e:	f8da 3004 	ldr.w	r3, [sl, #4]
  407e82:	f023 0303 	bic.w	r3, r3, #3
  407e86:	eb00 0e03 	add.w	lr, r0, r3
  407e8a:	4596      	cmp	lr, r2
  407e8c:	db34      	blt.n	407ef8 <_realloc_r+0xf0>
  407e8e:	68cb      	ldr	r3, [r1, #12]
  407e90:	688a      	ldr	r2, [r1, #8]
  407e92:	4657      	mov	r7, sl
  407e94:	60d3      	str	r3, [r2, #12]
  407e96:	609a      	str	r2, [r3, #8]
  407e98:	f857 1f08 	ldr.w	r1, [r7, #8]!
  407e9c:	f8da 300c 	ldr.w	r3, [sl, #12]
  407ea0:	60cb      	str	r3, [r1, #12]
  407ea2:	1f22      	subs	r2, r4, #4
  407ea4:	2a24      	cmp	r2, #36	; 0x24
  407ea6:	6099      	str	r1, [r3, #8]
  407ea8:	f200 8136 	bhi.w	408118 <_realloc_r+0x310>
  407eac:	2a13      	cmp	r2, #19
  407eae:	f240 80fd 	bls.w	4080ac <_realloc_r+0x2a4>
  407eb2:	6833      	ldr	r3, [r6, #0]
  407eb4:	f8ca 3008 	str.w	r3, [sl, #8]
  407eb8:	6873      	ldr	r3, [r6, #4]
  407eba:	f8ca 300c 	str.w	r3, [sl, #12]
  407ebe:	2a1b      	cmp	r2, #27
  407ec0:	f200 8140 	bhi.w	408144 <_realloc_r+0x33c>
  407ec4:	3608      	adds	r6, #8
  407ec6:	f10a 0310 	add.w	r3, sl, #16
  407eca:	e0f0      	b.n	4080ae <_realloc_r+0x2a6>
  407ecc:	f025 0507 	bic.w	r5, r5, #7
  407ed0:	2d00      	cmp	r5, #0
  407ed2:	462a      	mov	r2, r5
  407ed4:	daaf      	bge.n	407e36 <_realloc_r+0x2e>
  407ed6:	230c      	movs	r3, #12
  407ed8:	2000      	movs	r0, #0
  407eda:	f8c9 3000 	str.w	r3, [r9]
  407ede:	b003      	add	sp, #12
  407ee0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407ee4:	07d9      	lsls	r1, r3, #31
  407ee6:	d455      	bmi.n	407f94 <_realloc_r+0x18c>
  407ee8:	f856 3c08 	ldr.w	r3, [r6, #-8]
  407eec:	ebc3 0a08 	rsb	sl, r3, r8
  407ef0:	f8da 3004 	ldr.w	r3, [sl, #4]
  407ef4:	f023 0303 	bic.w	r3, r3, #3
  407ef8:	4423      	add	r3, r4
  407efa:	4293      	cmp	r3, r2
  407efc:	db4a      	blt.n	407f94 <_realloc_r+0x18c>
  407efe:	4657      	mov	r7, sl
  407f00:	f8da 100c 	ldr.w	r1, [sl, #12]
  407f04:	f857 0f08 	ldr.w	r0, [r7, #8]!
  407f08:	1f22      	subs	r2, r4, #4
  407f0a:	2a24      	cmp	r2, #36	; 0x24
  407f0c:	60c1      	str	r1, [r0, #12]
  407f0e:	6088      	str	r0, [r1, #8]
  407f10:	f200 810e 	bhi.w	408130 <_realloc_r+0x328>
  407f14:	2a13      	cmp	r2, #19
  407f16:	f240 8109 	bls.w	40812c <_realloc_r+0x324>
  407f1a:	6831      	ldr	r1, [r6, #0]
  407f1c:	f8ca 1008 	str.w	r1, [sl, #8]
  407f20:	6871      	ldr	r1, [r6, #4]
  407f22:	f8ca 100c 	str.w	r1, [sl, #12]
  407f26:	2a1b      	cmp	r2, #27
  407f28:	f200 8121 	bhi.w	40816e <_realloc_r+0x366>
  407f2c:	3608      	adds	r6, #8
  407f2e:	f10a 0210 	add.w	r2, sl, #16
  407f32:	6831      	ldr	r1, [r6, #0]
  407f34:	6011      	str	r1, [r2, #0]
  407f36:	6871      	ldr	r1, [r6, #4]
  407f38:	6051      	str	r1, [r2, #4]
  407f3a:	68b1      	ldr	r1, [r6, #8]
  407f3c:	6091      	str	r1, [r2, #8]
  407f3e:	461c      	mov	r4, r3
  407f40:	f8da 3004 	ldr.w	r3, [sl, #4]
  407f44:	463e      	mov	r6, r7
  407f46:	46d0      	mov	r8, sl
  407f48:	1b62      	subs	r2, r4, r5
  407f4a:	2a0f      	cmp	r2, #15
  407f4c:	f003 0301 	and.w	r3, r3, #1
  407f50:	d80e      	bhi.n	407f70 <_realloc_r+0x168>
  407f52:	4323      	orrs	r3, r4
  407f54:	4444      	add	r4, r8
  407f56:	f8c8 3004 	str.w	r3, [r8, #4]
  407f5a:	6863      	ldr	r3, [r4, #4]
  407f5c:	f043 0301 	orr.w	r3, r3, #1
  407f60:	6063      	str	r3, [r4, #4]
  407f62:	4648      	mov	r0, r9
  407f64:	f7ff fc5a 	bl	40781c <__malloc_unlock>
  407f68:	4630      	mov	r0, r6
  407f6a:	b003      	add	sp, #12
  407f6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407f70:	eb08 0105 	add.w	r1, r8, r5
  407f74:	431d      	orrs	r5, r3
  407f76:	f042 0301 	orr.w	r3, r2, #1
  407f7a:	440a      	add	r2, r1
  407f7c:	f8c8 5004 	str.w	r5, [r8, #4]
  407f80:	604b      	str	r3, [r1, #4]
  407f82:	6853      	ldr	r3, [r2, #4]
  407f84:	f043 0301 	orr.w	r3, r3, #1
  407f88:	3108      	adds	r1, #8
  407f8a:	6053      	str	r3, [r2, #4]
  407f8c:	4648      	mov	r0, r9
  407f8e:	f7fe fff5 	bl	406f7c <_free_r>
  407f92:	e7e6      	b.n	407f62 <_realloc_r+0x15a>
  407f94:	4639      	mov	r1, r7
  407f96:	4648      	mov	r0, r9
  407f98:	f7ff f8fe 	bl	407198 <_malloc_r>
  407f9c:	4607      	mov	r7, r0
  407f9e:	b1d8      	cbz	r0, 407fd8 <_realloc_r+0x1d0>
  407fa0:	f856 3c04 	ldr.w	r3, [r6, #-4]
  407fa4:	f023 0201 	bic.w	r2, r3, #1
  407fa8:	4442      	add	r2, r8
  407faa:	f1a0 0108 	sub.w	r1, r0, #8
  407fae:	4291      	cmp	r1, r2
  407fb0:	f000 80ac 	beq.w	40810c <_realloc_r+0x304>
  407fb4:	1f22      	subs	r2, r4, #4
  407fb6:	2a24      	cmp	r2, #36	; 0x24
  407fb8:	f200 8099 	bhi.w	4080ee <_realloc_r+0x2e6>
  407fbc:	2a13      	cmp	r2, #19
  407fbe:	d86a      	bhi.n	408096 <_realloc_r+0x28e>
  407fc0:	4603      	mov	r3, r0
  407fc2:	4632      	mov	r2, r6
  407fc4:	6811      	ldr	r1, [r2, #0]
  407fc6:	6019      	str	r1, [r3, #0]
  407fc8:	6851      	ldr	r1, [r2, #4]
  407fca:	6059      	str	r1, [r3, #4]
  407fcc:	6892      	ldr	r2, [r2, #8]
  407fce:	609a      	str	r2, [r3, #8]
  407fd0:	4631      	mov	r1, r6
  407fd2:	4648      	mov	r0, r9
  407fd4:	f7fe ffd2 	bl	406f7c <_free_r>
  407fd8:	4648      	mov	r0, r9
  407fda:	f7ff fc1f 	bl	40781c <__malloc_unlock>
  407fde:	4638      	mov	r0, r7
  407fe0:	b003      	add	sp, #12
  407fe2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407fe6:	4611      	mov	r1, r2
  407fe8:	b003      	add	sp, #12
  407fea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  407fee:	f7ff b8d3 	b.w	407198 <_malloc_r>
  407ff2:	68ca      	ldr	r2, [r1, #12]
  407ff4:	6889      	ldr	r1, [r1, #8]
  407ff6:	4604      	mov	r4, r0
  407ff8:	60ca      	str	r2, [r1, #12]
  407ffa:	6091      	str	r1, [r2, #8]
  407ffc:	e7a4      	b.n	407f48 <_realloc_r+0x140>
  407ffe:	6841      	ldr	r1, [r0, #4]
  408000:	f021 0103 	bic.w	r1, r1, #3
  408004:	4421      	add	r1, r4
  408006:	f105 0010 	add.w	r0, r5, #16
  40800a:	4281      	cmp	r1, r0
  40800c:	da5b      	bge.n	4080c6 <_realloc_r+0x2be>
  40800e:	07db      	lsls	r3, r3, #31
  408010:	d4c0      	bmi.n	407f94 <_realloc_r+0x18c>
  408012:	f856 3c08 	ldr.w	r3, [r6, #-8]
  408016:	ebc3 0a08 	rsb	sl, r3, r8
  40801a:	f8da 3004 	ldr.w	r3, [sl, #4]
  40801e:	f023 0303 	bic.w	r3, r3, #3
  408022:	eb01 0c03 	add.w	ip, r1, r3
  408026:	4560      	cmp	r0, ip
  408028:	f73f af66 	bgt.w	407ef8 <_realloc_r+0xf0>
  40802c:	4657      	mov	r7, sl
  40802e:	f8da 300c 	ldr.w	r3, [sl, #12]
  408032:	f857 1f08 	ldr.w	r1, [r7, #8]!
  408036:	1f22      	subs	r2, r4, #4
  408038:	2a24      	cmp	r2, #36	; 0x24
  40803a:	60cb      	str	r3, [r1, #12]
  40803c:	6099      	str	r1, [r3, #8]
  40803e:	f200 80b8 	bhi.w	4081b2 <_realloc_r+0x3aa>
  408042:	2a13      	cmp	r2, #19
  408044:	f240 80a9 	bls.w	40819a <_realloc_r+0x392>
  408048:	6833      	ldr	r3, [r6, #0]
  40804a:	f8ca 3008 	str.w	r3, [sl, #8]
  40804e:	6873      	ldr	r3, [r6, #4]
  408050:	f8ca 300c 	str.w	r3, [sl, #12]
  408054:	2a1b      	cmp	r2, #27
  408056:	f200 80b5 	bhi.w	4081c4 <_realloc_r+0x3bc>
  40805a:	3608      	adds	r6, #8
  40805c:	f10a 0310 	add.w	r3, sl, #16
  408060:	6832      	ldr	r2, [r6, #0]
  408062:	601a      	str	r2, [r3, #0]
  408064:	6872      	ldr	r2, [r6, #4]
  408066:	605a      	str	r2, [r3, #4]
  408068:	68b2      	ldr	r2, [r6, #8]
  40806a:	609a      	str	r2, [r3, #8]
  40806c:	eb0a 0205 	add.w	r2, sl, r5
  408070:	ebc5 030c 	rsb	r3, r5, ip
  408074:	f043 0301 	orr.w	r3, r3, #1
  408078:	f8cb 2008 	str.w	r2, [fp, #8]
  40807c:	6053      	str	r3, [r2, #4]
  40807e:	f8da 3004 	ldr.w	r3, [sl, #4]
  408082:	f003 0301 	and.w	r3, r3, #1
  408086:	431d      	orrs	r5, r3
  408088:	4648      	mov	r0, r9
  40808a:	f8ca 5004 	str.w	r5, [sl, #4]
  40808e:	f7ff fbc5 	bl	40781c <__malloc_unlock>
  408092:	4638      	mov	r0, r7
  408094:	e769      	b.n	407f6a <_realloc_r+0x162>
  408096:	6833      	ldr	r3, [r6, #0]
  408098:	6003      	str	r3, [r0, #0]
  40809a:	6873      	ldr	r3, [r6, #4]
  40809c:	6043      	str	r3, [r0, #4]
  40809e:	2a1b      	cmp	r2, #27
  4080a0:	d829      	bhi.n	4080f6 <_realloc_r+0x2ee>
  4080a2:	f100 0308 	add.w	r3, r0, #8
  4080a6:	f106 0208 	add.w	r2, r6, #8
  4080aa:	e78b      	b.n	407fc4 <_realloc_r+0x1bc>
  4080ac:	463b      	mov	r3, r7
  4080ae:	6832      	ldr	r2, [r6, #0]
  4080b0:	601a      	str	r2, [r3, #0]
  4080b2:	6872      	ldr	r2, [r6, #4]
  4080b4:	605a      	str	r2, [r3, #4]
  4080b6:	68b2      	ldr	r2, [r6, #8]
  4080b8:	609a      	str	r2, [r3, #8]
  4080ba:	463e      	mov	r6, r7
  4080bc:	4674      	mov	r4, lr
  4080be:	f8da 3004 	ldr.w	r3, [sl, #4]
  4080c2:	46d0      	mov	r8, sl
  4080c4:	e740      	b.n	407f48 <_realloc_r+0x140>
  4080c6:	eb08 0205 	add.w	r2, r8, r5
  4080ca:	1b4b      	subs	r3, r1, r5
  4080cc:	f043 0301 	orr.w	r3, r3, #1
  4080d0:	f8cb 2008 	str.w	r2, [fp, #8]
  4080d4:	6053      	str	r3, [r2, #4]
  4080d6:	f856 3c04 	ldr.w	r3, [r6, #-4]
  4080da:	f003 0301 	and.w	r3, r3, #1
  4080de:	431d      	orrs	r5, r3
  4080e0:	4648      	mov	r0, r9
  4080e2:	f846 5c04 	str.w	r5, [r6, #-4]
  4080e6:	f7ff fb99 	bl	40781c <__malloc_unlock>
  4080ea:	4630      	mov	r0, r6
  4080ec:	e73d      	b.n	407f6a <_realloc_r+0x162>
  4080ee:	4631      	mov	r1, r6
  4080f0:	f7ff fb2e 	bl	407750 <memmove>
  4080f4:	e76c      	b.n	407fd0 <_realloc_r+0x1c8>
  4080f6:	68b3      	ldr	r3, [r6, #8]
  4080f8:	6083      	str	r3, [r0, #8]
  4080fa:	68f3      	ldr	r3, [r6, #12]
  4080fc:	60c3      	str	r3, [r0, #12]
  4080fe:	2a24      	cmp	r2, #36	; 0x24
  408100:	d02c      	beq.n	40815c <_realloc_r+0x354>
  408102:	f100 0310 	add.w	r3, r0, #16
  408106:	f106 0210 	add.w	r2, r6, #16
  40810a:	e75b      	b.n	407fc4 <_realloc_r+0x1bc>
  40810c:	f850 2c04 	ldr.w	r2, [r0, #-4]
  408110:	f022 0203 	bic.w	r2, r2, #3
  408114:	4414      	add	r4, r2
  408116:	e717      	b.n	407f48 <_realloc_r+0x140>
  408118:	4631      	mov	r1, r6
  40811a:	4638      	mov	r0, r7
  40811c:	4674      	mov	r4, lr
  40811e:	463e      	mov	r6, r7
  408120:	f7ff fb16 	bl	407750 <memmove>
  408124:	46d0      	mov	r8, sl
  408126:	f8da 3004 	ldr.w	r3, [sl, #4]
  40812a:	e70d      	b.n	407f48 <_realloc_r+0x140>
  40812c:	463a      	mov	r2, r7
  40812e:	e700      	b.n	407f32 <_realloc_r+0x12a>
  408130:	4631      	mov	r1, r6
  408132:	4638      	mov	r0, r7
  408134:	461c      	mov	r4, r3
  408136:	463e      	mov	r6, r7
  408138:	f7ff fb0a 	bl	407750 <memmove>
  40813c:	46d0      	mov	r8, sl
  40813e:	f8da 3004 	ldr.w	r3, [sl, #4]
  408142:	e701      	b.n	407f48 <_realloc_r+0x140>
  408144:	68b3      	ldr	r3, [r6, #8]
  408146:	f8ca 3010 	str.w	r3, [sl, #16]
  40814a:	68f3      	ldr	r3, [r6, #12]
  40814c:	f8ca 3014 	str.w	r3, [sl, #20]
  408150:	2a24      	cmp	r2, #36	; 0x24
  408152:	d018      	beq.n	408186 <_realloc_r+0x37e>
  408154:	3610      	adds	r6, #16
  408156:	f10a 0318 	add.w	r3, sl, #24
  40815a:	e7a8      	b.n	4080ae <_realloc_r+0x2a6>
  40815c:	6933      	ldr	r3, [r6, #16]
  40815e:	6103      	str	r3, [r0, #16]
  408160:	6973      	ldr	r3, [r6, #20]
  408162:	6143      	str	r3, [r0, #20]
  408164:	f106 0218 	add.w	r2, r6, #24
  408168:	f100 0318 	add.w	r3, r0, #24
  40816c:	e72a      	b.n	407fc4 <_realloc_r+0x1bc>
  40816e:	68b1      	ldr	r1, [r6, #8]
  408170:	f8ca 1010 	str.w	r1, [sl, #16]
  408174:	68f1      	ldr	r1, [r6, #12]
  408176:	f8ca 1014 	str.w	r1, [sl, #20]
  40817a:	2a24      	cmp	r2, #36	; 0x24
  40817c:	d00f      	beq.n	40819e <_realloc_r+0x396>
  40817e:	3610      	adds	r6, #16
  408180:	f10a 0218 	add.w	r2, sl, #24
  408184:	e6d5      	b.n	407f32 <_realloc_r+0x12a>
  408186:	6933      	ldr	r3, [r6, #16]
  408188:	f8ca 3018 	str.w	r3, [sl, #24]
  40818c:	6973      	ldr	r3, [r6, #20]
  40818e:	f8ca 301c 	str.w	r3, [sl, #28]
  408192:	3618      	adds	r6, #24
  408194:	f10a 0320 	add.w	r3, sl, #32
  408198:	e789      	b.n	4080ae <_realloc_r+0x2a6>
  40819a:	463b      	mov	r3, r7
  40819c:	e760      	b.n	408060 <_realloc_r+0x258>
  40819e:	6932      	ldr	r2, [r6, #16]
  4081a0:	f8ca 2018 	str.w	r2, [sl, #24]
  4081a4:	6972      	ldr	r2, [r6, #20]
  4081a6:	f8ca 201c 	str.w	r2, [sl, #28]
  4081aa:	3618      	adds	r6, #24
  4081ac:	f10a 0220 	add.w	r2, sl, #32
  4081b0:	e6bf      	b.n	407f32 <_realloc_r+0x12a>
  4081b2:	4631      	mov	r1, r6
  4081b4:	4638      	mov	r0, r7
  4081b6:	f8cd c004 	str.w	ip, [sp, #4]
  4081ba:	f7ff fac9 	bl	407750 <memmove>
  4081be:	f8dd c004 	ldr.w	ip, [sp, #4]
  4081c2:	e753      	b.n	40806c <_realloc_r+0x264>
  4081c4:	68b3      	ldr	r3, [r6, #8]
  4081c6:	f8ca 3010 	str.w	r3, [sl, #16]
  4081ca:	68f3      	ldr	r3, [r6, #12]
  4081cc:	f8ca 3014 	str.w	r3, [sl, #20]
  4081d0:	2a24      	cmp	r2, #36	; 0x24
  4081d2:	d003      	beq.n	4081dc <_realloc_r+0x3d4>
  4081d4:	3610      	adds	r6, #16
  4081d6:	f10a 0318 	add.w	r3, sl, #24
  4081da:	e741      	b.n	408060 <_realloc_r+0x258>
  4081dc:	6933      	ldr	r3, [r6, #16]
  4081de:	f8ca 3018 	str.w	r3, [sl, #24]
  4081e2:	6973      	ldr	r3, [r6, #20]
  4081e4:	f8ca 301c 	str.w	r3, [sl, #28]
  4081e8:	3618      	adds	r6, #24
  4081ea:	f10a 0320 	add.w	r3, sl, #32
  4081ee:	e737      	b.n	408060 <_realloc_r+0x258>
  4081f0:	20000488 	.word	0x20000488

004081f4 <__fpclassifyd>:
  4081f4:	b410      	push	{r4}
  4081f6:	f031 4400 	bics.w	r4, r1, #2147483648	; 0x80000000
  4081fa:	d008      	beq.n	40820e <__fpclassifyd+0x1a>
  4081fc:	4b11      	ldr	r3, [pc, #68]	; (408244 <__fpclassifyd+0x50>)
  4081fe:	f5a1 1280 	sub.w	r2, r1, #1048576	; 0x100000
  408202:	429a      	cmp	r2, r3
  408204:	d808      	bhi.n	408218 <__fpclassifyd+0x24>
  408206:	2004      	movs	r0, #4
  408208:	f85d 4b04 	ldr.w	r4, [sp], #4
  40820c:	4770      	bx	lr
  40820e:	b918      	cbnz	r0, 408218 <__fpclassifyd+0x24>
  408210:	2002      	movs	r0, #2
  408212:	f85d 4b04 	ldr.w	r4, [sp], #4
  408216:	4770      	bx	lr
  408218:	f101 41ff 	add.w	r1, r1, #2139095040	; 0x7f800000
  40821c:	4b09      	ldr	r3, [pc, #36]	; (408244 <__fpclassifyd+0x50>)
  40821e:	f501 01e0 	add.w	r1, r1, #7340032	; 0x700000
  408222:	4299      	cmp	r1, r3
  408224:	d9ef      	bls.n	408206 <__fpclassifyd+0x12>
  408226:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
  40822a:	d201      	bcs.n	408230 <__fpclassifyd+0x3c>
  40822c:	2003      	movs	r0, #3
  40822e:	e7eb      	b.n	408208 <__fpclassifyd+0x14>
  408230:	4b05      	ldr	r3, [pc, #20]	; (408248 <__fpclassifyd+0x54>)
  408232:	429c      	cmp	r4, r3
  408234:	d001      	beq.n	40823a <__fpclassifyd+0x46>
  408236:	2000      	movs	r0, #0
  408238:	e7e6      	b.n	408208 <__fpclassifyd+0x14>
  40823a:	fab0 f080 	clz	r0, r0
  40823e:	0940      	lsrs	r0, r0, #5
  408240:	e7e2      	b.n	408208 <__fpclassifyd+0x14>
  408242:	bf00      	nop
  408244:	7fdfffff 	.word	0x7fdfffff
  408248:	7ff00000 	.word	0x7ff00000

0040824c <_sbrk_r>:
  40824c:	b538      	push	{r3, r4, r5, lr}
  40824e:	4c07      	ldr	r4, [pc, #28]	; (40826c <_sbrk_r+0x20>)
  408250:	2300      	movs	r3, #0
  408252:	4605      	mov	r5, r0
  408254:	4608      	mov	r0, r1
  408256:	6023      	str	r3, [r4, #0]
  408258:	f7f9 fb9a 	bl	401990 <_sbrk>
  40825c:	1c43      	adds	r3, r0, #1
  40825e:	d000      	beq.n	408262 <_sbrk_r+0x16>
  408260:	bd38      	pop	{r3, r4, r5, pc}
  408262:	6823      	ldr	r3, [r4, #0]
  408264:	2b00      	cmp	r3, #0
  408266:	d0fb      	beq.n	408260 <_sbrk_r+0x14>
  408268:	602b      	str	r3, [r5, #0]
  40826a:	bd38      	pop	{r3, r4, r5, pc}
  40826c:	20004f1c 	.word	0x20004f1c

00408270 <__sread>:
  408270:	b510      	push	{r4, lr}
  408272:	460c      	mov	r4, r1
  408274:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  408278:	f000 f9bc 	bl	4085f4 <_read_r>
  40827c:	2800      	cmp	r0, #0
  40827e:	db03      	blt.n	408288 <__sread+0x18>
  408280:	6d23      	ldr	r3, [r4, #80]	; 0x50
  408282:	4403      	add	r3, r0
  408284:	6523      	str	r3, [r4, #80]	; 0x50
  408286:	bd10      	pop	{r4, pc}
  408288:	89a3      	ldrh	r3, [r4, #12]
  40828a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  40828e:	81a3      	strh	r3, [r4, #12]
  408290:	bd10      	pop	{r4, pc}
  408292:	bf00      	nop

00408294 <__swrite>:
  408294:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  408298:	4616      	mov	r6, r2
  40829a:	898a      	ldrh	r2, [r1, #12]
  40829c:	461d      	mov	r5, r3
  40829e:	05d3      	lsls	r3, r2, #23
  4082a0:	460c      	mov	r4, r1
  4082a2:	4607      	mov	r7, r0
  4082a4:	d506      	bpl.n	4082b4 <__swrite+0x20>
  4082a6:	2200      	movs	r2, #0
  4082a8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  4082ac:	2302      	movs	r3, #2
  4082ae:	f000 f98d 	bl	4085cc <_lseek_r>
  4082b2:	89a2      	ldrh	r2, [r4, #12]
  4082b4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  4082b8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
  4082bc:	81a2      	strh	r2, [r4, #12]
  4082be:	4638      	mov	r0, r7
  4082c0:	4632      	mov	r2, r6
  4082c2:	462b      	mov	r3, r5
  4082c4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  4082c8:	f000 b896 	b.w	4083f8 <_write_r>

004082cc <__sseek>:
  4082cc:	b510      	push	{r4, lr}
  4082ce:	460c      	mov	r4, r1
  4082d0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  4082d4:	f000 f97a 	bl	4085cc <_lseek_r>
  4082d8:	89a3      	ldrh	r3, [r4, #12]
  4082da:	1c42      	adds	r2, r0, #1
  4082dc:	bf0e      	itee	eq
  4082de:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  4082e2:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  4082e6:	6520      	strne	r0, [r4, #80]	; 0x50
  4082e8:	81a3      	strh	r3, [r4, #12]
  4082ea:	bd10      	pop	{r4, pc}

004082ec <__sclose>:
  4082ec:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  4082f0:	f000 b918 	b.w	408524 <_close_r>

004082f4 <__ssprint_r>:
  4082f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4082f8:	6893      	ldr	r3, [r2, #8]
  4082fa:	f8d2 8000 	ldr.w	r8, [r2]
  4082fe:	b083      	sub	sp, #12
  408300:	4691      	mov	r9, r2
  408302:	2b00      	cmp	r3, #0
  408304:	d072      	beq.n	4083ec <__ssprint_r+0xf8>
  408306:	4607      	mov	r7, r0
  408308:	f04f 0b00 	mov.w	fp, #0
  40830c:	6808      	ldr	r0, [r1, #0]
  40830e:	688b      	ldr	r3, [r1, #8]
  408310:	460d      	mov	r5, r1
  408312:	465c      	mov	r4, fp
  408314:	2c00      	cmp	r4, #0
  408316:	d045      	beq.n	4083a4 <__ssprint_r+0xb0>
  408318:	429c      	cmp	r4, r3
  40831a:	461e      	mov	r6, r3
  40831c:	469a      	mov	sl, r3
  40831e:	d348      	bcc.n	4083b2 <__ssprint_r+0xbe>
  408320:	89ab      	ldrh	r3, [r5, #12]
  408322:	f413 6f90 	tst.w	r3, #1152	; 0x480
  408326:	d02d      	beq.n	408384 <__ssprint_r+0x90>
  408328:	696e      	ldr	r6, [r5, #20]
  40832a:	6929      	ldr	r1, [r5, #16]
  40832c:	eb06 0646 	add.w	r6, r6, r6, lsl #1
  408330:	ebc1 0a00 	rsb	sl, r1, r0
  408334:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
  408338:	1c60      	adds	r0, r4, #1
  40833a:	1076      	asrs	r6, r6, #1
  40833c:	4450      	add	r0, sl
  40833e:	4286      	cmp	r6, r0
  408340:	4632      	mov	r2, r6
  408342:	bf3c      	itt	cc
  408344:	4606      	movcc	r6, r0
  408346:	4632      	movcc	r2, r6
  408348:	055b      	lsls	r3, r3, #21
  40834a:	d535      	bpl.n	4083b8 <__ssprint_r+0xc4>
  40834c:	4611      	mov	r1, r2
  40834e:	4638      	mov	r0, r7
  408350:	f7fe ff22 	bl	407198 <_malloc_r>
  408354:	2800      	cmp	r0, #0
  408356:	d039      	beq.n	4083cc <__ssprint_r+0xd8>
  408358:	4652      	mov	r2, sl
  40835a:	6929      	ldr	r1, [r5, #16]
  40835c:	9001      	str	r0, [sp, #4]
  40835e:	f7fb fe9f 	bl	4040a0 <memcpy>
  408362:	89aa      	ldrh	r2, [r5, #12]
  408364:	9b01      	ldr	r3, [sp, #4]
  408366:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
  40836a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  40836e:	81aa      	strh	r2, [r5, #12]
  408370:	ebca 0206 	rsb	r2, sl, r6
  408374:	eb03 000a 	add.w	r0, r3, sl
  408378:	616e      	str	r6, [r5, #20]
  40837a:	612b      	str	r3, [r5, #16]
  40837c:	6028      	str	r0, [r5, #0]
  40837e:	60aa      	str	r2, [r5, #8]
  408380:	4626      	mov	r6, r4
  408382:	46a2      	mov	sl, r4
  408384:	4652      	mov	r2, sl
  408386:	4659      	mov	r1, fp
  408388:	f7ff f9e2 	bl	407750 <memmove>
  40838c:	f8d9 2008 	ldr.w	r2, [r9, #8]
  408390:	68ab      	ldr	r3, [r5, #8]
  408392:	6828      	ldr	r0, [r5, #0]
  408394:	1b9b      	subs	r3, r3, r6
  408396:	4450      	add	r0, sl
  408398:	1b14      	subs	r4, r2, r4
  40839a:	60ab      	str	r3, [r5, #8]
  40839c:	6028      	str	r0, [r5, #0]
  40839e:	f8c9 4008 	str.w	r4, [r9, #8]
  4083a2:	b31c      	cbz	r4, 4083ec <__ssprint_r+0xf8>
  4083a4:	f8d8 b000 	ldr.w	fp, [r8]
  4083a8:	f8d8 4004 	ldr.w	r4, [r8, #4]
  4083ac:	f108 0808 	add.w	r8, r8, #8
  4083b0:	e7b0      	b.n	408314 <__ssprint_r+0x20>
  4083b2:	4626      	mov	r6, r4
  4083b4:	46a2      	mov	sl, r4
  4083b6:	e7e5      	b.n	408384 <__ssprint_r+0x90>
  4083b8:	4638      	mov	r0, r7
  4083ba:	f7ff fd25 	bl	407e08 <_realloc_r>
  4083be:	4603      	mov	r3, r0
  4083c0:	2800      	cmp	r0, #0
  4083c2:	d1d5      	bne.n	408370 <__ssprint_r+0x7c>
  4083c4:	4638      	mov	r0, r7
  4083c6:	6929      	ldr	r1, [r5, #16]
  4083c8:	f7fe fdd8 	bl	406f7c <_free_r>
  4083cc:	230c      	movs	r3, #12
  4083ce:	603b      	str	r3, [r7, #0]
  4083d0:	89ab      	ldrh	r3, [r5, #12]
  4083d2:	2200      	movs	r2, #0
  4083d4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4083d8:	f04f 30ff 	mov.w	r0, #4294967295
  4083dc:	81ab      	strh	r3, [r5, #12]
  4083de:	f8c9 2008 	str.w	r2, [r9, #8]
  4083e2:	f8c9 2004 	str.w	r2, [r9, #4]
  4083e6:	b003      	add	sp, #12
  4083e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4083ec:	2000      	movs	r0, #0
  4083ee:	f8c9 0004 	str.w	r0, [r9, #4]
  4083f2:	b003      	add	sp, #12
  4083f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

004083f8 <_write_r>:
  4083f8:	b570      	push	{r4, r5, r6, lr}
  4083fa:	4c08      	ldr	r4, [pc, #32]	; (40841c <_write_r+0x24>)
  4083fc:	4606      	mov	r6, r0
  4083fe:	2500      	movs	r5, #0
  408400:	4608      	mov	r0, r1
  408402:	4611      	mov	r1, r2
  408404:	461a      	mov	r2, r3
  408406:	6025      	str	r5, [r4, #0]
  408408:	f7f8 fece 	bl	4011a8 <_write>
  40840c:	1c43      	adds	r3, r0, #1
  40840e:	d000      	beq.n	408412 <_write_r+0x1a>
  408410:	bd70      	pop	{r4, r5, r6, pc}
  408412:	6823      	ldr	r3, [r4, #0]
  408414:	2b00      	cmp	r3, #0
  408416:	d0fb      	beq.n	408410 <_write_r+0x18>
  408418:	6033      	str	r3, [r6, #0]
  40841a:	bd70      	pop	{r4, r5, r6, pc}
  40841c:	20004f1c 	.word	0x20004f1c

00408420 <__register_exitproc>:
  408420:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  408424:	4c25      	ldr	r4, [pc, #148]	; (4084bc <__register_exitproc+0x9c>)
  408426:	6825      	ldr	r5, [r4, #0]
  408428:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
  40842c:	4606      	mov	r6, r0
  40842e:	4688      	mov	r8, r1
  408430:	4692      	mov	sl, r2
  408432:	4699      	mov	r9, r3
  408434:	b3cc      	cbz	r4, 4084aa <__register_exitproc+0x8a>
  408436:	6860      	ldr	r0, [r4, #4]
  408438:	281f      	cmp	r0, #31
  40843a:	dc18      	bgt.n	40846e <__register_exitproc+0x4e>
  40843c:	1c43      	adds	r3, r0, #1
  40843e:	b17e      	cbz	r6, 408460 <__register_exitproc+0x40>
  408440:	eb04 0580 	add.w	r5, r4, r0, lsl #2
  408444:	2101      	movs	r1, #1
  408446:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
  40844a:	f8d4 7188 	ldr.w	r7, [r4, #392]	; 0x188
  40844e:	fa01 f200 	lsl.w	r2, r1, r0
  408452:	4317      	orrs	r7, r2
  408454:	2e02      	cmp	r6, #2
  408456:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
  40845a:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
  40845e:	d01e      	beq.n	40849e <__register_exitproc+0x7e>
  408460:	3002      	adds	r0, #2
  408462:	6063      	str	r3, [r4, #4]
  408464:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
  408468:	2000      	movs	r0, #0
  40846a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40846e:	4b14      	ldr	r3, [pc, #80]	; (4084c0 <__register_exitproc+0xa0>)
  408470:	b303      	cbz	r3, 4084b4 <__register_exitproc+0x94>
  408472:	f44f 70c8 	mov.w	r0, #400	; 0x190
  408476:	f7fe fe87 	bl	407188 <malloc>
  40847a:	4604      	mov	r4, r0
  40847c:	b1d0      	cbz	r0, 4084b4 <__register_exitproc+0x94>
  40847e:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
  408482:	2700      	movs	r7, #0
  408484:	e880 0088 	stmia.w	r0, {r3, r7}
  408488:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  40848c:	4638      	mov	r0, r7
  40848e:	2301      	movs	r3, #1
  408490:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
  408494:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
  408498:	2e00      	cmp	r6, #0
  40849a:	d0e1      	beq.n	408460 <__register_exitproc+0x40>
  40849c:	e7d0      	b.n	408440 <__register_exitproc+0x20>
  40849e:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
  4084a2:	430a      	orrs	r2, r1
  4084a4:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  4084a8:	e7da      	b.n	408460 <__register_exitproc+0x40>
  4084aa:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
  4084ae:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  4084b2:	e7c0      	b.n	408436 <__register_exitproc+0x16>
  4084b4:	f04f 30ff 	mov.w	r0, #4294967295
  4084b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4084bc:	00409fb0 	.word	0x00409fb0
  4084c0:	00407189 	.word	0x00407189

004084c4 <_calloc_r>:
  4084c4:	b510      	push	{r4, lr}
  4084c6:	fb02 f101 	mul.w	r1, r2, r1
  4084ca:	f7fe fe65 	bl	407198 <_malloc_r>
  4084ce:	4604      	mov	r4, r0
  4084d0:	b168      	cbz	r0, 4084ee <_calloc_r+0x2a>
  4084d2:	f850 2c04 	ldr.w	r2, [r0, #-4]
  4084d6:	f022 0203 	bic.w	r2, r2, #3
  4084da:	3a04      	subs	r2, #4
  4084dc:	2a24      	cmp	r2, #36	; 0x24
  4084de:	d818      	bhi.n	408512 <_calloc_r+0x4e>
  4084e0:	2a13      	cmp	r2, #19
  4084e2:	d806      	bhi.n	4084f2 <_calloc_r+0x2e>
  4084e4:	4603      	mov	r3, r0
  4084e6:	2200      	movs	r2, #0
  4084e8:	601a      	str	r2, [r3, #0]
  4084ea:	605a      	str	r2, [r3, #4]
  4084ec:	609a      	str	r2, [r3, #8]
  4084ee:	4620      	mov	r0, r4
  4084f0:	bd10      	pop	{r4, pc}
  4084f2:	2300      	movs	r3, #0
  4084f4:	2a1b      	cmp	r2, #27
  4084f6:	6003      	str	r3, [r0, #0]
  4084f8:	6043      	str	r3, [r0, #4]
  4084fa:	d90f      	bls.n	40851c <_calloc_r+0x58>
  4084fc:	2a24      	cmp	r2, #36	; 0x24
  4084fe:	6083      	str	r3, [r0, #8]
  408500:	60c3      	str	r3, [r0, #12]
  408502:	bf05      	ittet	eq
  408504:	6103      	streq	r3, [r0, #16]
  408506:	6143      	streq	r3, [r0, #20]
  408508:	f100 0310 	addne.w	r3, r0, #16
  40850c:	f100 0318 	addeq.w	r3, r0, #24
  408510:	e7e9      	b.n	4084e6 <_calloc_r+0x22>
  408512:	2100      	movs	r1, #0
  408514:	f7fb fe5e 	bl	4041d4 <memset>
  408518:	4620      	mov	r0, r4
  40851a:	bd10      	pop	{r4, pc}
  40851c:	f100 0308 	add.w	r3, r0, #8
  408520:	e7e1      	b.n	4084e6 <_calloc_r+0x22>
  408522:	bf00      	nop

00408524 <_close_r>:
  408524:	b538      	push	{r3, r4, r5, lr}
  408526:	4c07      	ldr	r4, [pc, #28]	; (408544 <_close_r+0x20>)
  408528:	2300      	movs	r3, #0
  40852a:	4605      	mov	r5, r0
  40852c:	4608      	mov	r0, r1
  40852e:	6023      	str	r3, [r4, #0]
  408530:	f7f9 fa48 	bl	4019c4 <_close>
  408534:	1c43      	adds	r3, r0, #1
  408536:	d000      	beq.n	40853a <_close_r+0x16>
  408538:	bd38      	pop	{r3, r4, r5, pc}
  40853a:	6823      	ldr	r3, [r4, #0]
  40853c:	2b00      	cmp	r3, #0
  40853e:	d0fb      	beq.n	408538 <_close_r+0x14>
  408540:	602b      	str	r3, [r5, #0]
  408542:	bd38      	pop	{r3, r4, r5, pc}
  408544:	20004f1c 	.word	0x20004f1c

00408548 <_fclose_r>:
  408548:	2900      	cmp	r1, #0
  40854a:	d03d      	beq.n	4085c8 <_fclose_r+0x80>
  40854c:	b570      	push	{r4, r5, r6, lr}
  40854e:	4605      	mov	r5, r0
  408550:	460c      	mov	r4, r1
  408552:	b108      	cbz	r0, 408558 <_fclose_r+0x10>
  408554:	6b83      	ldr	r3, [r0, #56]	; 0x38
  408556:	b37b      	cbz	r3, 4085b8 <_fclose_r+0x70>
  408558:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40855c:	b90b      	cbnz	r3, 408562 <_fclose_r+0x1a>
  40855e:	2000      	movs	r0, #0
  408560:	bd70      	pop	{r4, r5, r6, pc}
  408562:	4628      	mov	r0, r5
  408564:	4621      	mov	r1, r4
  408566:	f7fe fb5d 	bl	406c24 <__sflush_r>
  40856a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  40856c:	4606      	mov	r6, r0
  40856e:	b133      	cbz	r3, 40857e <_fclose_r+0x36>
  408570:	4628      	mov	r0, r5
  408572:	69e1      	ldr	r1, [r4, #28]
  408574:	4798      	blx	r3
  408576:	2800      	cmp	r0, #0
  408578:	bfb8      	it	lt
  40857a:	f04f 36ff 	movlt.w	r6, #4294967295
  40857e:	89a3      	ldrh	r3, [r4, #12]
  408580:	061b      	lsls	r3, r3, #24
  408582:	d41c      	bmi.n	4085be <_fclose_r+0x76>
  408584:	6b21      	ldr	r1, [r4, #48]	; 0x30
  408586:	b141      	cbz	r1, 40859a <_fclose_r+0x52>
  408588:	f104 0340 	add.w	r3, r4, #64	; 0x40
  40858c:	4299      	cmp	r1, r3
  40858e:	d002      	beq.n	408596 <_fclose_r+0x4e>
  408590:	4628      	mov	r0, r5
  408592:	f7fe fcf3 	bl	406f7c <_free_r>
  408596:	2300      	movs	r3, #0
  408598:	6323      	str	r3, [r4, #48]	; 0x30
  40859a:	6c61      	ldr	r1, [r4, #68]	; 0x44
  40859c:	b121      	cbz	r1, 4085a8 <_fclose_r+0x60>
  40859e:	4628      	mov	r0, r5
  4085a0:	f7fe fcec 	bl	406f7c <_free_r>
  4085a4:	2300      	movs	r3, #0
  4085a6:	6463      	str	r3, [r4, #68]	; 0x44
  4085a8:	f7fe fc80 	bl	406eac <__sfp_lock_acquire>
  4085ac:	2300      	movs	r3, #0
  4085ae:	81a3      	strh	r3, [r4, #12]
  4085b0:	f7fe fc7e 	bl	406eb0 <__sfp_lock_release>
  4085b4:	4630      	mov	r0, r6
  4085b6:	bd70      	pop	{r4, r5, r6, pc}
  4085b8:	f7fe fc72 	bl	406ea0 <__sinit>
  4085bc:	e7cc      	b.n	408558 <_fclose_r+0x10>
  4085be:	4628      	mov	r0, r5
  4085c0:	6921      	ldr	r1, [r4, #16]
  4085c2:	f7fe fcdb 	bl	406f7c <_free_r>
  4085c6:	e7dd      	b.n	408584 <_fclose_r+0x3c>
  4085c8:	2000      	movs	r0, #0
  4085ca:	4770      	bx	lr

004085cc <_lseek_r>:
  4085cc:	b570      	push	{r4, r5, r6, lr}
  4085ce:	4c08      	ldr	r4, [pc, #32]	; (4085f0 <_lseek_r+0x24>)
  4085d0:	4606      	mov	r6, r0
  4085d2:	2500      	movs	r5, #0
  4085d4:	4608      	mov	r0, r1
  4085d6:	4611      	mov	r1, r2
  4085d8:	461a      	mov	r2, r3
  4085da:	6025      	str	r5, [r4, #0]
  4085dc:	f7f9 f9f6 	bl	4019cc <_lseek>
  4085e0:	1c43      	adds	r3, r0, #1
  4085e2:	d000      	beq.n	4085e6 <_lseek_r+0x1a>
  4085e4:	bd70      	pop	{r4, r5, r6, pc}
  4085e6:	6823      	ldr	r3, [r4, #0]
  4085e8:	2b00      	cmp	r3, #0
  4085ea:	d0fb      	beq.n	4085e4 <_lseek_r+0x18>
  4085ec:	6033      	str	r3, [r6, #0]
  4085ee:	bd70      	pop	{r4, r5, r6, pc}
  4085f0:	20004f1c 	.word	0x20004f1c

004085f4 <_read_r>:
  4085f4:	b570      	push	{r4, r5, r6, lr}
  4085f6:	4c08      	ldr	r4, [pc, #32]	; (408618 <_read_r+0x24>)
  4085f8:	4606      	mov	r6, r0
  4085fa:	2500      	movs	r5, #0
  4085fc:	4608      	mov	r0, r1
  4085fe:	4611      	mov	r1, r2
  408600:	461a      	mov	r2, r3
  408602:	6025      	str	r5, [r4, #0]
  408604:	f7f8 fdb2 	bl	40116c <_read>
  408608:	1c43      	adds	r3, r0, #1
  40860a:	d000      	beq.n	40860e <_read_r+0x1a>
  40860c:	bd70      	pop	{r4, r5, r6, pc}
  40860e:	6823      	ldr	r3, [r4, #0]
  408610:	2b00      	cmp	r3, #0
  408612:	d0fb      	beq.n	40860c <_read_r+0x18>
  408614:	6033      	str	r3, [r6, #0]
  408616:	bd70      	pop	{r4, r5, r6, pc}
  408618:	20004f1c 	.word	0x20004f1c

0040861c <__aeabi_drsub>:
  40861c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  408620:	e002      	b.n	408628 <__adddf3>
  408622:	bf00      	nop

00408624 <__aeabi_dsub>:
  408624:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00408628 <__adddf3>:
  408628:	b530      	push	{r4, r5, lr}
  40862a:	ea4f 0441 	mov.w	r4, r1, lsl #1
  40862e:	ea4f 0543 	mov.w	r5, r3, lsl #1
  408632:	ea94 0f05 	teq	r4, r5
  408636:	bf08      	it	eq
  408638:	ea90 0f02 	teqeq	r0, r2
  40863c:	bf1f      	itttt	ne
  40863e:	ea54 0c00 	orrsne.w	ip, r4, r0
  408642:	ea55 0c02 	orrsne.w	ip, r5, r2
  408646:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  40864a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  40864e:	f000 80e2 	beq.w	408816 <__adddf3+0x1ee>
  408652:	ea4f 5454 	mov.w	r4, r4, lsr #21
  408656:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  40865a:	bfb8      	it	lt
  40865c:	426d      	neglt	r5, r5
  40865e:	dd0c      	ble.n	40867a <__adddf3+0x52>
  408660:	442c      	add	r4, r5
  408662:	ea80 0202 	eor.w	r2, r0, r2
  408666:	ea81 0303 	eor.w	r3, r1, r3
  40866a:	ea82 0000 	eor.w	r0, r2, r0
  40866e:	ea83 0101 	eor.w	r1, r3, r1
  408672:	ea80 0202 	eor.w	r2, r0, r2
  408676:	ea81 0303 	eor.w	r3, r1, r3
  40867a:	2d36      	cmp	r5, #54	; 0x36
  40867c:	bf88      	it	hi
  40867e:	bd30      	pophi	{r4, r5, pc}
  408680:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  408684:	ea4f 3101 	mov.w	r1, r1, lsl #12
  408688:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  40868c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  408690:	d002      	beq.n	408698 <__adddf3+0x70>
  408692:	4240      	negs	r0, r0
  408694:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  408698:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  40869c:	ea4f 3303 	mov.w	r3, r3, lsl #12
  4086a0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  4086a4:	d002      	beq.n	4086ac <__adddf3+0x84>
  4086a6:	4252      	negs	r2, r2
  4086a8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4086ac:	ea94 0f05 	teq	r4, r5
  4086b0:	f000 80a7 	beq.w	408802 <__adddf3+0x1da>
  4086b4:	f1a4 0401 	sub.w	r4, r4, #1
  4086b8:	f1d5 0e20 	rsbs	lr, r5, #32
  4086bc:	db0d      	blt.n	4086da <__adddf3+0xb2>
  4086be:	fa02 fc0e 	lsl.w	ip, r2, lr
  4086c2:	fa22 f205 	lsr.w	r2, r2, r5
  4086c6:	1880      	adds	r0, r0, r2
  4086c8:	f141 0100 	adc.w	r1, r1, #0
  4086cc:	fa03 f20e 	lsl.w	r2, r3, lr
  4086d0:	1880      	adds	r0, r0, r2
  4086d2:	fa43 f305 	asr.w	r3, r3, r5
  4086d6:	4159      	adcs	r1, r3
  4086d8:	e00e      	b.n	4086f8 <__adddf3+0xd0>
  4086da:	f1a5 0520 	sub.w	r5, r5, #32
  4086de:	f10e 0e20 	add.w	lr, lr, #32
  4086e2:	2a01      	cmp	r2, #1
  4086e4:	fa03 fc0e 	lsl.w	ip, r3, lr
  4086e8:	bf28      	it	cs
  4086ea:	f04c 0c02 	orrcs.w	ip, ip, #2
  4086ee:	fa43 f305 	asr.w	r3, r3, r5
  4086f2:	18c0      	adds	r0, r0, r3
  4086f4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  4086f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  4086fc:	d507      	bpl.n	40870e <__adddf3+0xe6>
  4086fe:	f04f 0e00 	mov.w	lr, #0
  408702:	f1dc 0c00 	rsbs	ip, ip, #0
  408706:	eb7e 0000 	sbcs.w	r0, lr, r0
  40870a:	eb6e 0101 	sbc.w	r1, lr, r1
  40870e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  408712:	d31b      	bcc.n	40874c <__adddf3+0x124>
  408714:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  408718:	d30c      	bcc.n	408734 <__adddf3+0x10c>
  40871a:	0849      	lsrs	r1, r1, #1
  40871c:	ea5f 0030 	movs.w	r0, r0, rrx
  408720:	ea4f 0c3c 	mov.w	ip, ip, rrx
  408724:	f104 0401 	add.w	r4, r4, #1
  408728:	ea4f 5244 	mov.w	r2, r4, lsl #21
  40872c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  408730:	f080 809a 	bcs.w	408868 <__adddf3+0x240>
  408734:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  408738:	bf08      	it	eq
  40873a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  40873e:	f150 0000 	adcs.w	r0, r0, #0
  408742:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  408746:	ea41 0105 	orr.w	r1, r1, r5
  40874a:	bd30      	pop	{r4, r5, pc}
  40874c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  408750:	4140      	adcs	r0, r0
  408752:	eb41 0101 	adc.w	r1, r1, r1
  408756:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40875a:	f1a4 0401 	sub.w	r4, r4, #1
  40875e:	d1e9      	bne.n	408734 <__adddf3+0x10c>
  408760:	f091 0f00 	teq	r1, #0
  408764:	bf04      	itt	eq
  408766:	4601      	moveq	r1, r0
  408768:	2000      	moveq	r0, #0
  40876a:	fab1 f381 	clz	r3, r1
  40876e:	bf08      	it	eq
  408770:	3320      	addeq	r3, #32
  408772:	f1a3 030b 	sub.w	r3, r3, #11
  408776:	f1b3 0220 	subs.w	r2, r3, #32
  40877a:	da0c      	bge.n	408796 <__adddf3+0x16e>
  40877c:	320c      	adds	r2, #12
  40877e:	dd08      	ble.n	408792 <__adddf3+0x16a>
  408780:	f102 0c14 	add.w	ip, r2, #20
  408784:	f1c2 020c 	rsb	r2, r2, #12
  408788:	fa01 f00c 	lsl.w	r0, r1, ip
  40878c:	fa21 f102 	lsr.w	r1, r1, r2
  408790:	e00c      	b.n	4087ac <__adddf3+0x184>
  408792:	f102 0214 	add.w	r2, r2, #20
  408796:	bfd8      	it	le
  408798:	f1c2 0c20 	rsble	ip, r2, #32
  40879c:	fa01 f102 	lsl.w	r1, r1, r2
  4087a0:	fa20 fc0c 	lsr.w	ip, r0, ip
  4087a4:	bfdc      	itt	le
  4087a6:	ea41 010c 	orrle.w	r1, r1, ip
  4087aa:	4090      	lslle	r0, r2
  4087ac:	1ae4      	subs	r4, r4, r3
  4087ae:	bfa2      	ittt	ge
  4087b0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  4087b4:	4329      	orrge	r1, r5
  4087b6:	bd30      	popge	{r4, r5, pc}
  4087b8:	ea6f 0404 	mvn.w	r4, r4
  4087bc:	3c1f      	subs	r4, #31
  4087be:	da1c      	bge.n	4087fa <__adddf3+0x1d2>
  4087c0:	340c      	adds	r4, #12
  4087c2:	dc0e      	bgt.n	4087e2 <__adddf3+0x1ba>
  4087c4:	f104 0414 	add.w	r4, r4, #20
  4087c8:	f1c4 0220 	rsb	r2, r4, #32
  4087cc:	fa20 f004 	lsr.w	r0, r0, r4
  4087d0:	fa01 f302 	lsl.w	r3, r1, r2
  4087d4:	ea40 0003 	orr.w	r0, r0, r3
  4087d8:	fa21 f304 	lsr.w	r3, r1, r4
  4087dc:	ea45 0103 	orr.w	r1, r5, r3
  4087e0:	bd30      	pop	{r4, r5, pc}
  4087e2:	f1c4 040c 	rsb	r4, r4, #12
  4087e6:	f1c4 0220 	rsb	r2, r4, #32
  4087ea:	fa20 f002 	lsr.w	r0, r0, r2
  4087ee:	fa01 f304 	lsl.w	r3, r1, r4
  4087f2:	ea40 0003 	orr.w	r0, r0, r3
  4087f6:	4629      	mov	r1, r5
  4087f8:	bd30      	pop	{r4, r5, pc}
  4087fa:	fa21 f004 	lsr.w	r0, r1, r4
  4087fe:	4629      	mov	r1, r5
  408800:	bd30      	pop	{r4, r5, pc}
  408802:	f094 0f00 	teq	r4, #0
  408806:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  40880a:	bf06      	itte	eq
  40880c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  408810:	3401      	addeq	r4, #1
  408812:	3d01      	subne	r5, #1
  408814:	e74e      	b.n	4086b4 <__adddf3+0x8c>
  408816:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  40881a:	bf18      	it	ne
  40881c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  408820:	d029      	beq.n	408876 <__adddf3+0x24e>
  408822:	ea94 0f05 	teq	r4, r5
  408826:	bf08      	it	eq
  408828:	ea90 0f02 	teqeq	r0, r2
  40882c:	d005      	beq.n	40883a <__adddf3+0x212>
  40882e:	ea54 0c00 	orrs.w	ip, r4, r0
  408832:	bf04      	itt	eq
  408834:	4619      	moveq	r1, r3
  408836:	4610      	moveq	r0, r2
  408838:	bd30      	pop	{r4, r5, pc}
  40883a:	ea91 0f03 	teq	r1, r3
  40883e:	bf1e      	ittt	ne
  408840:	2100      	movne	r1, #0
  408842:	2000      	movne	r0, #0
  408844:	bd30      	popne	{r4, r5, pc}
  408846:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  40884a:	d105      	bne.n	408858 <__adddf3+0x230>
  40884c:	0040      	lsls	r0, r0, #1
  40884e:	4149      	adcs	r1, r1
  408850:	bf28      	it	cs
  408852:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  408856:	bd30      	pop	{r4, r5, pc}
  408858:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  40885c:	bf3c      	itt	cc
  40885e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  408862:	bd30      	popcc	{r4, r5, pc}
  408864:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  408868:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  40886c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  408870:	f04f 0000 	mov.w	r0, #0
  408874:	bd30      	pop	{r4, r5, pc}
  408876:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  40887a:	bf1a      	itte	ne
  40887c:	4619      	movne	r1, r3
  40887e:	4610      	movne	r0, r2
  408880:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  408884:	bf1c      	itt	ne
  408886:	460b      	movne	r3, r1
  408888:	4602      	movne	r2, r0
  40888a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  40888e:	bf06      	itte	eq
  408890:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  408894:	ea91 0f03 	teqeq	r1, r3
  408898:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  40889c:	bd30      	pop	{r4, r5, pc}
  40889e:	bf00      	nop

004088a0 <__aeabi_ui2d>:
  4088a0:	f090 0f00 	teq	r0, #0
  4088a4:	bf04      	itt	eq
  4088a6:	2100      	moveq	r1, #0
  4088a8:	4770      	bxeq	lr
  4088aa:	b530      	push	{r4, r5, lr}
  4088ac:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4088b0:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4088b4:	f04f 0500 	mov.w	r5, #0
  4088b8:	f04f 0100 	mov.w	r1, #0
  4088bc:	e750      	b.n	408760 <__adddf3+0x138>
  4088be:	bf00      	nop

004088c0 <__aeabi_i2d>:
  4088c0:	f090 0f00 	teq	r0, #0
  4088c4:	bf04      	itt	eq
  4088c6:	2100      	moveq	r1, #0
  4088c8:	4770      	bxeq	lr
  4088ca:	b530      	push	{r4, r5, lr}
  4088cc:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4088d0:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4088d4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  4088d8:	bf48      	it	mi
  4088da:	4240      	negmi	r0, r0
  4088dc:	f04f 0100 	mov.w	r1, #0
  4088e0:	e73e      	b.n	408760 <__adddf3+0x138>
  4088e2:	bf00      	nop

004088e4 <__aeabi_f2d>:
  4088e4:	0042      	lsls	r2, r0, #1
  4088e6:	ea4f 01e2 	mov.w	r1, r2, asr #3
  4088ea:	ea4f 0131 	mov.w	r1, r1, rrx
  4088ee:	ea4f 7002 	mov.w	r0, r2, lsl #28
  4088f2:	bf1f      	itttt	ne
  4088f4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  4088f8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  4088fc:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  408900:	4770      	bxne	lr
  408902:	f092 0f00 	teq	r2, #0
  408906:	bf14      	ite	ne
  408908:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  40890c:	4770      	bxeq	lr
  40890e:	b530      	push	{r4, r5, lr}
  408910:	f44f 7460 	mov.w	r4, #896	; 0x380
  408914:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  408918:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  40891c:	e720      	b.n	408760 <__adddf3+0x138>
  40891e:	bf00      	nop

00408920 <__aeabi_ul2d>:
  408920:	ea50 0201 	orrs.w	r2, r0, r1
  408924:	bf08      	it	eq
  408926:	4770      	bxeq	lr
  408928:	b530      	push	{r4, r5, lr}
  40892a:	f04f 0500 	mov.w	r5, #0
  40892e:	e00a      	b.n	408946 <__aeabi_l2d+0x16>

00408930 <__aeabi_l2d>:
  408930:	ea50 0201 	orrs.w	r2, r0, r1
  408934:	bf08      	it	eq
  408936:	4770      	bxeq	lr
  408938:	b530      	push	{r4, r5, lr}
  40893a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  40893e:	d502      	bpl.n	408946 <__aeabi_l2d+0x16>
  408940:	4240      	negs	r0, r0
  408942:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  408946:	f44f 6480 	mov.w	r4, #1024	; 0x400
  40894a:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40894e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  408952:	f43f aedc 	beq.w	40870e <__adddf3+0xe6>
  408956:	f04f 0203 	mov.w	r2, #3
  40895a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  40895e:	bf18      	it	ne
  408960:	3203      	addne	r2, #3
  408962:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  408966:	bf18      	it	ne
  408968:	3203      	addne	r2, #3
  40896a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  40896e:	f1c2 0320 	rsb	r3, r2, #32
  408972:	fa00 fc03 	lsl.w	ip, r0, r3
  408976:	fa20 f002 	lsr.w	r0, r0, r2
  40897a:	fa01 fe03 	lsl.w	lr, r1, r3
  40897e:	ea40 000e 	orr.w	r0, r0, lr
  408982:	fa21 f102 	lsr.w	r1, r1, r2
  408986:	4414      	add	r4, r2
  408988:	e6c1      	b.n	40870e <__adddf3+0xe6>
  40898a:	bf00      	nop

0040898c <__aeabi_dmul>:
  40898c:	b570      	push	{r4, r5, r6, lr}
  40898e:	f04f 0cff 	mov.w	ip, #255	; 0xff
  408992:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  408996:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  40899a:	bf1d      	ittte	ne
  40899c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  4089a0:	ea94 0f0c 	teqne	r4, ip
  4089a4:	ea95 0f0c 	teqne	r5, ip
  4089a8:	f000 f8de 	bleq	408b68 <__aeabi_dmul+0x1dc>
  4089ac:	442c      	add	r4, r5
  4089ae:	ea81 0603 	eor.w	r6, r1, r3
  4089b2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  4089b6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  4089ba:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  4089be:	bf18      	it	ne
  4089c0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  4089c4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4089c8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4089cc:	d038      	beq.n	408a40 <__aeabi_dmul+0xb4>
  4089ce:	fba0 ce02 	umull	ip, lr, r0, r2
  4089d2:	f04f 0500 	mov.w	r5, #0
  4089d6:	fbe1 e502 	umlal	lr, r5, r1, r2
  4089da:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  4089de:	fbe0 e503 	umlal	lr, r5, r0, r3
  4089e2:	f04f 0600 	mov.w	r6, #0
  4089e6:	fbe1 5603 	umlal	r5, r6, r1, r3
  4089ea:	f09c 0f00 	teq	ip, #0
  4089ee:	bf18      	it	ne
  4089f0:	f04e 0e01 	orrne.w	lr, lr, #1
  4089f4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  4089f8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  4089fc:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  408a00:	d204      	bcs.n	408a0c <__aeabi_dmul+0x80>
  408a02:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  408a06:	416d      	adcs	r5, r5
  408a08:	eb46 0606 	adc.w	r6, r6, r6
  408a0c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  408a10:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  408a14:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  408a18:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  408a1c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  408a20:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  408a24:	bf88      	it	hi
  408a26:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  408a2a:	d81e      	bhi.n	408a6a <__aeabi_dmul+0xde>
  408a2c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  408a30:	bf08      	it	eq
  408a32:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  408a36:	f150 0000 	adcs.w	r0, r0, #0
  408a3a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  408a3e:	bd70      	pop	{r4, r5, r6, pc}
  408a40:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  408a44:	ea46 0101 	orr.w	r1, r6, r1
  408a48:	ea40 0002 	orr.w	r0, r0, r2
  408a4c:	ea81 0103 	eor.w	r1, r1, r3
  408a50:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  408a54:	bfc2      	ittt	gt
  408a56:	ebd4 050c 	rsbsgt	r5, r4, ip
  408a5a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  408a5e:	bd70      	popgt	{r4, r5, r6, pc}
  408a60:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  408a64:	f04f 0e00 	mov.w	lr, #0
  408a68:	3c01      	subs	r4, #1
  408a6a:	f300 80ab 	bgt.w	408bc4 <__aeabi_dmul+0x238>
  408a6e:	f114 0f36 	cmn.w	r4, #54	; 0x36
  408a72:	bfde      	ittt	le
  408a74:	2000      	movle	r0, #0
  408a76:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  408a7a:	bd70      	pople	{r4, r5, r6, pc}
  408a7c:	f1c4 0400 	rsb	r4, r4, #0
  408a80:	3c20      	subs	r4, #32
  408a82:	da35      	bge.n	408af0 <__aeabi_dmul+0x164>
  408a84:	340c      	adds	r4, #12
  408a86:	dc1b      	bgt.n	408ac0 <__aeabi_dmul+0x134>
  408a88:	f104 0414 	add.w	r4, r4, #20
  408a8c:	f1c4 0520 	rsb	r5, r4, #32
  408a90:	fa00 f305 	lsl.w	r3, r0, r5
  408a94:	fa20 f004 	lsr.w	r0, r0, r4
  408a98:	fa01 f205 	lsl.w	r2, r1, r5
  408a9c:	ea40 0002 	orr.w	r0, r0, r2
  408aa0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  408aa4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  408aa8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  408aac:	fa21 f604 	lsr.w	r6, r1, r4
  408ab0:	eb42 0106 	adc.w	r1, r2, r6
  408ab4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  408ab8:	bf08      	it	eq
  408aba:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  408abe:	bd70      	pop	{r4, r5, r6, pc}
  408ac0:	f1c4 040c 	rsb	r4, r4, #12
  408ac4:	f1c4 0520 	rsb	r5, r4, #32
  408ac8:	fa00 f304 	lsl.w	r3, r0, r4
  408acc:	fa20 f005 	lsr.w	r0, r0, r5
  408ad0:	fa01 f204 	lsl.w	r2, r1, r4
  408ad4:	ea40 0002 	orr.w	r0, r0, r2
  408ad8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  408adc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  408ae0:	f141 0100 	adc.w	r1, r1, #0
  408ae4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  408ae8:	bf08      	it	eq
  408aea:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  408aee:	bd70      	pop	{r4, r5, r6, pc}
  408af0:	f1c4 0520 	rsb	r5, r4, #32
  408af4:	fa00 f205 	lsl.w	r2, r0, r5
  408af8:	ea4e 0e02 	orr.w	lr, lr, r2
  408afc:	fa20 f304 	lsr.w	r3, r0, r4
  408b00:	fa01 f205 	lsl.w	r2, r1, r5
  408b04:	ea43 0302 	orr.w	r3, r3, r2
  408b08:	fa21 f004 	lsr.w	r0, r1, r4
  408b0c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  408b10:	fa21 f204 	lsr.w	r2, r1, r4
  408b14:	ea20 0002 	bic.w	r0, r0, r2
  408b18:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  408b1c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  408b20:	bf08      	it	eq
  408b22:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  408b26:	bd70      	pop	{r4, r5, r6, pc}
  408b28:	f094 0f00 	teq	r4, #0
  408b2c:	d10f      	bne.n	408b4e <__aeabi_dmul+0x1c2>
  408b2e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  408b32:	0040      	lsls	r0, r0, #1
  408b34:	eb41 0101 	adc.w	r1, r1, r1
  408b38:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  408b3c:	bf08      	it	eq
  408b3e:	3c01      	subeq	r4, #1
  408b40:	d0f7      	beq.n	408b32 <__aeabi_dmul+0x1a6>
  408b42:	ea41 0106 	orr.w	r1, r1, r6
  408b46:	f095 0f00 	teq	r5, #0
  408b4a:	bf18      	it	ne
  408b4c:	4770      	bxne	lr
  408b4e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  408b52:	0052      	lsls	r2, r2, #1
  408b54:	eb43 0303 	adc.w	r3, r3, r3
  408b58:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  408b5c:	bf08      	it	eq
  408b5e:	3d01      	subeq	r5, #1
  408b60:	d0f7      	beq.n	408b52 <__aeabi_dmul+0x1c6>
  408b62:	ea43 0306 	orr.w	r3, r3, r6
  408b66:	4770      	bx	lr
  408b68:	ea94 0f0c 	teq	r4, ip
  408b6c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  408b70:	bf18      	it	ne
  408b72:	ea95 0f0c 	teqne	r5, ip
  408b76:	d00c      	beq.n	408b92 <__aeabi_dmul+0x206>
  408b78:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  408b7c:	bf18      	it	ne
  408b7e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  408b82:	d1d1      	bne.n	408b28 <__aeabi_dmul+0x19c>
  408b84:	ea81 0103 	eor.w	r1, r1, r3
  408b88:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  408b8c:	f04f 0000 	mov.w	r0, #0
  408b90:	bd70      	pop	{r4, r5, r6, pc}
  408b92:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  408b96:	bf06      	itte	eq
  408b98:	4610      	moveq	r0, r2
  408b9a:	4619      	moveq	r1, r3
  408b9c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  408ba0:	d019      	beq.n	408bd6 <__aeabi_dmul+0x24a>
  408ba2:	ea94 0f0c 	teq	r4, ip
  408ba6:	d102      	bne.n	408bae <__aeabi_dmul+0x222>
  408ba8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  408bac:	d113      	bne.n	408bd6 <__aeabi_dmul+0x24a>
  408bae:	ea95 0f0c 	teq	r5, ip
  408bb2:	d105      	bne.n	408bc0 <__aeabi_dmul+0x234>
  408bb4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  408bb8:	bf1c      	itt	ne
  408bba:	4610      	movne	r0, r2
  408bbc:	4619      	movne	r1, r3
  408bbe:	d10a      	bne.n	408bd6 <__aeabi_dmul+0x24a>
  408bc0:	ea81 0103 	eor.w	r1, r1, r3
  408bc4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  408bc8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  408bcc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  408bd0:	f04f 0000 	mov.w	r0, #0
  408bd4:	bd70      	pop	{r4, r5, r6, pc}
  408bd6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  408bda:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  408bde:	bd70      	pop	{r4, r5, r6, pc}

00408be0 <__aeabi_ddiv>:
  408be0:	b570      	push	{r4, r5, r6, lr}
  408be2:	f04f 0cff 	mov.w	ip, #255	; 0xff
  408be6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  408bea:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  408bee:	bf1d      	ittte	ne
  408bf0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  408bf4:	ea94 0f0c 	teqne	r4, ip
  408bf8:	ea95 0f0c 	teqne	r5, ip
  408bfc:	f000 f8a7 	bleq	408d4e <__aeabi_ddiv+0x16e>
  408c00:	eba4 0405 	sub.w	r4, r4, r5
  408c04:	ea81 0e03 	eor.w	lr, r1, r3
  408c08:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  408c0c:	ea4f 3101 	mov.w	r1, r1, lsl #12
  408c10:	f000 8088 	beq.w	408d24 <__aeabi_ddiv+0x144>
  408c14:	ea4f 3303 	mov.w	r3, r3, lsl #12
  408c18:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  408c1c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  408c20:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  408c24:	ea4f 2202 	mov.w	r2, r2, lsl #8
  408c28:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  408c2c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  408c30:	ea4f 2600 	mov.w	r6, r0, lsl #8
  408c34:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  408c38:	429d      	cmp	r5, r3
  408c3a:	bf08      	it	eq
  408c3c:	4296      	cmpeq	r6, r2
  408c3e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  408c42:	f504 7440 	add.w	r4, r4, #768	; 0x300
  408c46:	d202      	bcs.n	408c4e <__aeabi_ddiv+0x6e>
  408c48:	085b      	lsrs	r3, r3, #1
  408c4a:	ea4f 0232 	mov.w	r2, r2, rrx
  408c4e:	1ab6      	subs	r6, r6, r2
  408c50:	eb65 0503 	sbc.w	r5, r5, r3
  408c54:	085b      	lsrs	r3, r3, #1
  408c56:	ea4f 0232 	mov.w	r2, r2, rrx
  408c5a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  408c5e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  408c62:	ebb6 0e02 	subs.w	lr, r6, r2
  408c66:	eb75 0e03 	sbcs.w	lr, r5, r3
  408c6a:	bf22      	ittt	cs
  408c6c:	1ab6      	subcs	r6, r6, r2
  408c6e:	4675      	movcs	r5, lr
  408c70:	ea40 000c 	orrcs.w	r0, r0, ip
  408c74:	085b      	lsrs	r3, r3, #1
  408c76:	ea4f 0232 	mov.w	r2, r2, rrx
  408c7a:	ebb6 0e02 	subs.w	lr, r6, r2
  408c7e:	eb75 0e03 	sbcs.w	lr, r5, r3
  408c82:	bf22      	ittt	cs
  408c84:	1ab6      	subcs	r6, r6, r2
  408c86:	4675      	movcs	r5, lr
  408c88:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  408c8c:	085b      	lsrs	r3, r3, #1
  408c8e:	ea4f 0232 	mov.w	r2, r2, rrx
  408c92:	ebb6 0e02 	subs.w	lr, r6, r2
  408c96:	eb75 0e03 	sbcs.w	lr, r5, r3
  408c9a:	bf22      	ittt	cs
  408c9c:	1ab6      	subcs	r6, r6, r2
  408c9e:	4675      	movcs	r5, lr
  408ca0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  408ca4:	085b      	lsrs	r3, r3, #1
  408ca6:	ea4f 0232 	mov.w	r2, r2, rrx
  408caa:	ebb6 0e02 	subs.w	lr, r6, r2
  408cae:	eb75 0e03 	sbcs.w	lr, r5, r3
  408cb2:	bf22      	ittt	cs
  408cb4:	1ab6      	subcs	r6, r6, r2
  408cb6:	4675      	movcs	r5, lr
  408cb8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  408cbc:	ea55 0e06 	orrs.w	lr, r5, r6
  408cc0:	d018      	beq.n	408cf4 <__aeabi_ddiv+0x114>
  408cc2:	ea4f 1505 	mov.w	r5, r5, lsl #4
  408cc6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  408cca:	ea4f 1606 	mov.w	r6, r6, lsl #4
  408cce:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  408cd2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  408cd6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  408cda:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  408cde:	d1c0      	bne.n	408c62 <__aeabi_ddiv+0x82>
  408ce0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  408ce4:	d10b      	bne.n	408cfe <__aeabi_ddiv+0x11e>
  408ce6:	ea41 0100 	orr.w	r1, r1, r0
  408cea:	f04f 0000 	mov.w	r0, #0
  408cee:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  408cf2:	e7b6      	b.n	408c62 <__aeabi_ddiv+0x82>
  408cf4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  408cf8:	bf04      	itt	eq
  408cfa:	4301      	orreq	r1, r0
  408cfc:	2000      	moveq	r0, #0
  408cfe:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  408d02:	bf88      	it	hi
  408d04:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  408d08:	f63f aeaf 	bhi.w	408a6a <__aeabi_dmul+0xde>
  408d0c:	ebb5 0c03 	subs.w	ip, r5, r3
  408d10:	bf04      	itt	eq
  408d12:	ebb6 0c02 	subseq.w	ip, r6, r2
  408d16:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  408d1a:	f150 0000 	adcs.w	r0, r0, #0
  408d1e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  408d22:	bd70      	pop	{r4, r5, r6, pc}
  408d24:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  408d28:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  408d2c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  408d30:	bfc2      	ittt	gt
  408d32:	ebd4 050c 	rsbsgt	r5, r4, ip
  408d36:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  408d3a:	bd70      	popgt	{r4, r5, r6, pc}
  408d3c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  408d40:	f04f 0e00 	mov.w	lr, #0
  408d44:	3c01      	subs	r4, #1
  408d46:	e690      	b.n	408a6a <__aeabi_dmul+0xde>
  408d48:	ea45 0e06 	orr.w	lr, r5, r6
  408d4c:	e68d      	b.n	408a6a <__aeabi_dmul+0xde>
  408d4e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  408d52:	ea94 0f0c 	teq	r4, ip
  408d56:	bf08      	it	eq
  408d58:	ea95 0f0c 	teqeq	r5, ip
  408d5c:	f43f af3b 	beq.w	408bd6 <__aeabi_dmul+0x24a>
  408d60:	ea94 0f0c 	teq	r4, ip
  408d64:	d10a      	bne.n	408d7c <__aeabi_ddiv+0x19c>
  408d66:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  408d6a:	f47f af34 	bne.w	408bd6 <__aeabi_dmul+0x24a>
  408d6e:	ea95 0f0c 	teq	r5, ip
  408d72:	f47f af25 	bne.w	408bc0 <__aeabi_dmul+0x234>
  408d76:	4610      	mov	r0, r2
  408d78:	4619      	mov	r1, r3
  408d7a:	e72c      	b.n	408bd6 <__aeabi_dmul+0x24a>
  408d7c:	ea95 0f0c 	teq	r5, ip
  408d80:	d106      	bne.n	408d90 <__aeabi_ddiv+0x1b0>
  408d82:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  408d86:	f43f aefd 	beq.w	408b84 <__aeabi_dmul+0x1f8>
  408d8a:	4610      	mov	r0, r2
  408d8c:	4619      	mov	r1, r3
  408d8e:	e722      	b.n	408bd6 <__aeabi_dmul+0x24a>
  408d90:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  408d94:	bf18      	it	ne
  408d96:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  408d9a:	f47f aec5 	bne.w	408b28 <__aeabi_dmul+0x19c>
  408d9e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  408da2:	f47f af0d 	bne.w	408bc0 <__aeabi_dmul+0x234>
  408da6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  408daa:	f47f aeeb 	bne.w	408b84 <__aeabi_dmul+0x1f8>
  408dae:	e712      	b.n	408bd6 <__aeabi_dmul+0x24a>

00408db0 <__gedf2>:
  408db0:	f04f 3cff 	mov.w	ip, #4294967295
  408db4:	e006      	b.n	408dc4 <__cmpdf2+0x4>
  408db6:	bf00      	nop

00408db8 <__ledf2>:
  408db8:	f04f 0c01 	mov.w	ip, #1
  408dbc:	e002      	b.n	408dc4 <__cmpdf2+0x4>
  408dbe:	bf00      	nop

00408dc0 <__cmpdf2>:
  408dc0:	f04f 0c01 	mov.w	ip, #1
  408dc4:	f84d cd04 	str.w	ip, [sp, #-4]!
  408dc8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  408dcc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  408dd0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  408dd4:	bf18      	it	ne
  408dd6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  408dda:	d01b      	beq.n	408e14 <__cmpdf2+0x54>
  408ddc:	b001      	add	sp, #4
  408dde:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  408de2:	bf0c      	ite	eq
  408de4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  408de8:	ea91 0f03 	teqne	r1, r3
  408dec:	bf02      	ittt	eq
  408dee:	ea90 0f02 	teqeq	r0, r2
  408df2:	2000      	moveq	r0, #0
  408df4:	4770      	bxeq	lr
  408df6:	f110 0f00 	cmn.w	r0, #0
  408dfa:	ea91 0f03 	teq	r1, r3
  408dfe:	bf58      	it	pl
  408e00:	4299      	cmppl	r1, r3
  408e02:	bf08      	it	eq
  408e04:	4290      	cmpeq	r0, r2
  408e06:	bf2c      	ite	cs
  408e08:	17d8      	asrcs	r0, r3, #31
  408e0a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  408e0e:	f040 0001 	orr.w	r0, r0, #1
  408e12:	4770      	bx	lr
  408e14:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  408e18:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  408e1c:	d102      	bne.n	408e24 <__cmpdf2+0x64>
  408e1e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  408e22:	d107      	bne.n	408e34 <__cmpdf2+0x74>
  408e24:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  408e28:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  408e2c:	d1d6      	bne.n	408ddc <__cmpdf2+0x1c>
  408e2e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  408e32:	d0d3      	beq.n	408ddc <__cmpdf2+0x1c>
  408e34:	f85d 0b04 	ldr.w	r0, [sp], #4
  408e38:	4770      	bx	lr
  408e3a:	bf00      	nop

00408e3c <__aeabi_cdrcmple>:
  408e3c:	4684      	mov	ip, r0
  408e3e:	4610      	mov	r0, r2
  408e40:	4662      	mov	r2, ip
  408e42:	468c      	mov	ip, r1
  408e44:	4619      	mov	r1, r3
  408e46:	4663      	mov	r3, ip
  408e48:	e000      	b.n	408e4c <__aeabi_cdcmpeq>
  408e4a:	bf00      	nop

00408e4c <__aeabi_cdcmpeq>:
  408e4c:	b501      	push	{r0, lr}
  408e4e:	f7ff ffb7 	bl	408dc0 <__cmpdf2>
  408e52:	2800      	cmp	r0, #0
  408e54:	bf48      	it	mi
  408e56:	f110 0f00 	cmnmi.w	r0, #0
  408e5a:	bd01      	pop	{r0, pc}

00408e5c <__aeabi_dcmpeq>:
  408e5c:	f84d ed08 	str.w	lr, [sp, #-8]!
  408e60:	f7ff fff4 	bl	408e4c <__aeabi_cdcmpeq>
  408e64:	bf0c      	ite	eq
  408e66:	2001      	moveq	r0, #1
  408e68:	2000      	movne	r0, #0
  408e6a:	f85d fb08 	ldr.w	pc, [sp], #8
  408e6e:	bf00      	nop

00408e70 <__aeabi_dcmplt>:
  408e70:	f84d ed08 	str.w	lr, [sp, #-8]!
  408e74:	f7ff ffea 	bl	408e4c <__aeabi_cdcmpeq>
  408e78:	bf34      	ite	cc
  408e7a:	2001      	movcc	r0, #1
  408e7c:	2000      	movcs	r0, #0
  408e7e:	f85d fb08 	ldr.w	pc, [sp], #8
  408e82:	bf00      	nop

00408e84 <__aeabi_dcmple>:
  408e84:	f84d ed08 	str.w	lr, [sp, #-8]!
  408e88:	f7ff ffe0 	bl	408e4c <__aeabi_cdcmpeq>
  408e8c:	bf94      	ite	ls
  408e8e:	2001      	movls	r0, #1
  408e90:	2000      	movhi	r0, #0
  408e92:	f85d fb08 	ldr.w	pc, [sp], #8
  408e96:	bf00      	nop

00408e98 <__aeabi_dcmpge>:
  408e98:	f84d ed08 	str.w	lr, [sp, #-8]!
  408e9c:	f7ff ffce 	bl	408e3c <__aeabi_cdrcmple>
  408ea0:	bf94      	ite	ls
  408ea2:	2001      	movls	r0, #1
  408ea4:	2000      	movhi	r0, #0
  408ea6:	f85d fb08 	ldr.w	pc, [sp], #8
  408eaa:	bf00      	nop

00408eac <__aeabi_dcmpgt>:
  408eac:	f84d ed08 	str.w	lr, [sp, #-8]!
  408eb0:	f7ff ffc4 	bl	408e3c <__aeabi_cdrcmple>
  408eb4:	bf34      	ite	cc
  408eb6:	2001      	movcc	r0, #1
  408eb8:	2000      	movcs	r0, #0
  408eba:	f85d fb08 	ldr.w	pc, [sp], #8
  408ebe:	bf00      	nop

00408ec0 <__aeabi_d2iz>:
  408ec0:	ea4f 0241 	mov.w	r2, r1, lsl #1
  408ec4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  408ec8:	d215      	bcs.n	408ef6 <__aeabi_d2iz+0x36>
  408eca:	d511      	bpl.n	408ef0 <__aeabi_d2iz+0x30>
  408ecc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  408ed0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  408ed4:	d912      	bls.n	408efc <__aeabi_d2iz+0x3c>
  408ed6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  408eda:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  408ede:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  408ee2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  408ee6:	fa23 f002 	lsr.w	r0, r3, r2
  408eea:	bf18      	it	ne
  408eec:	4240      	negne	r0, r0
  408eee:	4770      	bx	lr
  408ef0:	f04f 0000 	mov.w	r0, #0
  408ef4:	4770      	bx	lr
  408ef6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  408efa:	d105      	bne.n	408f08 <__aeabi_d2iz+0x48>
  408efc:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  408f00:	bf08      	it	eq
  408f02:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  408f06:	4770      	bx	lr
  408f08:	f04f 0000 	mov.w	r0, #0
  408f0c:	4770      	bx	lr
  408f0e:	bf00      	nop

00408f10 <__aeabi_uldivmod>:
  408f10:	b953      	cbnz	r3, 408f28 <__aeabi_uldivmod+0x18>
  408f12:	b94a      	cbnz	r2, 408f28 <__aeabi_uldivmod+0x18>
  408f14:	2900      	cmp	r1, #0
  408f16:	bf08      	it	eq
  408f18:	2800      	cmpeq	r0, #0
  408f1a:	bf1c      	itt	ne
  408f1c:	f04f 31ff 	movne.w	r1, #4294967295
  408f20:	f04f 30ff 	movne.w	r0, #4294967295
  408f24:	f000 b83c 	b.w	408fa0 <__aeabi_idiv0>
  408f28:	b082      	sub	sp, #8
  408f2a:	46ec      	mov	ip, sp
  408f2c:	e92d 5000 	stmdb	sp!, {ip, lr}
  408f30:	f000 f81e 	bl	408f70 <__gnu_uldivmod_helper>
  408f34:	f8dd e004 	ldr.w	lr, [sp, #4]
  408f38:	b002      	add	sp, #8
  408f3a:	bc0c      	pop	{r2, r3}
  408f3c:	4770      	bx	lr
  408f3e:	bf00      	nop

00408f40 <__gnu_ldivmod_helper>:
  408f40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  408f44:	9c06      	ldr	r4, [sp, #24]
  408f46:	4615      	mov	r5, r2
  408f48:	4606      	mov	r6, r0
  408f4a:	460f      	mov	r7, r1
  408f4c:	4698      	mov	r8, r3
  408f4e:	f000 f829 	bl	408fa4 <__divdi3>
  408f52:	fb05 f301 	mul.w	r3, r5, r1
  408f56:	fb00 3808 	mla	r8, r0, r8, r3
  408f5a:	fba5 2300 	umull	r2, r3, r5, r0
  408f5e:	1ab2      	subs	r2, r6, r2
  408f60:	4443      	add	r3, r8
  408f62:	eb67 0303 	sbc.w	r3, r7, r3
  408f66:	e9c4 2300 	strd	r2, r3, [r4]
  408f6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408f6e:	bf00      	nop

00408f70 <__gnu_uldivmod_helper>:
  408f70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  408f74:	9c06      	ldr	r4, [sp, #24]
  408f76:	4690      	mov	r8, r2
  408f78:	4606      	mov	r6, r0
  408f7a:	460f      	mov	r7, r1
  408f7c:	461d      	mov	r5, r3
  408f7e:	f000 f95f 	bl	409240 <__udivdi3>
  408f82:	fb00 f505 	mul.w	r5, r0, r5
  408f86:	fba0 2308 	umull	r2, r3, r0, r8
  408f8a:	fb08 5501 	mla	r5, r8, r1, r5
  408f8e:	1ab2      	subs	r2, r6, r2
  408f90:	442b      	add	r3, r5
  408f92:	eb67 0303 	sbc.w	r3, r7, r3
  408f96:	e9c4 2300 	strd	r2, r3, [r4]
  408f9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408f9e:	bf00      	nop

00408fa0 <__aeabi_idiv0>:
  408fa0:	4770      	bx	lr
  408fa2:	bf00      	nop

00408fa4 <__divdi3>:
  408fa4:	2900      	cmp	r1, #0
  408fa6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  408faa:	f2c0 80a6 	blt.w	4090fa <__divdi3+0x156>
  408fae:	2600      	movs	r6, #0
  408fb0:	2b00      	cmp	r3, #0
  408fb2:	f2c0 809c 	blt.w	4090ee <__divdi3+0x14a>
  408fb6:	4688      	mov	r8, r1
  408fb8:	4694      	mov	ip, r2
  408fba:	469e      	mov	lr, r3
  408fbc:	4615      	mov	r5, r2
  408fbe:	4604      	mov	r4, r0
  408fc0:	460f      	mov	r7, r1
  408fc2:	2b00      	cmp	r3, #0
  408fc4:	d13d      	bne.n	409042 <__divdi3+0x9e>
  408fc6:	428a      	cmp	r2, r1
  408fc8:	d959      	bls.n	40907e <__divdi3+0xda>
  408fca:	fab2 f382 	clz	r3, r2
  408fce:	b13b      	cbz	r3, 408fe0 <__divdi3+0x3c>
  408fd0:	f1c3 0220 	rsb	r2, r3, #32
  408fd4:	409f      	lsls	r7, r3
  408fd6:	fa20 f202 	lsr.w	r2, r0, r2
  408fda:	409d      	lsls	r5, r3
  408fdc:	4317      	orrs	r7, r2
  408fde:	409c      	lsls	r4, r3
  408fe0:	0c29      	lsrs	r1, r5, #16
  408fe2:	0c22      	lsrs	r2, r4, #16
  408fe4:	fbb7 fef1 	udiv	lr, r7, r1
  408fe8:	b2a8      	uxth	r0, r5
  408fea:	fb01 771e 	mls	r7, r1, lr, r7
  408fee:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
  408ff2:	fb00 f30e 	mul.w	r3, r0, lr
  408ff6:	42bb      	cmp	r3, r7
  408ff8:	d90a      	bls.n	409010 <__divdi3+0x6c>
  408ffa:	197f      	adds	r7, r7, r5
  408ffc:	f10e 32ff 	add.w	r2, lr, #4294967295
  409000:	f080 8105 	bcs.w	40920e <__divdi3+0x26a>
  409004:	42bb      	cmp	r3, r7
  409006:	f240 8102 	bls.w	40920e <__divdi3+0x26a>
  40900a:	f1ae 0e02 	sub.w	lr, lr, #2
  40900e:	442f      	add	r7, r5
  409010:	1aff      	subs	r7, r7, r3
  409012:	b2a4      	uxth	r4, r4
  409014:	fbb7 f3f1 	udiv	r3, r7, r1
  409018:	fb01 7713 	mls	r7, r1, r3, r7
  40901c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
  409020:	fb00 f003 	mul.w	r0, r0, r3
  409024:	42b8      	cmp	r0, r7
  409026:	d908      	bls.n	40903a <__divdi3+0x96>
  409028:	197f      	adds	r7, r7, r5
  40902a:	f103 32ff 	add.w	r2, r3, #4294967295
  40902e:	f080 80f0 	bcs.w	409212 <__divdi3+0x26e>
  409032:	42b8      	cmp	r0, r7
  409034:	f240 80ed 	bls.w	409212 <__divdi3+0x26e>
  409038:	3b02      	subs	r3, #2
  40903a:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
  40903e:	2200      	movs	r2, #0
  409040:	e003      	b.n	40904a <__divdi3+0xa6>
  409042:	428b      	cmp	r3, r1
  409044:	d90f      	bls.n	409066 <__divdi3+0xc2>
  409046:	2200      	movs	r2, #0
  409048:	4613      	mov	r3, r2
  40904a:	1c34      	adds	r4, r6, #0
  40904c:	bf18      	it	ne
  40904e:	2401      	movne	r4, #1
  409050:	4260      	negs	r0, r4
  409052:	f04f 0500 	mov.w	r5, #0
  409056:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
  40905a:	4058      	eors	r0, r3
  40905c:	4051      	eors	r1, r2
  40905e:	1900      	adds	r0, r0, r4
  409060:	4169      	adcs	r1, r5
  409062:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  409066:	fab3 f283 	clz	r2, r3
  40906a:	2a00      	cmp	r2, #0
  40906c:	f040 8086 	bne.w	40917c <__divdi3+0x1d8>
  409070:	428b      	cmp	r3, r1
  409072:	d302      	bcc.n	40907a <__divdi3+0xd6>
  409074:	4584      	cmp	ip, r0
  409076:	f200 80db 	bhi.w	409230 <__divdi3+0x28c>
  40907a:	2301      	movs	r3, #1
  40907c:	e7e5      	b.n	40904a <__divdi3+0xa6>
  40907e:	b912      	cbnz	r2, 409086 <__divdi3+0xe2>
  409080:	2301      	movs	r3, #1
  409082:	fbb3 f5f2 	udiv	r5, r3, r2
  409086:	fab5 f085 	clz	r0, r5
  40908a:	2800      	cmp	r0, #0
  40908c:	d13b      	bne.n	409106 <__divdi3+0x162>
  40908e:	1b78      	subs	r0, r7, r5
  409090:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  409094:	fa1f fc85 	uxth.w	ip, r5
  409098:	2201      	movs	r2, #1
  40909a:	fbb0 f8fe 	udiv	r8, r0, lr
  40909e:	0c21      	lsrs	r1, r4, #16
  4090a0:	fb0e 0718 	mls	r7, lr, r8, r0
  4090a4:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
  4090a8:	fb0c f308 	mul.w	r3, ip, r8
  4090ac:	42bb      	cmp	r3, r7
  4090ae:	d907      	bls.n	4090c0 <__divdi3+0x11c>
  4090b0:	197f      	adds	r7, r7, r5
  4090b2:	f108 31ff 	add.w	r1, r8, #4294967295
  4090b6:	d202      	bcs.n	4090be <__divdi3+0x11a>
  4090b8:	42bb      	cmp	r3, r7
  4090ba:	f200 80bd 	bhi.w	409238 <__divdi3+0x294>
  4090be:	4688      	mov	r8, r1
  4090c0:	1aff      	subs	r7, r7, r3
  4090c2:	b2a4      	uxth	r4, r4
  4090c4:	fbb7 f3fe 	udiv	r3, r7, lr
  4090c8:	fb0e 7713 	mls	r7, lr, r3, r7
  4090cc:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
  4090d0:	fb0c fc03 	mul.w	ip, ip, r3
  4090d4:	45bc      	cmp	ip, r7
  4090d6:	d907      	bls.n	4090e8 <__divdi3+0x144>
  4090d8:	197f      	adds	r7, r7, r5
  4090da:	f103 31ff 	add.w	r1, r3, #4294967295
  4090de:	d202      	bcs.n	4090e6 <__divdi3+0x142>
  4090e0:	45bc      	cmp	ip, r7
  4090e2:	f200 80a7 	bhi.w	409234 <__divdi3+0x290>
  4090e6:	460b      	mov	r3, r1
  4090e8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  4090ec:	e7ad      	b.n	40904a <__divdi3+0xa6>
  4090ee:	4252      	negs	r2, r2
  4090f0:	ea6f 0606 	mvn.w	r6, r6
  4090f4:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4090f8:	e75d      	b.n	408fb6 <__divdi3+0x12>
  4090fa:	4240      	negs	r0, r0
  4090fc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  409100:	f04f 36ff 	mov.w	r6, #4294967295
  409104:	e754      	b.n	408fb0 <__divdi3+0xc>
  409106:	f1c0 0220 	rsb	r2, r0, #32
  40910a:	fa24 f102 	lsr.w	r1, r4, r2
  40910e:	fa07 f300 	lsl.w	r3, r7, r0
  409112:	4085      	lsls	r5, r0
  409114:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  409118:	40d7      	lsrs	r7, r2
  40911a:	4319      	orrs	r1, r3
  40911c:	fbb7 f2fe 	udiv	r2, r7, lr
  409120:	0c0b      	lsrs	r3, r1, #16
  409122:	fb0e 7712 	mls	r7, lr, r2, r7
  409126:	fa1f fc85 	uxth.w	ip, r5
  40912a:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
  40912e:	fb0c f702 	mul.w	r7, ip, r2
  409132:	429f      	cmp	r7, r3
  409134:	fa04 f400 	lsl.w	r4, r4, r0
  409138:	d907      	bls.n	40914a <__divdi3+0x1a6>
  40913a:	195b      	adds	r3, r3, r5
  40913c:	f102 30ff 	add.w	r0, r2, #4294967295
  409140:	d274      	bcs.n	40922c <__divdi3+0x288>
  409142:	429f      	cmp	r7, r3
  409144:	d972      	bls.n	40922c <__divdi3+0x288>
  409146:	3a02      	subs	r2, #2
  409148:	442b      	add	r3, r5
  40914a:	1bdf      	subs	r7, r3, r7
  40914c:	b289      	uxth	r1, r1
  40914e:	fbb7 f8fe 	udiv	r8, r7, lr
  409152:	fb0e 7318 	mls	r3, lr, r8, r7
  409156:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
  40915a:	fb0c f708 	mul.w	r7, ip, r8
  40915e:	429f      	cmp	r7, r3
  409160:	d908      	bls.n	409174 <__divdi3+0x1d0>
  409162:	195b      	adds	r3, r3, r5
  409164:	f108 31ff 	add.w	r1, r8, #4294967295
  409168:	d25c      	bcs.n	409224 <__divdi3+0x280>
  40916a:	429f      	cmp	r7, r3
  40916c:	d95a      	bls.n	409224 <__divdi3+0x280>
  40916e:	f1a8 0802 	sub.w	r8, r8, #2
  409172:	442b      	add	r3, r5
  409174:	1bd8      	subs	r0, r3, r7
  409176:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
  40917a:	e78e      	b.n	40909a <__divdi3+0xf6>
  40917c:	f1c2 0320 	rsb	r3, r2, #32
  409180:	fa2c f103 	lsr.w	r1, ip, r3
  409184:	fa0e fe02 	lsl.w	lr, lr, r2
  409188:	fa20 f703 	lsr.w	r7, r0, r3
  40918c:	ea41 0e0e 	orr.w	lr, r1, lr
  409190:	fa08 f002 	lsl.w	r0, r8, r2
  409194:	fa28 f103 	lsr.w	r1, r8, r3
  409198:	ea4f 451e 	mov.w	r5, lr, lsr #16
  40919c:	4338      	orrs	r0, r7
  40919e:	fbb1 f8f5 	udiv	r8, r1, r5
  4091a2:	0c03      	lsrs	r3, r0, #16
  4091a4:	fb05 1118 	mls	r1, r5, r8, r1
  4091a8:	fa1f f78e 	uxth.w	r7, lr
  4091ac:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  4091b0:	fb07 f308 	mul.w	r3, r7, r8
  4091b4:	428b      	cmp	r3, r1
  4091b6:	fa0c fc02 	lsl.w	ip, ip, r2
  4091ba:	d909      	bls.n	4091d0 <__divdi3+0x22c>
  4091bc:	eb11 010e 	adds.w	r1, r1, lr
  4091c0:	f108 39ff 	add.w	r9, r8, #4294967295
  4091c4:	d230      	bcs.n	409228 <__divdi3+0x284>
  4091c6:	428b      	cmp	r3, r1
  4091c8:	d92e      	bls.n	409228 <__divdi3+0x284>
  4091ca:	f1a8 0802 	sub.w	r8, r8, #2
  4091ce:	4471      	add	r1, lr
  4091d0:	1ac9      	subs	r1, r1, r3
  4091d2:	b280      	uxth	r0, r0
  4091d4:	fbb1 f3f5 	udiv	r3, r1, r5
  4091d8:	fb05 1113 	mls	r1, r5, r3, r1
  4091dc:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  4091e0:	fb07 f703 	mul.w	r7, r7, r3
  4091e4:	428f      	cmp	r7, r1
  4091e6:	d908      	bls.n	4091fa <__divdi3+0x256>
  4091e8:	eb11 010e 	adds.w	r1, r1, lr
  4091ec:	f103 30ff 	add.w	r0, r3, #4294967295
  4091f0:	d216      	bcs.n	409220 <__divdi3+0x27c>
  4091f2:	428f      	cmp	r7, r1
  4091f4:	d914      	bls.n	409220 <__divdi3+0x27c>
  4091f6:	3b02      	subs	r3, #2
  4091f8:	4471      	add	r1, lr
  4091fa:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  4091fe:	1bc9      	subs	r1, r1, r7
  409200:	fba3 890c 	umull	r8, r9, r3, ip
  409204:	4549      	cmp	r1, r9
  409206:	d309      	bcc.n	40921c <__divdi3+0x278>
  409208:	d005      	beq.n	409216 <__divdi3+0x272>
  40920a:	2200      	movs	r2, #0
  40920c:	e71d      	b.n	40904a <__divdi3+0xa6>
  40920e:	4696      	mov	lr, r2
  409210:	e6fe      	b.n	409010 <__divdi3+0x6c>
  409212:	4613      	mov	r3, r2
  409214:	e711      	b.n	40903a <__divdi3+0x96>
  409216:	4094      	lsls	r4, r2
  409218:	4544      	cmp	r4, r8
  40921a:	d2f6      	bcs.n	40920a <__divdi3+0x266>
  40921c:	3b01      	subs	r3, #1
  40921e:	e7f4      	b.n	40920a <__divdi3+0x266>
  409220:	4603      	mov	r3, r0
  409222:	e7ea      	b.n	4091fa <__divdi3+0x256>
  409224:	4688      	mov	r8, r1
  409226:	e7a5      	b.n	409174 <__divdi3+0x1d0>
  409228:	46c8      	mov	r8, r9
  40922a:	e7d1      	b.n	4091d0 <__divdi3+0x22c>
  40922c:	4602      	mov	r2, r0
  40922e:	e78c      	b.n	40914a <__divdi3+0x1a6>
  409230:	4613      	mov	r3, r2
  409232:	e70a      	b.n	40904a <__divdi3+0xa6>
  409234:	3b02      	subs	r3, #2
  409236:	e757      	b.n	4090e8 <__divdi3+0x144>
  409238:	f1a8 0802 	sub.w	r8, r8, #2
  40923c:	442f      	add	r7, r5
  40923e:	e73f      	b.n	4090c0 <__divdi3+0x11c>

00409240 <__udivdi3>:
  409240:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  409244:	2b00      	cmp	r3, #0
  409246:	d144      	bne.n	4092d2 <__udivdi3+0x92>
  409248:	428a      	cmp	r2, r1
  40924a:	4615      	mov	r5, r2
  40924c:	4604      	mov	r4, r0
  40924e:	d94f      	bls.n	4092f0 <__udivdi3+0xb0>
  409250:	fab2 f782 	clz	r7, r2
  409254:	460e      	mov	r6, r1
  409256:	b14f      	cbz	r7, 40926c <__udivdi3+0x2c>
  409258:	f1c7 0320 	rsb	r3, r7, #32
  40925c:	40b9      	lsls	r1, r7
  40925e:	fa20 f603 	lsr.w	r6, r0, r3
  409262:	fa02 f507 	lsl.w	r5, r2, r7
  409266:	430e      	orrs	r6, r1
  409268:	fa00 f407 	lsl.w	r4, r0, r7
  40926c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  409270:	0c23      	lsrs	r3, r4, #16
  409272:	fbb6 f0fe 	udiv	r0, r6, lr
  409276:	b2af      	uxth	r7, r5
  409278:	fb0e 6110 	mls	r1, lr, r0, r6
  40927c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  409280:	fb07 f100 	mul.w	r1, r7, r0
  409284:	4299      	cmp	r1, r3
  409286:	d909      	bls.n	40929c <__udivdi3+0x5c>
  409288:	195b      	adds	r3, r3, r5
  40928a:	f100 32ff 	add.w	r2, r0, #4294967295
  40928e:	f080 80ec 	bcs.w	40946a <__udivdi3+0x22a>
  409292:	4299      	cmp	r1, r3
  409294:	f240 80e9 	bls.w	40946a <__udivdi3+0x22a>
  409298:	3802      	subs	r0, #2
  40929a:	442b      	add	r3, r5
  40929c:	1a5a      	subs	r2, r3, r1
  40929e:	b2a4      	uxth	r4, r4
  4092a0:	fbb2 f3fe 	udiv	r3, r2, lr
  4092a4:	fb0e 2213 	mls	r2, lr, r3, r2
  4092a8:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
  4092ac:	fb07 f703 	mul.w	r7, r7, r3
  4092b0:	4297      	cmp	r7, r2
  4092b2:	d908      	bls.n	4092c6 <__udivdi3+0x86>
  4092b4:	1952      	adds	r2, r2, r5
  4092b6:	f103 31ff 	add.w	r1, r3, #4294967295
  4092ba:	f080 80d8 	bcs.w	40946e <__udivdi3+0x22e>
  4092be:	4297      	cmp	r7, r2
  4092c0:	f240 80d5 	bls.w	40946e <__udivdi3+0x22e>
  4092c4:	3b02      	subs	r3, #2
  4092c6:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
  4092ca:	2600      	movs	r6, #0
  4092cc:	4631      	mov	r1, r6
  4092ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4092d2:	428b      	cmp	r3, r1
  4092d4:	d847      	bhi.n	409366 <__udivdi3+0x126>
  4092d6:	fab3 f683 	clz	r6, r3
  4092da:	2e00      	cmp	r6, #0
  4092dc:	d148      	bne.n	409370 <__udivdi3+0x130>
  4092de:	428b      	cmp	r3, r1
  4092e0:	d302      	bcc.n	4092e8 <__udivdi3+0xa8>
  4092e2:	4282      	cmp	r2, r0
  4092e4:	f200 80cd 	bhi.w	409482 <__udivdi3+0x242>
  4092e8:	2001      	movs	r0, #1
  4092ea:	4631      	mov	r1, r6
  4092ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4092f0:	b912      	cbnz	r2, 4092f8 <__udivdi3+0xb8>
  4092f2:	2501      	movs	r5, #1
  4092f4:	fbb5 f5f2 	udiv	r5, r5, r2
  4092f8:	fab5 f885 	clz	r8, r5
  4092fc:	f1b8 0f00 	cmp.w	r8, #0
  409300:	d177      	bne.n	4093f2 <__udivdi3+0x1b2>
  409302:	1b4a      	subs	r2, r1, r5
  409304:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  409308:	b2af      	uxth	r7, r5
  40930a:	2601      	movs	r6, #1
  40930c:	fbb2 f0fe 	udiv	r0, r2, lr
  409310:	0c23      	lsrs	r3, r4, #16
  409312:	fb0e 2110 	mls	r1, lr, r0, r2
  409316:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  40931a:	fb07 f300 	mul.w	r3, r7, r0
  40931e:	428b      	cmp	r3, r1
  409320:	d907      	bls.n	409332 <__udivdi3+0xf2>
  409322:	1949      	adds	r1, r1, r5
  409324:	f100 32ff 	add.w	r2, r0, #4294967295
  409328:	d202      	bcs.n	409330 <__udivdi3+0xf0>
  40932a:	428b      	cmp	r3, r1
  40932c:	f200 80ba 	bhi.w	4094a4 <__udivdi3+0x264>
  409330:	4610      	mov	r0, r2
  409332:	1ac9      	subs	r1, r1, r3
  409334:	b2a4      	uxth	r4, r4
  409336:	fbb1 f3fe 	udiv	r3, r1, lr
  40933a:	fb0e 1113 	mls	r1, lr, r3, r1
  40933e:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
  409342:	fb07 f703 	mul.w	r7, r7, r3
  409346:	42a7      	cmp	r7, r4
  409348:	d908      	bls.n	40935c <__udivdi3+0x11c>
  40934a:	1964      	adds	r4, r4, r5
  40934c:	f103 32ff 	add.w	r2, r3, #4294967295
  409350:	f080 808f 	bcs.w	409472 <__udivdi3+0x232>
  409354:	42a7      	cmp	r7, r4
  409356:	f240 808c 	bls.w	409472 <__udivdi3+0x232>
  40935a:	3b02      	subs	r3, #2
  40935c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
  409360:	4631      	mov	r1, r6
  409362:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409366:	2600      	movs	r6, #0
  409368:	4630      	mov	r0, r6
  40936a:	4631      	mov	r1, r6
  40936c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409370:	f1c6 0420 	rsb	r4, r6, #32
  409374:	fa22 f504 	lsr.w	r5, r2, r4
  409378:	40b3      	lsls	r3, r6
  40937a:	432b      	orrs	r3, r5
  40937c:	fa20 fc04 	lsr.w	ip, r0, r4
  409380:	fa01 f706 	lsl.w	r7, r1, r6
  409384:	fa21 f504 	lsr.w	r5, r1, r4
  409388:	ea4f 4e13 	mov.w	lr, r3, lsr #16
  40938c:	ea4c 0707 	orr.w	r7, ip, r7
  409390:	fbb5 f8fe 	udiv	r8, r5, lr
  409394:	0c39      	lsrs	r1, r7, #16
  409396:	fb0e 5518 	mls	r5, lr, r8, r5
  40939a:	fa1f fc83 	uxth.w	ip, r3
  40939e:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
  4093a2:	fb0c f108 	mul.w	r1, ip, r8
  4093a6:	42a9      	cmp	r1, r5
  4093a8:	fa02 f206 	lsl.w	r2, r2, r6
  4093ac:	d904      	bls.n	4093b8 <__udivdi3+0x178>
  4093ae:	18ed      	adds	r5, r5, r3
  4093b0:	f108 34ff 	add.w	r4, r8, #4294967295
  4093b4:	d367      	bcc.n	409486 <__udivdi3+0x246>
  4093b6:	46a0      	mov	r8, r4
  4093b8:	1a6d      	subs	r5, r5, r1
  4093ba:	b2bf      	uxth	r7, r7
  4093bc:	fbb5 f4fe 	udiv	r4, r5, lr
  4093c0:	fb0e 5514 	mls	r5, lr, r4, r5
  4093c4:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
  4093c8:	fb0c fc04 	mul.w	ip, ip, r4
  4093cc:	458c      	cmp	ip, r1
  4093ce:	d904      	bls.n	4093da <__udivdi3+0x19a>
  4093d0:	18c9      	adds	r1, r1, r3
  4093d2:	f104 35ff 	add.w	r5, r4, #4294967295
  4093d6:	d35c      	bcc.n	409492 <__udivdi3+0x252>
  4093d8:	462c      	mov	r4, r5
  4093da:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
  4093de:	ebcc 0101 	rsb	r1, ip, r1
  4093e2:	fba4 2302 	umull	r2, r3, r4, r2
  4093e6:	4299      	cmp	r1, r3
  4093e8:	d348      	bcc.n	40947c <__udivdi3+0x23c>
  4093ea:	d044      	beq.n	409476 <__udivdi3+0x236>
  4093ec:	4620      	mov	r0, r4
  4093ee:	2600      	movs	r6, #0
  4093f0:	e76c      	b.n	4092cc <__udivdi3+0x8c>
  4093f2:	f1c8 0420 	rsb	r4, r8, #32
  4093f6:	fa01 f308 	lsl.w	r3, r1, r8
  4093fa:	fa05 f508 	lsl.w	r5, r5, r8
  4093fe:	fa20 f704 	lsr.w	r7, r0, r4
  409402:	40e1      	lsrs	r1, r4
  409404:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  409408:	431f      	orrs	r7, r3
  40940a:	fbb1 f6fe 	udiv	r6, r1, lr
  40940e:	0c3a      	lsrs	r2, r7, #16
  409410:	fb0e 1116 	mls	r1, lr, r6, r1
  409414:	fa1f fc85 	uxth.w	ip, r5
  409418:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
  40941c:	fb0c f206 	mul.w	r2, ip, r6
  409420:	429a      	cmp	r2, r3
  409422:	fa00 f408 	lsl.w	r4, r0, r8
  409426:	d907      	bls.n	409438 <__udivdi3+0x1f8>
  409428:	195b      	adds	r3, r3, r5
  40942a:	f106 31ff 	add.w	r1, r6, #4294967295
  40942e:	d237      	bcs.n	4094a0 <__udivdi3+0x260>
  409430:	429a      	cmp	r2, r3
  409432:	d935      	bls.n	4094a0 <__udivdi3+0x260>
  409434:	3e02      	subs	r6, #2
  409436:	442b      	add	r3, r5
  409438:	1a9b      	subs	r3, r3, r2
  40943a:	b2bf      	uxth	r7, r7
  40943c:	fbb3 f0fe 	udiv	r0, r3, lr
  409440:	fb0e 3310 	mls	r3, lr, r0, r3
  409444:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
  409448:	fb0c f100 	mul.w	r1, ip, r0
  40944c:	4299      	cmp	r1, r3
  40944e:	d907      	bls.n	409460 <__udivdi3+0x220>
  409450:	195b      	adds	r3, r3, r5
  409452:	f100 32ff 	add.w	r2, r0, #4294967295
  409456:	d221      	bcs.n	40949c <__udivdi3+0x25c>
  409458:	4299      	cmp	r1, r3
  40945a:	d91f      	bls.n	40949c <__udivdi3+0x25c>
  40945c:	3802      	subs	r0, #2
  40945e:	442b      	add	r3, r5
  409460:	1a5a      	subs	r2, r3, r1
  409462:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
  409466:	4667      	mov	r7, ip
  409468:	e750      	b.n	40930c <__udivdi3+0xcc>
  40946a:	4610      	mov	r0, r2
  40946c:	e716      	b.n	40929c <__udivdi3+0x5c>
  40946e:	460b      	mov	r3, r1
  409470:	e729      	b.n	4092c6 <__udivdi3+0x86>
  409472:	4613      	mov	r3, r2
  409474:	e772      	b.n	40935c <__udivdi3+0x11c>
  409476:	40b0      	lsls	r0, r6
  409478:	4290      	cmp	r0, r2
  40947a:	d2b7      	bcs.n	4093ec <__udivdi3+0x1ac>
  40947c:	1e60      	subs	r0, r4, #1
  40947e:	2600      	movs	r6, #0
  409480:	e724      	b.n	4092cc <__udivdi3+0x8c>
  409482:	4630      	mov	r0, r6
  409484:	e722      	b.n	4092cc <__udivdi3+0x8c>
  409486:	42a9      	cmp	r1, r5
  409488:	d995      	bls.n	4093b6 <__udivdi3+0x176>
  40948a:	f1a8 0802 	sub.w	r8, r8, #2
  40948e:	441d      	add	r5, r3
  409490:	e792      	b.n	4093b8 <__udivdi3+0x178>
  409492:	458c      	cmp	ip, r1
  409494:	d9a0      	bls.n	4093d8 <__udivdi3+0x198>
  409496:	3c02      	subs	r4, #2
  409498:	4419      	add	r1, r3
  40949a:	e79e      	b.n	4093da <__udivdi3+0x19a>
  40949c:	4610      	mov	r0, r2
  40949e:	e7df      	b.n	409460 <__udivdi3+0x220>
  4094a0:	460e      	mov	r6, r1
  4094a2:	e7c9      	b.n	409438 <__udivdi3+0x1f8>
  4094a4:	3802      	subs	r0, #2
  4094a6:	4429      	add	r1, r5
  4094a8:	e743      	b.n	409332 <__udivdi3+0xf2>
  4094aa:	bf00      	nop

004094ac <all_twi_definitions>:
  4094ac:	c600 4000 c700 4000 0008 0000 0008 0000     ...@...@........
  4094bc:	0600 4002 0700 4002 0009 0000 0009 0000     ...@...@........
  4094cc:	4600 4002 4700 4002 000e 0000 000e 0000     .F.@.G.@........
  4094dc:	8600 4001 8700 4001 0013 0000 0013 0000     ...@...@........
  4094ec:	c600 4001 c700 4001 0014 0000 0014 0000     ...@...@........
  4094fc:	8600 4000 8700 4000 0015 0000 0015 0000     ...@...@........
  40950c:	0600 4004 0700 4004 0016 0000 0016 0000     ...@...@........
  40951c:	4600 4003 4700 4003 0007 0000 0007 0000     .F.@.G.@........

0040952c <null_dma_control>:
	...
  409534:	2e2e 732f 6372 412f 4653 632f 6d6f 6f6d     ../src/ASF/commo
  409544:	2f6e 6573 7672 6369 7365 662f 6572 7265     n/services/freer
  409554:	6f74 2f73 6173 2f6d 7266 6565 7472 736f     tos/sam/freertos
  409564:	745f 6977 6d5f 7361 6574 2e72 0063 0000     _twi_master.c...
	...
  40957c:	000a 0000 0f03 0000 0000 0000 0000 0000     ................
  40958c:	000f 0000 0303 0000 0000 0000 0000 0000     ................
  40959c:	000a 0000 0303 0000 6863 7069 6f66 6e75     ........chipfoun
  4095ac:	0d64 000a 6f6e 2074 6f66 6e75 0d64 000a     d...not found...
  4095bc:	7962 6574 5b20 6425 3a5d 2520 0958 0000     byte [%d]: %X...
  4095cc:	2e2e 732f 6372 412f 4653 742f 6968 6472     ../src/ASF/third
  4095dc:	6170 7472 2f79 7266 6565 7472 736f 642f     party/freertos/d
  4095ec:	6d65 2f6f 6570 6972 6870 7265 6c61 635f     emo/peripheral_c
  4095fc:	6e6f 7274 6c6f 642f 6d65 2d6f 6174 6b73     ontrol/demo-task
  40960c:	2f73 5754 2d49 4545 5250 4d4f 742d 7361     s/TWI-EEPROM-tas
  40961c:	2e6b 0063 474d 5443 7361 006b 7854 0000     k.c.MGCTask.Tx..
  40962c:	2e2e 732f 6372 412f 4653 632f 6d6f 6f6d     ../src/ASF/commo
  40963c:	2f6e 6573 7672 6369 7365 662f 6572 7265     n/services/freer
  40964c:	6f74 2f73 6173 2f6d 7266 6565 7472 736f     tos/sam/freertos
  40965c:	705f 7265 7069 6568 6172 5f6c 6f63 746e     _peripheral_cont
  40966c:	6f72 2e6c 0063 0000 2e2e 732f 6372 412f     rol.c...../src/A
  40967c:	4653 632f 6d6f 6f6d 2f6e 6573 7672 6369     SF/common/servic
  40968c:	7365 662f 6572 7265 6f74 2f73 6173 2f6d     es/freertos/sam/
  40969c:	7266 6565 7472 736f 755f 6173 7472 735f     freertos_usart_s
  4096ac:	7265 6169 2e6c 0063                         erial.c.

004096b4 <all_usart_definitions>:
  4096b4:	c200 4000 c300 4000 0008 0000 0008 0000     ...@...@........
  4096c4:	0200 4002 0300 4002 0009 0000 0009 0000     ...@...@........
  4096d4:	4200 4002 4300 4002 000e 0000 000e 0000     .B.@.C.@........
  4096e4:	8200 4001 8300 4001 0013 0000 0013 0000     ...@...@........
  4096f4:	c200 4001 c300 4001 0014 0000 0014 0000     ...@...@........
  409704:	8200 4000 8300 4000 0015 0000 0015 0000     ...@...@........
  409714:	0200 4004 0300 4004 0016 0000 0016 0000     ...@...@........
  409724:	4200 4003 4300 4003 0007 0000 0007 0000     .B.@.C.@........
  409734:	0b10 2000 0032 0000 000a 0000 0500 0000     ... 2...........
  409744:	c200 0001 00c0 0000 0800 0000 0000 0000     ................
	...
  40975c:	2e2e 732f 6372 412f 4653 742f 6968 6472     ../src/ASF/third
  40976c:	6170 7472 2f79 7266 6565 7472 736f 642f     party/freertos/d
  40977c:	6d65 2f6f 6570 6972 6870 7265 6c61 635f     emo/peripheral_c
  40978c:	6e6f 7274 6c6f 642f 6d65 2d6f 6174 6b73     ontrol/demo-task
  40979c:	2f73 5355 5241 2d54 4c43 2d49 6174 6b73     s/USART-CLI-task
  4097ac:	632e 0000 7246 6565 5452 534f 6320 6d6f     .c..FreeRTOS com
  4097bc:	616d 646e 7320 7265 6576 2e72 0a0d 7954     mand server...Ty
  4097cc:	6570 4820 6c65 2070 6f74 7620 6569 2077     pe Help to view 
  4097dc:	2061 696c 7473 6f20 2066 6572 6967 7473     a list of regist
  4097ec:	7265 6465 6320 6d6f 616d 646e 2e73 0a0d     ered commands...
  4097fc:	0a0d 003e 0a0d 505b 6572 7373 4520 544e     ..>...[Press ENT
  40980c:	5245 7420 206f 7865 6365 7475 2065 6874     ER to execute th
  40981c:	2065 7270 7665 6f69 7375 6320 6d6f 616d     e previous comma
  40982c:	646e 6120 6167 6e69 0d5d 3e0a 0000 0000     nd again]..>....
  40983c:	5f55 4c43 0049 0000                         U_CLI...

00409844 <xHelpCommand>:
  409844:	9940 0040 9948 0040 1c41 0040 0000 0000     @.@.H.@.A.@.....
  409854:	2e2e 732f 6372 412f 4653 742f 6968 6472     ../src/ASF/third
  409864:	6170 7472 2f79 7266 6565 7472 736f 662f     party/freertos/f
  409874:	6572 7265 6f74 2d73 2e37 2e33 2f30 6f73     reertos-7.3.0/so
  409884:	7275 6563 462f 6572 5265 4f54 5f53 4c43     urce/FreeRTOS_CL
  409894:	2e49 0063 6e49 6f63 7272 6365 2074 6f63     I.c.Incorrect co
  4098a4:	6d6d 6e61 2064 6170 6172 656d 6574 2872     mmand parameter(
  4098b4:	2973 202e 4520 746e 7265 2220 6568 706c     s).  Enter "help
  4098c4:	2022 6f74 7620 6569 2077 2061 696c 7473     " to view a list
  4098d4:	6f20 2066 7661 6961 616c 6c62 2065 6f63      of available co
  4098e4:	6d6d 6e61 7364 0d2e 0d0a 000a 6f43 6d6d     mmands......Comm
  4098f4:	6e61 2064 6f6e 2074 6572 6f63 6e67 7369     and not recognis
  409904:	6465 202e 4520 746e 7265 2220 6568 706c     ed.  Enter "help
  409914:	2022 6f74 7620 6569 2077 2061 696c 7473     " to view a list
  409924:	6f20 2066 7661 6961 616c 6c62 2065 6f63      of available co
  409934:	6d6d 6e61 7364 0d2e 0d0a 000a 6568 706c     mmands......help
  409944:	0000 0000 0a0d 6568 706c 0d3a 200a 694c     ......help:.. Li
  409954:	7473 2073 6c61 206c 6874 2065 6572 6967     sts all the regi
  409964:	7473 7265 6465 6320 6d6f 616d 646e 0d73     stered commands.
  409974:	0d0a 000a 2e2e 732f 6372 412f 4653 742f     ....../src/ASF/t
  409984:	6968 6472 6170 7472 2f79 7266 6565 7472     hirdparty/freert
  409994:	736f 662f 6572 7265 6f74 2d73 2e37 2e33     os/freertos-7.3.
  4099a4:	2f30 6f73 7275 6563 712f 6575 6575 632e     0/source/queue.c
  4099b4:	0000 0000                                   ....

004099b8 <ucExpectedStackBytes.6040>:
  4099b8:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
  4099c8:	a5a5 a5a5 7325 0909 6325 2509 0975 7525     ....%s..%c.%u.%u
  4099d8:	2509 0d75 000a 0000 7325 0909 0930 3009     .%u.....%s..0..0
  4099e8:	2525 0a0d 0000 0000 7325 0909 7525 0909     %%......%s..%u..
  4099f8:	7525 2525 0a0d 0000 7325 0909 7525 0909     %u%%....%s..%u..
  409a08:	313c 2525 0a0d 0000 2e2e 732f 6372 412f     <1%%....../src/A
  409a18:	4653 742f 6968 6472 6170 7472 2f79 7266     SF/thirdparty/fr
  409a28:	6565 7472 736f 662f 6572 7265 6f74 2d73     eertos/freertos-
  409a38:	2e37 2e33 2f30 6f73 7275 6563 742f 7361     7.3.0/source/tas
  409a48:	736b 632e 0000 0000 4449 454c 0000 0000     ks.c....IDLE....
  409a58:	6d54 2072 7653 0063 2e2e 732f 6372 412f     Tmr Svc.../src/A
  409a68:	4653 742f 6968 6472 6170 7472 2f79 7266     SF/thirdparty/fr
  409a78:	6565 7472 736f 662f 6572 7265 6f74 2d73     eertos/freertos-
  409a88:	2e37 2e33 2f30 6f73 7275 6563 742f 6d69     7.3.0/source/tim
  409a98:	7265 2e73 0063 0000                         ers.c...

00409aa0 <create_task_command_definition>:
  409aa0:	9d38 0040 9d44 0040 3a81 0040 0001 0000     8.@.D.@..:@.....

00409ab0 <multi_parameter_echo_command_definition>:
  409ab0:	9dac 0040 9dbc 0040 3b31 0040 00ff 0000     ..@...@.1;@.....

00409ac0 <run_time_stats_command_definition>:
  409ac0:	9ee0 0040 9ef0 0040 3cb5 0040 0000 0000     ..@...@..<@.....
  409ad0:	2e2e 732f 6372 642f 6d65 2d6f 6174 6b73     ../src/demo-task
  409ae0:	2f73 4c43 2d49 6f63 6d6d 6e61 7364 632e     s/CLI-commands.c
  409af0:	0000 0000 6154 6b73 6420 6c65 7465 6465     ....Task deleted
  409b00:	0a0d 0000 6854 2065 6174 6b73 7720 7361     ....The task was
  409b10:	6e20 746f 7220 6e75 696e 676e 202e 4520      not running.  E
  409b20:	6578 7563 6574 7420 6568 6320 6572 7461     xecute the creat
  409b30:	2d65 6174 6b73 6320 6d6f 616d 646e 6620     e-task command f
  409b40:	7269 7473 0d2e 000a 6854 2065 6174 6b73     irst....The task
  409b50:	6820 7361 6120 726c 6165 7964 6220 6565      has already bee
  409b60:	206e 7263 6165 6574 2e64 4520 6578 7563     n created. Execu
  409b70:	6574 7420 6568 6420 6c65 7465 2d65 6174     te the delete-ta
  409b80:	6b73 6320 6d6f 616d 646e 6620 7269 7473     sk command first
  409b90:	0d2e 000a 7243 6165 6574 0064 6154 6b73     ....Created.Task
  409ba0:	6320 6572 7461 6465 0a0d 0000 6154 6b73      created....Task
  409bb0:	6e20 746f 6320 6572 7461 6465 0a0d 0000      not created....
  409bc0:	6854 2065 6170 6172 656d 6574 7372 7720     The parameters w
  409bd0:	7265 3a65 0a0d 0000 6c25 3a64 0020 0000     ere:....%ld: ...
  409be0:	6854 2065 6874 6572 2065 6170 6172 656d     The three parame
  409bf0:	6574 7372 7720 7265 3a65 0a0d 0000 0000     ters were:......
  409c00:	6154 6b73 2020 2020 2020 2020 2020 2020     Task            
  409c10:	6241 2073 6954 656d 2020 2020 2020 2025     Abs Time      % 
  409c20:	6954 656d 0a0d 2a2a 2a2a 2a2a 2a2a 2a2a     Time..**********
  409c30:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
  409c40:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 0a0d     **************..
  409c50:	0000 0000 6154 6b73 2020 2020 2020 2020     ....Task        
  409c60:	2020 7453 7461 2065 5020 6972 726f 7469       State  Priorit
  409c70:	2079 5320 6174 6b63 2309 0a0d 2a2a 2a2a     y  Stack.#..****
  409c80:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
  409c90:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
  409ca0:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 0a0d 0000     ************....
  409cb0:	7243 6165 6574 2064 6174 6b73 7220 6e75     Created task run
  409cc0:	696e 676e 202e 5220 6365 6965 6576 2064     ning.  Received 
  409cd0:	6170 6172 656d 6574 2072 6c25 0d64 0d0a     parameter %ld...
  409ce0:	000a 0000 6564 656c 6574 742d 7361 006b     ....delete-task.
  409cf0:	6564 656c 6574 742d 7361 3a6b 0a0d 4420     delete-task:.. D
  409d00:	6c65 7465 7365 7420 6568 7420 7361 206b     eletes the task 
  409d10:	7263 6165 6574 2064 7962 7420 6568 6320     created by the c
  409d20:	6572 7461 2d65 6174 6b73 6320 6d6f 616d     reate-task comma
  409d30:	646e 0a0d 0a0d 0000 7263 6165 6574 742d     nd......create-t
  409d40:	7361 006b 7263 6165 6574 742d 7361 206b     ask.create-task 
  409d50:	703c 7261 6d61 3a3e 0a0d 4320 6572 7461     <param>:.. Creat
  409d60:	7365 6120 6e20 7765 7420 7361 206b 6874     es a new task th
  409d70:	7461 7020 7265 6f69 6964 6163 6c6c 2079     at periodically 
  409d80:	7277 7469 7365 7420 6568 7020 7261 6d61     writes the param
  409d90:	7465 7265 7420 206f 6874 2065 4c43 2049     eter to the CLI 
  409da0:	756f 7074 7475 0a0d 0a0d 0000 6365 6f68     output......echo
  409db0:	702d 7261 6d61 7465 7265 0073 6365 6f68     -parameters.echo
  409dc0:	702d 7261 6d61 7465 7265 2073 2e3c 2e2e     -parameters <...
  409dd0:	3a3e 0a0d 5420 6b61 2065 6176 6972 6261     >:.. Take variab
  409de0:	656c 6e20 6d75 6562 2072 666f 7020 7261     le number of par
  409df0:	6d61 7465 7265 2c73 6520 6863 736f 6520     ameters, echos e
  409e00:	6361 2068 6e69 7420 7275 0d6e 0d0a 000a     ach in turn.....
  409e10:	6365 6f68 332d 702d 7261 6d61 7465 7265     echo-3-parameter
  409e20:	0073 0000 6365 6f68 332d 702d 7261 6d61     s...echo-3-param
  409e30:	7465 7265 2073 703c 7261 6d61 3e31 3c20     eters <param1> <
  409e40:	6170 6172 326d 203e 703c 7261 6d61 3e33     param2> <param3>
  409e50:	0d3a 200a 7845 6570 7463 2073 6874 6572     :.. Expects thre
  409e60:	2065 6170 6172 656d 6574 7372 202c 6365     e parameters, ec
  409e70:	6f68 2073 6165 6863 6920 206e 7574 6e72     hos each in turn
  409e80:	0a0d 0a0d 0000 0000 6174 6b73 732d 6174     ........task-sta
  409e90:	7374 0000 6174 6b73 732d 6174 7374 0d3a     ts..task-stats:.
  409ea0:	200a 6944 7073 616c 7379 6120 7420 6261     . Displays a tab
  409eb0:	656c 7320 6f68 6977 676e 7420 6568 7320     le showing the s
  409ec0:	6174 6574 6f20 2066 6165 6863 4620 6572     tate of each Fre
  409ed0:	5265 4f54 2053 6174 6b73 0a0d 0a0d 0000     eRTOS task......
  409ee0:	7572 2d6e 6974 656d 732d 6174 7374 0000     run-time-stats..
  409ef0:	7572 2d6e 6974 656d 732d 6174 7374 0d3a     run-time-stats:.
  409f00:	200a 6944 7073 616c 7379 6120 7420 6261     . Displays a tab
  409f10:	656c 7320 6f68 6977 676e 6820 776f 6d20     le showing how m
  409f20:	6375 2068 7270 636f 7365 6973 676e 7420     uch processing t
  409f30:	6d69 2065 6165 6863 4620 6572 5265 4f54     ime each FreeRTO
  409f40:	2053 6174 6b73 6820 7361 7520 6573 0d64     S task has used.
  409f50:	0d0a 000a                                   ....

00409f54 <delete_task_command_definition>:
  409f54:	9ce4 0040 9cf0 0040 3a21 0040 0000 0000     ..@...@.!:@.....

00409f64 <task_stats_command_definition>:
  409f64:	9e88 0040 9e94 0040 3ced 0040 0000 0000     ..@...@..<@.....

00409f74 <three_parameter_echo_command_definition>:
  409f74:	9e10 0040 9e24 0040 3bed 0040 0003 0000     ..@.$.@..;@.....
  409f84:	454c 2044 6974 656d 0072 0000 2e2e 732f     LED timer...../s
  409f94:	6372 6d2f 6961 2e6e 0063 0000 7250 6e69     rc/main.c...Prin
  409fa4:	2074 6974 656d 0072 0043 0000               t timer.C...

00409fb0 <_global_impure_ptr>:
  409fb0:	0020 2000                                    .. 

00409fb4 <zeroes.6911>:
  409fb4:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

00409fc4 <blanks.6910>:
  409fc4:	2020 2020 2020 2020 2020 2020 2020 2020                     
  409fd4:	4e49 0046 6e69 0066 414e 004e 616e 006e     INF.inf.NAN.nan.
  409fe4:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
  409ff4:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
  40a004:	6463 6665 0000 0000 6e28 6c75 296c 0000     cdef....(null)..
  40a014:	0030 0000                                   0...

0040a018 <_ctype_>:
  40a018:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
  40a028:	2020 2020 2020 2020 2020 2020 2020 2020                     
  40a038:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
  40a048:	0410 0404 0404 0404 0404 1004 1010 1010     ................
  40a058:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
  40a068:	0101 0101 0101 0101 0101 0101 1010 1010     ................
  40a078:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
  40a088:	0202 0202 0202 0202 0202 0202 1010 1010     ................
  40a098:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
  40a11c:	6e49 6966 696e 7974 0000 0000 614e 004e     Infinity....NaN.
  40a12c:	4f50 4953 0058 0000 002e 0000               POSIX.......

0040a138 <__mprec_tens>:
  40a138:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
  40a148:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
  40a158:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
  40a168:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
  40a178:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
  40a188:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
  40a198:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
  40a1a8:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
  40a1b8:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
  40a1c8:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
  40a1d8:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
  40a1e8:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
  40a1f8:	9db4 79d9 7843 44ea                         ...yCx.D

0040a200 <p05.5302>:
  40a200:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

0040a210 <__mprec_bigtens>:
  40a210:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
  40a220:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
  40a230:	bf3c 7f73 4fdd 7515                         <.s..O.u

0040a238 <_init>:
  40a238:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40a23a:	bf00      	nop
  40a23c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40a23e:	bc08      	pop	{r3}
  40a240:	469e      	mov	lr, r3
  40a242:	4770      	bx	lr

0040a244 <__init_array_start>:
  40a244:	00405c41 	.word	0x00405c41

0040a248 <__frame_dummy_init_array_entry>:
  40a248:	0040016d                                m.@.

0040a24c <_fini>:
  40a24c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40a24e:	bf00      	nop
  40a250:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40a252:	bc08      	pop	{r3}
  40a254:	469e      	mov	lr, r3
  40a256:	4770      	bx	lr

0040a258 <__fini_array_start>:
  40a258:	00400149 	.word	0x00400149
